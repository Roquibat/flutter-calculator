valuealphaopacityredgreenblue	withAlphawithOpacitywithRed	withGreenwithBlue_linearizeColorComponentcomputeLuminancelerp
alphaBlendgetAlphaFromOpacity==hashCodetoStringclearsrcdstsrcOverdstOversrcIndstInsrcOutdstOutsrcATopdstATopxorplusmodulatescreenoverlaydarkenlighten
colorDodge	colorBurn	hardLight	softLight
difference	exclusionmultiplyhue
saturationcolor
luminositynonelowmediumhighbuttroundsquaremiterbevelfillstrokehardEdge	antiAliasantiAliasWithSaveLayer_data_kIsAntiAliasIndex_kColorIndex_kBlendModeIndex_kStyleIndex_kStrokeWidthIndex_kStrokeCapIndex_kStrokeJoinIndex_kStrokeMiterLimitIndex_kFilterQualityIndex_kMaskFilterIndex_kMaskFilterBlurStyleIndex_kMaskFilterSigmaIndex_kInvertColorIndex_kIsAntiAliasOffset_kColorOffset_kBlendModeOffset_kStyleOffset_kStrokeWidthOffset_kStrokeCapOffset_kStrokeJoinOffset_kStrokeMiterLimitOffset_kFilterQualityOffset_kMaskFilterOffset_kMaskFilterBlurStyleOffset_kMaskFilterSigmaOffset_kInvertColorOffset_kDataByteCount_objects_ensureObjectsInitialized_kShaderIndex_kColorFilterIndex_kImageFilterIndex_kObjectCountisAntiAlias_kColorDefault_kBlendModeDefault	blendModestylestrokeWidth	strokeCap
strokeJoin_kStrokeMiterLimitDefaultstrokeMiterLimit
maskFilterfilterQualityshadercolorFilterimageFilterinvertColorssRGBextendedSRGBrawRgbarawStraightRgbarawUnmodifiedrawExtendedRgba128pngrgba8888bgra8888rgbaFloat32_imageonCreate	onDispose_debugStackwidthheight	_disposeddisposedebugDisposed
toByteData
colorSpacedebugGetOpenHandleStackTracesclone	isCloneOf_toByteData_dispose_handlesdurationimage
frameCountrepetitionCountgetNextFrame_cachedFrameCount_frameCount_cachedRepetitionCount_repetitionCount_getNextFramenonZeroevenOdd	intersectunionreverseDifferencefillTypemoveTorelativeMoveTolineTorelativeLineToquadraticBezierTorelativeQuadraticBezierTocubicTorelativeCubicToconicTorelativeConicToarcTo
arcToPointrelativeArcToPointaddRectaddOvaladdArc
addPolygonaddRRectaddPathextendWithPathcloseresetcontainsshift	transform	getBoundscombinecomputeMetrics_constructor_clone_getFillType_setFillType_arcTo_arcToPoint_relativeArcToPoint_addRect_addOval_addArc_addPolygon	_addRRect_addPath_addPathWithMatrix_extendWithPath_extendWithPathAndMatrix	_contains_shift
_transform
_getBounds_oppositionvectorangle	_iteratoriterator_pathMetric_pathMeasurecurrentmoveNextlengthisClosedcontourIndex_measuregetTangentForOffsetextractPath_length
_getPosTan_extractPath	_isClosed_nextContour_nativeNextContourcurrentContourIndexnormalsolidouterinner_style_sigma	_TypeNone	_TypeBlur_color
_blendMode_matrix_type
_kTypeMode_kTypeMatrix_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGamma_toNativeImageFilter_toNativeColorFilter_shortDescriptioncreator	_initMode_initMatrix_initLinearToSrgbGamma_initSrgbToLinearGammadatanativeFiltersigmaXsigmaYtileMode_modeStringradiusXradiusYinnerFilterouterFilter	_initBlur_initDilate
_initErode_initColorFilter_initComposed_debugDisposedclamprepeatedmirrordecal_initLinear_initRadial_initConical
_initSweep_validateColorStops_initWithImage
_debugName	fromAsset_shaderRegistry_reinitializeShader_uniformFloatCount_samplerCount_initFromAssetfragmentShader_kEmptyFloat32List_floatssetFloatsetImageSampler_setImageSampler_validateSamplers	trianglestriangleStriptriangleFan_initpointslinespolygonsave	saveLayerrestorerestoreToCountgetSaveCount	translatescalerotateskewgetTransformclipRect	clipRRectclipPathgetLocalClipBoundsgetDestinationClipBounds	drawColordrawLine	drawPaintdrawRect	drawRRect
drawDRRectdrawOval
drawCircledrawArcdrawPath	drawImagedrawImageRectdrawImageNinedrawPicturedrawParagraph
drawPointsdrawRawPointsdrawVertices	drawAtlasdrawRawAtlas
drawShadow	_recorder_sorted_saveLayerWithoutBounds
_saveLayer_scale_getTransform	_clipRect
_clipRRect	_clipPath_getLocalClipBounds_getDestinationClipBounds
_drawColor	_drawLine
_drawPaint	_drawRect
_drawRRect_drawDRRect	_drawOval_drawCircle_drawArc	_drawPath
_drawImage_drawImageRect_drawImageNine_drawPicture_drawPoints_drawVertices
_drawAtlas_drawShadowtoImagetoImageSyncapproximateBytesUsed_toImage_toImageSyncisRecordingendRecording_endRecording_canvas_kBytesPerShadow	_kXOffset	_kYOffset_kBlurOffsetoffset
blurRadiusconvertRadiusToSigma	blurSigmatoPaintlerpList_encodeShadowsfromUint8ListfromFilePath_initFromFileencodedbytesPerPixelinstantiateCodec_initEncoded_initRaw_width	_getWidth_height
_getHeight_bytesPerPixel_getBytesPerPixel_instantiateCodecmessagestackW_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaint
ColorSpaceImageByteFormatPixelFormatImageEventCallbackImage_Image
_wrapImageImageDecoderCallback	FrameInfoCodec_NativeCodecinstantiateImageCodecinstantiateImageCodecFromBufferinstantiateImageCodecWithSize_getDefaultImageSizeTargetImageSizeCallbackTargetImageSizedecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayer_NativeEngineLayerPath_NativePathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgramFragmentShader
VertexModeVertices	PointModeClipOpCanvas_NativeCanvasPictureEventCallbackPicture_NativePicturePictureRecorder_NativePictureRecorderShadowImmutableBufferImageDescriptor_NativeImageDescriptor	_Callback_CallbackWithError_Callbacker_CallbackerWithError	_futurize_futurizeWithErrorPictureRasterizationExceptiondartuiboolRecthasNaNRRectOffsetdxisNaNdyFloat64ListlengtheverydoublevalueisFiniteRadiusxy	withAlphaalpharoundclampintfromRGBOfromARGBmathpowHSVColormaterialColorstransparentCurveselasticInOutAnimationController	_clampInt_lerpInttoIntredgreenblueclampDoubleoverrideObject	identicalruntimeTypehashCodeStringtoRadixStringpadLeftsrcdstclear	saveLayerrestore	blendModesrcOverdstInsrcOutsrcIndstOutdstATopdstOversrcATopplusmultiplyscreenoverlaymodulate	hardLight
colorDodge	colorBurncolor	exclusion
difference
luminosityhue	softLight
saturationblurBackdropFilternonelowmediumhighfilterQualitymatrix	drawImagedrawImageRectdrawImageNine	drawAtlas	strokeCapAsquarestrokeWidthbuttdrawPath
drawPoints
strokeJoinstrokeMiterLimitstyle
drawCirclehardEdge	antiAliasantiAliasWithSaveLayerisAntiAliaspragmaByteDataListfilledgetInt32_kFakeHostEndiansetInt32indexvaluesfillstroke
getFloat32
setFloat32miterbevel	_TypeNone	_TypeBlur_style_sigmadebugDisposed_validateSamplers	Exception
_debugNamecreator_toNativeColorFilter_toNativeImageFilterfromEnvironmenttoStringStringBufferwritetoStringAsFixed
toByteDataextendedSRGBrawExtendedRgba128
colorSpacevoidwidgets
StackTracecurrent_handlesaddcallMemoryAllocations	_disposedcontainsremoveisEmptydispose
StateErrorformatrawRgbaFuturesRGBUnsupportedErrormaphandle_debugStacktoList__imageNativeFieldWrapperClass1NativeInt32PointerVoidsymbolisLeaf	Uint8Listerrorencodedcallbackbuffer
asByteDataHandleSetwidthheightgetNextFramecloneDurationimage	CompletersyncdecodeErrorcompleteErrorcompletedurationmillisecondsdurationMillisecondsfuturefromUint8ListtargetWidthtargetHeightallowUpscalinggetTargetSizeintrinsicWidthintrinsicHeightinstantiateCodecthenrawrowBytespixelFormatcodec	frameInfofillTypecombinereverseDifferencexor	intersectSceneBuilderclipPath_clonenonZerozero
fromCircle_opextractPathIterablefromDoublelefttoprightbottomBoolradiusrotationlargeArc	clockwiseFloat32List_getValue32matrix4fromLTRBforceClosedgetTangentForOffsetcossinatan2computeMetricslineTomoveToIterableBaseIterator
RangeError_nextContourcurrentContourIndexisClosedcloseaddRectstartWithMoveTonextContour
maskFilter
drawShadowhashcolorFilterfromColorFiltermodelinearToSrgbGammasrgbToLinearGamma_type_listEquals_matrix_color
_blendModehashAll
_kTypeMode_kTypeMatrixfromList_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGammaImageFilteredpushBackdropFilterpushImageFiltersigmaXsigmaYtileModeradiusXradiusYMatrix4	diagonal3ArgumentErrordatainnerFilterinnerouterFilteroutermirrorrepeateddecaldilateerodecomposed_shortDescriptionshaderpaintingGradientLinearGradientRadialGradientBoxDecorationlinearradial	Int32ListiNoSuchMethodError
colorStopsfocalfocalRadiuspi
startAngleendAngle
isNotEmptyUripath
encodeFulltarget	microtask
_fromAssetWeakReferenceMap_initFromAsset	debugNamefragmentShader_uniformFloatCount_samplerCountdrawVertices	trianglestriangleStriptriangleFannew
Uint16ListcolorstextureCoordinatesindicesdrawRawPointsclipRectSceneendRecordingCustomPainterpaintsydoAntiAliasarcTo	ParagraphlayoutParagraphStyleParagraphBuilder	TextAlignParagraphConstraintspointslinespolygonRSTransformscosssintxtyisRecording_canvascullRectlargestminmax_objects_dataclipOpUint32stack_NativeParagraph_needsLayout_paint
addPicturedrawPicture	onDisposeUint64	_recorderonCreate	TextStylenormaloffset
blurRadiusscalelerp_lerpDoubleshadowIndex_kColorDefaultconvertRadiusToSigma_init_length_initFromFile_initEncodedTttoImageSyncwritelnNativeFieldWrapperClass1CodecEngineLayerPathIterableBaseIteratorImageFilterShaderCanvasPicturePictureRecorderImageDescriptor	ExceptionÕBÎ’ˆn7WèÁï2áª      	dart:coreÀm$ ÀP›n <€†€¤€µ€¶€Î€ï-Fz­®û‚E‚•‚æƒ6ƒ„ƒÕ„„„d„Š„‹„ª„ê„ù„û„ü……`…o…q…r…—…ñ† †††/†p†Î†İ†ß†à‡‡]‡l‡n‡o‡›‡Û‡İ‡Şˆˆˆfˆ¶‰‰-‰1‰a‰e‰q‰™‰ÖŠŠFŠNŠRŠ£Šò‹B‹n‹r‹~‹ËŒŒŒŒ-Œ1Œ„ŒÊŒØEKs™Àåë;‰·½Pu¬­íó@PuœÂÈ‘‘‘\‘i‘‘À‘â’’2’3’ˆ’’³’Ú“ “M“}“ƒ“Æ“Ì””R”ˆ”¾”ô•6•7•e•k•“•™•Á•ç––3–F–G–€–†–Õ–÷—&—'—Z—`—±—Ó—ù—ú˜1˜^˜_˜˜˜Æ˜Ç˜ÿ™,™-™v™¬™²™êšš5š9š:šƒšËšÑ›	›/›]››’›“›ãœœœNœgœ™œœœç#[v¦ª«ü)/g²¶·õŸ2ŸRŸrŸxŸ¹Ÿ½Ÿ¾ 	  c  ‡ Å ã¡#¡^¡›¡×¢¢¢¢<¢B¢Š¢Í¢Ó££j£©£ï£õ¤B¤Œ¤×¥#¥q¥Á¦¦_¦Œ¦’¦á§§6§K§b§w§†§®§¶§Ã§Ú§ü¨¨*¨n¨®¨ò©4©?©G©M©Q©R©•©Û©áª-ªtª¿««Y«™«Á¬ ¬¬¬F¬l¬£¬À¬Î­­^­¦­¯­Ì­ş®,®L®i®{®Æ¯¯b¯k¯q¯u¯v¯Ã¯É¯ô°'°b°f°g°s°–°¸°Ë°Ñ°ı±±±1±R±V±W±c±‰±Š±–±ä±æ±ç²²²k²µ²Ô²Ø³)³v³Å´´c´®´ò´öµFµ‘µâ¶.¶|¶É··[·ª·ğ¸¸¸]¸ª¸ô¹F¹“¹äº%º)ºPºTº¢ºã»4»»Ò¼!¼p¼‹¼¼¼¡¼ì¼ı½½]½p½¶½·½û¾¾=¾C¾ ¾©¾ª¾é¾ï¿>¿M¿S¿¿”¿ï¿ö¿÷À @6À @<À @‡À @˜À @À @àÀ @æÀ AAÀ AHÀ AIÀ A†À AŒÀ AÚÀ B+À BHÀ BNÀ BœÀ BÉÀ BÏÀ C.À C9À C:À CxÀ C~À C§À C­À CûÀ DÀ D`À DfÀ DµÀ DàÀ DëÀ DìÀ E4À EÀ EÎÀ EÜÀ EâÀ F!À F'À FtÀ F¼À FÌÀ FÒÀ GÀ G$À GÀ GŠÀ G‹À GØÀ H&À HpÀ HvÀ H°À H¶À IÀ IUÀ I[À I§À I­À J
À JÀ JÀ JcÀ J¶À KÀ KÀ KKÀ KQÀ KÀ KïÀ KõÀ LBÀ LHÀ L¦À L°À L±À MÀ MSÀ MÀ M£À MŞÀ MäÀ N6À N‚À NˆÀ NÕÀ NÛÀ O9À OCÀ ODÀ O“À O³À O¹À PÀ PÀ P]À P©À PİÀ PãÀ Q.À Q?À QEÀ Q¤À Q¯À Q°À QÿÀ RÀ R À RnÀ RtÀ RÄÀ SÀ S?À SEÀ SÀ S¡À S§À TÀ TÀ TÀ TbÀ T–À TœÀ TéÀ TïÀ UJÀ UQÀ URÀ U‘À U—À UæÀ V2À VXÀ V^À V¬À V²À WÀ WQÀ W¢À WñÀ X;À XAÀ XÀ X¥À X¦À XğÀ XöÀ YEÀ Y”À YšÀ YëÀ ZÀ ZÀ ZkÀ ZqÀ ZÑÀ Z×À ZçÀ ZíÀ [/À [wÀ [“À [İÀ [ôÀ \ À \À \IÀ \JÀ \•À \»À \ÁÀ ]À ]ZÀ ]‰À ]À ]àÀ ^,À ^RÀ ^XÀ ^¨À ^÷À _HÀ _NÀ _À _¿À _ÅÀ `#À `)À `9À `?À `À ` À `èÀ aÀ aNÀ aeÀ aˆÀ a‰À aÒÀ bÀ bÀ bXÀ b¦À b÷À cÀ cÀ chÀ cµÀ cäÀ cêÀ dIÀ dOÀ d_À deÀ dÀ dåÀ e5À e`À ekÀ elÀ eºÀ eÙÀ eßÀ f(À f9À f?À fÀ f§À f¨À f÷À gÀ gÀ geÀ gvÀ g|À gÛÀ gæÀ gçÀ h"À h(À htÀ hÁÀ hğÀ höÀ iXÀ ifÀ igÀ iºÀ iÀÀ jÀ jYÀ jˆÀ jÀ jïÀ jüÀ jıÀ kFÀ kpÀ kvÀ kÆÀ lÀ l]À lŠÀ lÀ lÜÀ m)À mXÀ m^À m¿À mÅÀ mÕÀ mÛÀ nÀ n[À nªÀ nÖÀ nãÀ näÀ o2À oJÀ oPÀ o’À o˜À oùÀ oÿÀ pÀ pÀ pNÀ p[À p\À p¥À p«À púÀ qÀ qÀ q`À qqÀ qwÀ q¯À qµÀ rÀ r%À r&À rrÀ r€À r†À rÕÀ rìÀ ròÀ s;À sLÀ sRÀ sŠÀ sÀ sñÀ sşÀ sÿÀ tMÀ tfÀ tlÀ t»À u
À uÀ u\À u©À uñÀ u÷À vFÀ vjÀ vpÀ vĞÀ vùÀ vúÀ wKÀ wdÀ wjÀ w³À w¹À xÀ xRÀ xxÀ x~À xÙÀ xßÀ xïÀ xõÀ yEÀ ynÀ y½À yîÀ yõÀ yöÀ zGÀ z`À zfÀ z¯À zÿÀ {,À {2À {À {“À {£À {©À {ëÀ |:À |PÀ |^À |_À |°À |ÉÀ |ÏÀ }À }À }gÀ }·À }ìÀ }òÀ ~OÀ ~UÀ ~eÀ ~kÀ ~¡À ~ïÀ =À FÀ GÀ ˜À ±À ·À € À €PÀ €}À €ƒÀ €åÀ €ëÀ €ûÀ À PÀ fÀ ±À ÊÀ ØÀ ÚÀ ÛÀ ‚3À ‚nÀ ‚rÀ ‚ÏÀ ƒÀ ƒÀ ƒoÀ ƒÃÀ „À „mÀ „qÀ „¿À „úÀ „şÀ …WÀ …[À …¨À …ğÀ †À †À †!À †%À †pÀ †©À †¿À †ÜÀ †÷À ‡À ‡5À ‡PÀ ‡eÀ ‡»À ‡ãÀ ‡äÀ ˆ(À ˆ.À ˆtÀ ˆ¹À ˆÁÀ ˆÂÀ ˆúÀ ‰ À ‰BÀ ‰qÀ ‰xÀ ‰yÀ ‰ÃÀ ‰ëÀ ‰ñÀ Š<À Š‰À ŠÒÀ ‹À ‹#À ‹SÀ ‹cÀ ‹iÀ ‹¸À ‹ìÀ ŒÀ ŒÀ ŒÀ Œ\À ŒiÀ ŒoÀ Œ½À ŒúÀ  À 'À -À À ÏÀ À  À MÀ UÀ WÀ XÀ |À €À À ’À ÇÀ 
À FÀ WÀ —À À îÀ RÀ XÀ ¦À ØÀ àÀ áÀ ‘À ‘"À ‘lÀ ‘¼À ’,À ’2À ’‚À ’§À ’°À ’±À ’ôÀ “9À “^À “dÀ “³À ”$À ”*À ”zÀ ”ŸÀ ”¥À ”óÀ •À •À •À • À •JÀ •NÀ •›À •ßÀ •ãÀ •ñÀ •õÀ –AÀ –MÀ –ˆÀ –ÅÀ –×À —À —À —|À —‚À —ÊÀ ˜À ˜&À ˜,À ˜<À ˜BÀ ˜À ˜¡À ˜òÀ ™+À ™4À ™5À ™jÀ ™pÀ ™×À ™İÀ š%À šuÀ šÀ š‡À š—À šÀ šëÀ šüÀ ›À ›À ›TÀ ›†À ›ŒÀ ›óÀ ›ùÀ œAÀ œ‘À œÀ œ£À œ³À œ¹À À À !À #À $À ^À bÀ yÀ µÀ ÊÀ À #À $À jÀ °À ×À ßÀ àÀ Ÿ$À ŸjÀ Ÿ±À ŸïÀ ŸùÀ ŸûÀ ŸüÀ  +À  7À  MÀ  SÀ  À  ïÀ  õÀ ¡AÀ ¡WÀ ¡¤À ¡ıÀ ¢RÀ ¢kÀ ¢sÀ ¢tÀ ¢ À ¢¦À ¢ÿÀ £0À £6À £vÀ £|À £ÔÀ ¤/À ¤5À ¤EÀ ¤KÀ ¤§À ¤ËÀ ¤×À ¤ØÀ ¤÷À ¤ıÀ ¥IÀ ¥OÀ ¥¢À ¥¨À ¥ïÀ ¥õÀ ¦JÀ ¦iÀ ¦ÀÀ ¦ÆÀ ¦ÖÀ ¦ÜÀ §$À §oÀ § À §ıÀ ¨
À ¨À ¨WÀ ¨]À ¨°À ©À ©+À ©1À ©ƒÀ ©ĞÀ ª"À ªtÀ ªzÀ ªÊÀ «À «hÀ «¸À «şÀ ¬À ¬À ¬À ¬hÀ ¬‚À ¬„À ¬…À ¬ÇÀ ¬ËÀ ­À ­0À ­>À ­†À ­œÀ ­§À ­¨À ­×À ­ÜÀ ®'À ®rÀ ®ÁÀ ¯À ¯^À ¯cÀ ¯³À °À °À °À °bÀ °cÀ °„À ° À °ÔÀ °ÕÀ ± À ±%À ±NÀ ±sÀ ±À ±ÇÀ ±ñÀ ²!À ²NÀ ²xÀ ²¬À ²ÜÀ ³À ³	À ³KÀ ³À ³¿À ³õÀ ´7À ´uÀ ´µÀ µÀ µGÀ µ‡À µÙÀ ¶#À ¶eÀ ¶fÀ ¶§À ¶éÀ ¶êÀ ·.À ·OÀ ·kÀ ·†À ·‡À ·µÀ ·øÀ ·üÀ ·ıÀ ¸#À ¸NÀ ¸yÀ ¸ÍÀ ¸ÎÀ ¹À ¹"À ¹(À ¹@À ¹YÀ ¹ À ¹¤À ¹ÄÀ ºÀ º>À ºeÀ º©À º­À º®À ºæÀ »À »À »PÀ »VÀ »vÀ »|À »ŒÀ »’À »ØÀ ¼	À ¼QÀ ¼WÀ ¼ŸÀ ¼´À ¼ÈÀ ½À ½=À ½AÀ ½\À ½’À ½ĞÀ ½ÔÀ ½ÕÀ ¾À ¾NÀ ¾OÀ ¾›À ¾¡À ¾ãÀ ¿4À ¿…À ¿¦À ¿¬À ¿ùÀ ÀÀ À À ÀGÀ ÀMÀ À]À ÀcÀ À²À ÀæÀ Á0À ÁFÀ ÁbÀ Á¯À ÁêÀ ÁîÀ ÂÀ ÂKÀ ÂÀ Â‘À Â’À ÂÖÀ ÂÜÀ ÃÀ Ã À ÃrÀ ÃvÀ Ã™À Ã¾À ÃüÀ Ä À ÄÀ Ä;À ÄŠÀ ÄÇÀ ÄÍÀ Å
À Å%À ÅiÀ ÅmÀ ÅÀ Å±À Å÷À ÅûÀ ÅüÀ Æ=À ÆmÀ ÆsÀ Æ¥À ÆÁÀ ÇÀ ÇÀ Ç:À Ç_À Ç¡À Ç¥À Ç¦À ÇçÀ ÇíÀ È>À È‰À ÈÀ ÈÉÀ ÈÏÀ ÈíÀ ÈóÀ É\À ÉbÀ ÉÉÀ ÉÏÀ Ê6À Ê<À ÊˆÀ ÊÙÀ ÊåÀ ÊëÀ ÊûÀ ËÀ ËPÀ Ë|À ËÅÀ ÌÀ Ì"À ÌvÀ ÌzÀ ÌŸÀ ÌÄÀ ÍÀ ÍÀ ÍÀ ÍDÀ Í{À Í|À ÍÇÀ ÎÀ Î`À Î­À ÎûÀ ÏÀ ÏFÀ ÏLÀ ÏšÀ Ï¾À ÏÄÀ Ğ-À Ğ3À ĞœÀ Ğ¢À ÑÀ ÑÀ Ñ]À Ñ®À ÑºÀ ÑÀÀ ÑĞÀ ÑÖÀ Ò À Ò;À Ò„À Ò¤À ÒíÀ ÒñÀ ÓÀ ÓVÀ Ó¡À Ó¥À Ó¦À ÓöÀ Ô4À Ô:À Ô^À Ô}À ÔÁÀ ÔâÀ Ô÷À ÕÀ Õ8À Õ“À ÕÚÀ ÕåÀ ÕëÀ ÕüÀ Ö À Ö&À Ö?À Ö‘À ÖÙÀ ×!À ×.À ×{À ×­À ×ÿÀ ØXÀ Ø©À Ø¯À Ø³À Ø´À ÙÀ ÙZÀ Ù¦À Ù¬À ÙÔÀ Ú!À ÚEÀ ÚŸÀ Ú£À ÚÎÀ ÚóÀ Û9À Û=À Û>À ÛxÀ Û~À Û´À ÛºÀ ÛÊÀ ÛĞÀ ÜÀ ÜDÀ ÜvÀ Ü¾À ÜÕÀ İÀ İ	À İ'À İ7À İEÀ İtÀ İ«À İ´À İÇÀ İÑÀ İáÀ ŞÀ Ş0À ŞÀ ŞšÀ Ş¢À ŞµÀ Ş¿À Ş÷À ŞûÀ ŞüÀ ßCÀ ßUÀ ß[À ß€À ß†À ß×À ßøÀ àOÀ àqÀ àuÀ àÀ àãÀ áÀ á!À áOÀ áWÀ ádÀ áªÀ á°À á´À áµÀ áğÀ áöÀ â=À âWÀ â]À âkÀ â˜À â²À âÄÀ âŞÀ ã.À ã9À ãAÀ ãKÀ ãQÀ ãaÀ ãgÀ ã¢À ãÃÀ äÀ ä<À ä@À ähÀ äÀ äŸÀ äÍÀ äÕÀ äâÀ å#À åyÀ å¤À åèÀ åğÀ åöÀ åúÀ åûÀ æ:À æ@À æŒÀ æÖÀ çÀ ç!À çhÀ çlÀ çÀ ç×À çÛÀ çÜÀ çèÀ çşÀ è7À èVÀ è\À èŒÀ è§À èÃÀ èìÀ é
À é*À éfÀ éuÀ é˜À é À éÉÀ éîÀ éöÀ ê"À ê_À ê´À ê¾À êÍÀ êóÀ êûÀ ëÀ ëÀ ë1À ëbÀ ëzÀ ë€À ë°À ëØÀ ëğÀ ëöÀ ì'À ìSÀ ìkÀ ìqÀ ìÀ ìÍÀ ìåÀ ìëÀ í	À íDÀ í\À íbÀ í‘À íÒÀ íêÀ íğÀ î
À î=À îUÀ î[À îzÀ î·À îÏÀ îÕÀ îíÀ ï&À ï,À ïCÀ ïaÀ ïeÀ ïgÀ ïhÀ ï³À ï·À ïúÀ ğDÀ ğÀ ğÁÀ ğÅÀ ğøÀ ğüÀ ñ4À ñFÀ ñbÀ ñhÀ ñµÀ ñáÀ ñçÀ òÀ ò"À òoÀ ò½À òõÀ ó.À ó>À ó@À óAÀ óƒÀ ó›À óéÀ ô6À ô~À ôÈÀ ôßÀ ôöÀ ôüÀ õZÀ õeÀ õfÀ õ†À õŒÀ õåÀ õøÀ õùÀ öÀ öÀ ölÀ ö§À ö¸À ö¹À ößÀ öåÀ ÷1À ÷^À ÷dÀ ÷yÀ ÷À ÷À ÷«À ÷ËÀ ÷ÑÀ øÀ ø7À øÀ øÏÀ øğÀ ù
À ù$À ù>À ùXÀ ùcÀ ùkÀ ùuÀ ù‹À ùŒÀ ùÀ ù¤À ùôÀ úBÀ úÀ úÛÀ û$À û*À û{À û‡À ûÀ ûÀ û£À üÀ üGÀ üNÀ üPÀ üQÀ üÀ ü£À üñÀ ıAÀ ıtÀ ı€À ıÀ ıĞÀ şÀ şRÀ ş^À ş_À ş¯À şöÀ ÿEÀ ÿ€À ÿÀ ÿ‘À ÿ’À ÿ¾À ÿ÷À ÿøÀ .À 2À rÀ vÀ ÄÀ ÜÀ àÀ/À~ÀÅÀÀ[ÀiÀmÀ¹ÀÀOÀSÀaÀeÀÓÀ"ÀHÀ—À¥À×ÀçÀÀ"À,ÀKÀeÀiÀjÀ‹À§À¾À¿ÀıÀÀNÀÀ±ÀØÀÙÀÀÀiÀ¬ÀÍÀõÀöÀÀÀVÀiÀjÀ¬ÀÀÀÁÀÛÀ	(À	YÀ	_À	°À	ËÀ	ÑÀ
À
gÀ
¶À
ÖÀ
éÀÀ1À]ÀsÀªÀ¿ÀâÀúÀ ÀÀÀIÀOÀÀ³ÀÎÀâÀòÀÀ!À+À™ÀÀÀÓÀÙÀ%À5À;À€ÀÏÀÀÀiÀ‚ÀÒÀ!ÀkÀ·ÀÀ9ÀgÀkÀlÀ¨À®ÀúÀIÀuÀ{ÀÊÀÀKÀ—ÀÄÀâÀÀ4ÀBÀbÀpÀ˜À§ÀõÀûÀÿÀ ÀQÀsÀyÀ¹ÀïÀÀÀqÀ„ÀÀ¡À¥À¦À×ÀİÀ,À{ÀÌÀÀdÀ²ÀşÀÀ"ÀpÀ™ÀŸÀçÀ8ÀNÀTÀŠÀÀÀ¹ÀÙÀñÀ÷À/ÀnÀÀ×ÀèÀúÀÀjÀ¸ÀŞÀÀÀ@ÀHÀNÀpÀ¤ÀïÀÀ]À¡ÀŞÀ÷ÀıÀ9ÀiÀoÀŒÀ¦À¬ÀÎÀìÀ À À À 1À TÀ ZÀ uÀ {À À ×À áÀ çÀ!À!À!$À!*À!oÀ!½À!áÀ!óÀ"À" À"KÀ"œÀ"êÀ#,À#5À#;À#ZÀ#…À#‰À#ŠÀ#ÖÀ$À$"À$oÀ$¹À%	À%XÀ%¢À%ïÀ&(À&)À&5À&_À&aÀ&bÀ&|À&±À&úÀ'À'À'hÀ'ŠÀ'¦À'´À'µÀ(À(À(À(oÀ(ŠÀ(‹À(àÀ))À)vÀ)¦À)İÀ)îÀ*À*À*#À*+À*/À*0À*lÀ*ÂÀ+À+À+6À+IÀ+aÀ+mÀ+…À+ÒÀ+êÀ,4À,lÀ,sÀ,‰À,™À,À,À,éÀ-À-PÀ-lÀ-mÀ-–À-—À-İÀ-üÀ-ıÀ.	À.9À.;À.<À.VÀ.wÀ.«À.­À.®À.àÀ/À/À/QÀ/UÀ/‘À/«À/¯À/ùÀ0BÀ0À0ÖÀ1!À1JÀ1NÀ1‡À1‹À1—À1£À1İÀ2À2<À2‰À2ÔÀ2ñÀ3=À3\À3}À3ƒÀ3‹À3À3¥À3©À3µÀ3ÂÀ3üÀ4=À4}À4¼À5À5"À5qÀ5¹À5ÚÀ5àÀ5èÀ5úÀ6DÀ6`À6fÀ6¤À6ÀÀ6şÀ6ÿÀ7.À74À7À7œÀ7À7ÆÀ7ÌÀ8À8À8fÀ8{À8}À8~À8À8¢À8êÀ9À9À9@À9]À9tÀ9šÀ9°À9±À9àÀ9æÀ:À:?À:ZÀ:[À:ƒÀ:‰À:ÍÀ:ÓÀ;$À;*À;kÀ;›À;¿À;ÀÀ<À<3À<9À<„À<©À<»À<½À<¾À=
À=À=XÀ=sÀ=xÀ=±À=ÏÀ=ãÀ=äÀ=şÀ=ÿÀ>À>FÀ>GÀ>›À>»À>¼À>ÛÀ>ÜÀ>èÀ?2À?3À?ŒÀ?±À?²À?¾À?éÀ@1À@™À@´À@×ÀA8ÀABÀA{ÀAŠÀA²ÀAîÀB0ÀB<ÀBDÀBLÀBeÀBƒÀB‰ÀB¦ÀBªÀB«ÀBçÀC8ÀCˆÀC‰ÀC•ÀC×ÀCòÀCôÀCõÀDÀDÀDkÀD»ÀE	ÀE,ÀE0ÀE‚ÀEĞÀEëÀF+ÀFPÀF¡ÀFçÀG3ÀGƒÀG–ÀGšÀGåÀH/ÀHÀHÎÀIÀIkÀIºÀJÀJ>ÀJBÀJŒÀJÖÀK&ÀKbÀKfÀK³ÀK¿ÀKäÀKøÀLÀL!ÀL?ÀLJÀL–ÀLÀÀLÌÀLêÀM
ÀM.ÀM3ÀM5ÀM6ÀMYÀM]ÀM¬ÀMüÀNJÀNmÀNqÀNÅÀOÀOLÀOPÀO¢ÀOòÀOşÀPÀPMÀP—ÀPçÀQ6ÀQ‚ÀQÓÀR"ÀRjÀR¦ÀRªÀRôÀS>ÀSÀSÊÀSÎÀTÀT'ÀT+ÀTPÀTTÀT¤ÀTïÀU:ÀUbÀU‘ÀU­ÀUÁÀUÖÀUôÀUùÀV!ÀV-ÀVlÀV‰ÀVÍÀVõÀVÿÀWFÀWpÀWzÀW‚ÀWÊÀWÑÀWÖÀWØÀWÙÀWüÀX ÀXKÀXOÀXœÀXëÀY*ÀY.ÀYwÀYÆÀYÜÀYàÀZ.ÀZ{ÀZÇÀ[À[WÀ[§À[÷À\GÀ\~À\‚À\ÌÀ]À]JÀ]NÀ]›À]§À]«À]ĞÀ]ÔÀ^$À^oÀ^ºÀ^âÀ_À_+À_UÀ_`À_ŠÀ_ÖÀ_ŞÀ`9À`xÀ`¹À`áÀaÀa-Àa4ÀaBÀaXÀa\Àa^Àa_Àa¯ÀaÑÀaÓÀaÔÀb#ÀbLÀbPÀb^ÀbbÀb¬ÀbÍÀc	ÀcÀc6Àc9Àc:ÀcÀcƒÀc‘Àc•ÀcáÀdÀdGÀd_Àd‹Àd‘ÀdàÀdøÀe+ÀeWÀe…Àe†Àe´ÀeºÀf	ÀfYÀf§ÀfôÀgÀg%Àg[ÀgoÀgpÀgŸÀg¥ÀgõÀhDÀh‘ÀhßÀi	ÀiÀiEÀiZÀi[ÀigÀi£Ài¥Ài¦ÀiïÀióÀjBÀjÀj×Àk!ÀkNÀkPÀkQÀk¯ÀkèÀl"Àl?ÀlAÀlBÀlÀlƒÀlÑÀmÀm4Àm8Àm„ÀmÕÀnÀnÀncÀn­ÀnıÀoLÀo˜ÀoéÀp8Àp€Àp¼ÀpÀÀq
ÀqTÀq¤ÀqàÀqüÀrÀrÀr+ÀrAÀrdÀruÀr‰ÀrÀr¼ÀrÁÀrŞÀsÀsÀs4ÀsjÀsnÀsoÀs—Às¼ÀsúÀt
Àt Àt8ÀtTÀtqÀtzÀt{Àt˜ÀtŞÀuÀuÀu[Àu‡Àu‘Àu™ÀušÀu«ÀuÆÀuêÀvÀvÀv8Àv|Àv—Àv³Àv¾ÀväÀw Àw Àw!ÀwMÀwYÀw_ÀwaÀwbÀw¯Àw¿ÀwÃÀwúÀxÀxXÀx^Àx¯ÀxşÀyMÀyxÀy~Ày¶ÀyÁÀyÂÀzÀz
Àz[Àz¬Àz²ÀzëÀzöÀzøÀzùÀ{À{!À{/À{3À{‚À{¨À{½À{ñÀ{÷À|EÀ|À|ÑÀ|×À|çÀ|íÀ}<À}VÀ}dÀ}³À}ÙÀ}ßÀ~-À~{À~•À~›À~«À~âÀ~ïÀ:À@ÀÀÙÀ€À€À€bÀ€›À€¡À€ïÀCÀIÀYÀ–ÀÀÑÀ×À‚%À‚pÀ‚±À‚·À‚ÇÀ‚ÍÀƒÀƒ/ÀƒDÀƒFÀƒGÀƒ˜ÀƒµÀ„À„(À„.À„~À„ÇÀ…À…aÀ…{À…À…ĞÀ†À†VÀ†\À†§À†ÌÀ†ŞÀ†àÀ†áÀ‡9À‡ƒÀ‡ŸÀ‡¹À‡ºÀ‡ÆÀˆÀˆ)Àˆ+Àˆ,Àˆ^ÀˆbÀˆ§Àˆ«ÀˆîÀ‰-À‰AÀ‰EÀ‰‹À‰¶À‰ºÀ‰ùÀŠ<ÀŠdÀŠhÀŠ¬ÀŠåÀŠûÀ‹À‹À‹DÀ‹JÀ‹—À‹æÀŒ	ÀŒ=ÀŒmÀŒ„ÀŒˆÀŒ‰ÀŒÇÀŒÍÀÀ/ÀSÀTÀ‰À¬À­ÀõÀ"À#ÀjÀwÀšÀ›ÀâÀÀAÀBÀ…ÀÅÀÔÀÚÀKÀÀÀ‘À‘À‘JÀ‘‘À‘ÖÀ‘ãÀ’1À’2À’wÀ’¾À’ÍÀ’ÓÀ“@À“±À”À”À”IÀ”À”ÕÀ”êÀ•DÀ•EÀ•‹À•ÏÀ–À–[À–€À–†À–óÀ—dÀ—ªÀ—«À—ñÀ˜5À˜zÀ˜ÁÀ™À™/À™}À™~À™ÁÀ™ãÀ™éÀš,ÀšPÀšVÀšÀšİÀ›$À›hÀ›¯À›óÀœ!Àœ'ÀœlÀœ¢ÀœóÀœôÀCÀˆÀÀİÀ&ÀjÀ‘À—ÀÜÀŸ+ÀŸwÀŸ}ÀŸ ÀŸÁÀŸÜÀŸ÷À À À À hÀ ­À ³À çÀ íÀ¡<À¡ŠÀ¡ÍÀ¢À¢À¢`À¢®À¢ûÀ£À£-À£GÀ£hÀ£ƒÀ£À£¹À£¿À£ÀÀ¤À¤À¤9À¤:À¤|À¤ªÀ¤°À¥À¥PÀ¥kÀ¥lÀ¥´À¥ñÀ¦0À¦qÀ¦·À¦ûÀ§?À§KÀ§QÀ§½À¨-À¨3À¨£À©À©WÀ©XÀ©ªÀ©¸À©¾ÀªÀª2Àª8ÀªÀª³Àª´ÀªöÀ«9À«IÀ«gÀ«hÀ«®À«´À¬À¬OÀ¬zÀ¬¼À¬½À­À­BÀ­À­…À­ÒÀ®#À®NÀ®—À®˜À®İÀ¯À¯.À¯/À¯tÀ¯¸À¯ÓÀ¯ãÀ¯äÀ°4À°À° À°¦À°îÀ°ôÀ±9À±XÀ±YÀ±™À±ÈÀ±åÀ±æÀ²&À²VÀ²}À²~À²³À²¹À³	À³VÀ³¡À³àÀ³æÀ´7À´†À´ØÀµ%ÀµoÀµ½ÀµËÀ¶À¶$À¶%À¶qÀ¶„À¶ŠÀ¶ÚÀ·(À·bÀ·«À·×À¸(À¸;À¸AÀ¸¸À¸¼À¸½À¹À¹=À¹CÀ¹À¹×Àº&ÀºuÀº¿Àº÷ÀºıÀ»HÀ»•À»ŞÀ¼À¼À¼hÀ¼µÀ½À½HÀ½•À½âÀ¾1À¾À¾ĞÀ¾ÖÀ¿$À¿sÀ¿§À¿­À¿şÀÀIÀÀƒÀÀ…ÀÀ†ÀÀĞÀÀøÀÁÀÁÀÁkÀÁ°ÀÁÃÀÁÄÀÁıÀÂÀÂÀÂeÀÂ‹ÀÂŒÀÂ˜ÀÂÜÀÂèÀÃ)ÀÃ*ÀÃ~ÀÃÀÃÀÃøÀÄ$ÀÄ%ÀÄ1ÀÄÀÄ»ÀÄ¼ÀÄÈÀÅ.ÀÅdÀÅeÀÅqÀÅÏÀÅûÀÅüÀÆÀÆnÀÆ¤ÀÆ¥ÀÆ±ÀÇ*ÀÇyÀÇzÀÇ†ÀÈÀÈ2ÀÈeÀÈfÀÈrÀÈñÀÉLÀÉMÀÉYÀÉàÀÊCÀÊDÀÊPÀÊÇÀËÀËÀË#ÀË¢ÀËùÀËúÀÌÀÌXÀÌxÀÌ×ÀÌÛÀÌÜÀÍ_ÀÍåÀÍæÀÍòÀÎÀÎ6ÀÎQÀÎlÀÎ‡ÀÎÀÎ²ÀÎÖÀÏ0ÀÏ4ÀÏ5ÀÏ»ÀĞHÀĞIÀĞUÀĞpÀĞŠÀĞ«ÀĞÆÀĞáÀĞüÀÑÀÑ,ÀÑPÀÑ¼ÀÑÀÀÑÁÀÒOÀÒtÀÒŠÀÒ ÀÒ¶ÀÒÌÀÒãÀÒøÀÓÀÓÀÓÀÓ8ÀÓXÀÓ”ÀÓ˜ÀÓ™ÀÔÀÔXÀÔYÀÔeÀÔÀÔ¡ÀÔİÀÔáÀÔâÀÕQÀÕ¡ÀÕ¢ÀÕ®ÀÕïÀÖÀÖbÀÖfÀÖgÀÖåÀ×ZÀ×[À×gÀ×œÀ×ÎÀ×ÒÀ×ÓÀØ%ÀØbÀØcÀØoÀØÀØ°ÀØÔÀØØÀØÙÀÙ#ÀÙQÀÙRÀÙ^ÀÙ¡ÀÙÅÀÙàÀÚÀÚVÀÚcÀÚÀÚ¤ÀÚ¨ÀÚ©ÀÛ	ÀÛKÀÛLÀÛ¾ÀÜÀÜÀÜ+ÀÜuÀÜ™ÀÜ´ÀÜÜÀİ0Àİ=ÀİÀİ…Àİ‰ÀİŠÀİñÀŞ:ÀŞ;ÀŞ³ÀßÀßÀß&ÀßsÀßŒÀßÀß™ÀßæÀßÿÀà ÀàÀà,ÀàOÀàyÀà}Àà~ÀàŞÀáÀáÀáÀá8Àá\ÀáŠÀá²ÀáÃÀáÇÀáÈÀâÀâ[Àâ\ÀâhÀâÀâ¶ÀâäÀãÀãÀãÀãÀãlÀã«Àã¬Àã¸ÀãÍÀãøÀä6Àä:Àä;Àä€Àä¥Àä¦ÀåÀåQÀåRÀå^Àå™ÀåÆÀåÊÀåÌÀåÍÀæÀæÀæ!ÀæÀæÀæÀÀæÆÀæìÀçÀçÀç_ÀçeÀçºÀçæÀè#ÀèkÀèoÀèpÀèÀè•ÀèèÀé,ÀéEÀéFÀésÀéyÀéÊÀêÀê8ÀêOÀêPÀê€Àê†ÀêÖÀë%ÀëAÀëGÀë•ÀëäÀì3ÀìÀì’Àì×ÀíÀíÀíÀí[Àí_Àí°ÀíüÀîBÀîFÀîŒÀîÀîÜÀï+ÀïIÀïMÀï—ÀïçÀğÀğHÀğwÀğÍÀğÎÀğöÀğ÷ÀñÀñ5Àñ7Àñ8Àñ‡Àñ¡ÀñÜÀòÀòÀò#ÀòFÀòGÀòSÀònÀò¡ÀòÂÀòÚÀó=Àó™ÀôÀôÀôÀô6Àô:Àô;ÀôGÀô[Àô‚Àô²ÀôÅÀôËÀôãÀôõÀôùÀôûÀôüÀõ;Àõ?Àõ‡ÀõÒÀö ÀöDÀöHÀö–ÀöåÀ÷1À÷À÷ÏÀ÷İÀ÷ğÀøÀøLÀøÀøÁÀøÂÀøøÀøşÀùGÀù‘ÀùÚÀùñÀùòÀúÀúÀúkÀú±ÀûÀû Àû7Àû8ÀûcÀûiÀû¹Àü ÀüNÀüÀüÖÀüÜÀı*ÀızÀıÉÀşÀşÀşÀş<Àş=ÀşÀş´ÀşºÀÿ	ÀÿVÀÿnÀÿtÀÿ©Àÿ¯ÀÿõÀ 'À hÀ lÀ mÀ ¶À ¼À şÀBÀÀíÀñÀòÀşÀfÀhÀiÀ¤ÀÙÀşÀÀÀXÀšÀ›À¿À5ÀWÀ[À\À½ÀêÀëÀ/À_À­ÀğÀ+ÀGÀZÀgÀ}À£ÀÈÀÑÀ×ÀÛÀÜÀ7À}À~À½ÀäÀZÀˆÀËÀÜÀàÀáÀ	QÀ	¿À	ÀÀ	äÀ
ZÀ
~À
‚À
ƒÀ
áÀÀÀ:À?À”À¾ÀÖÀÀÀ/À5ÀFÀJÀKÀ¥ÀËÀÌÀÀÀ_ÀÀÀ‚À·ÀóÀÀ<À=ÀŠÀÍÀ×ÀØÀ&ÀrÀ À©ÀªÀ÷ÀHÀ‹À”À•ÀåÀóÀüÀşÀÿÀLÀœÀ®À²ÀÀÀaÀgÀ›À¡ÀòÀøÀGÀ•ÀåÀöÀüÀKÀQÀwÀ}ÀÀ“ÀàÀùÀ
ÀÀ À!À;ÀRÀSÀ™ÀäÀÀDÀEÀQÀtÀ“ÀµÀØÀÜÀİÀéÀÀÀ)ÀzÀ|À}ÀÎÀÀkÀ·ÀèÀìÀ5ÀBÀmÀºÀÀOÀUÀ¦ÀôÀ!À\ÀtÀ”À¬ÀÈÀÉÀÀZÀoÀuÀÂÀêÀğÀ#ÀVÀ‰À¼ÀïÀõÀDÀÀ–À¤ÀäÀûÀÀ)À@ÀJÀTÀZÀlÀrÀ“À™À§ÀåÀ À À 9À UÀ _À iÀ oÀ öÀ üÀ!
À!GÀ!jÀ!À!°À!ÓÀ!İÀ!çÀ!íÀ"vÀ"|À"ŠÀ"ËÀ"ñÀ#À#=À#cÀ#mÀ#wÀ#§À#¾À#ÙÀ#óÀ$À$À$^À$nÀ$–À$­À$ÈÀ$àÀ%	À%
À%XÀ%sÀ%›À%²À%ÍÀ%åÀ&À&À&&À&EÀ&dÀ&wÀ&xÀ&¨À&İÀ'!À'jÀ'³À'´À'ÌÀ'ØÀ(%À(&À(OÀ(dÀ({À(¯À(ÆÀ(ĞÀ(øÀ)À)?À)]À)tÀ)~À)ÉÀ)óÀ*À*LÀ*pÀ*¥À*´À*öÀ*üÀ+ À+À+À+0À+\À+pÀ+vÀ+–À+¶À+íÀ,À,:À,>À,?À,KÀ,`À,ŠÀ,íÀ,ñÀ,òÀ,şÀ-À-4À-KÀ-„À-À-ÌÀ-ğÀ."À.FÀ.xÀ.‡À.¬À.²À.¶À.·À.ÃÀ.ÙÀ.îÀ/À/>À/WÀ/†À/ªÀ/ÜÀ0 À02À0AÀ0İÀ0ãÀ0çÀ0éÀ0êÀ1(À1,À1|À1ÇÀ2À2/À2jÀ2ŒÀ2ÄÀ2ØÀ3À3À3À3BÀ3|À3À3ÉÀ3ÍÀ3üÀ4AÀ4UÀ4sÀ4wÀ4xÀ4§À4ìÀ5 À5À5"À5#À5qÀ5—À5´À5µÀ5õÀ6À6À6{À6°À6±À7À75À76À7šÀ7ÄÀ7ÅÀ8)À8SÀ8UÀ8VÀ8‰À8À8›À8ŸÀ8îÀ9;À9ŠÀ9²À9şÀ:)À:FÀ:˜À:ÅÀ:ÆÀ;À;qÀ;ÊÀ;ÎÀ;ÏÀ<À<bÀ<±À<ôÀ<øÀ<ùÀ==À=À=İÀ>À>#À>$À>hÀ>nÀ>¼À?À?8À?„À?¤À?âÀ?èÀ@JÀ@NÀ@OÀ@™À@ŸÀ@îÀA%ÀAJÀA¦ÀAîÀAòÀAóÀBDÀB‘ÀB¸ÀB¹ÀCÀC:ÀCZÀC\ÀC]ÀCÀCÚÀCÛÀCõÀDÀDÀD<ÀD€ÀDŒÀDÃÀDÄÀDĞÀEÀEÀE ÀEdÀEeÀEqÀE”ÀEÀÀEÔÀEÚÀFÀF1ÀFcÀFgÀFhÀFtÀF¼ÀF¾ÀF¿ÀF÷ÀG[ÀG\ÀGsÀGŠÀG¥ÀG¦ÀGºÀGüÀHÀH?ÀH@ÀH[ÀHsÀHÀHËÀHüÀI'ÀI-ÀI1ÀI2ÀI>ÀIˆÀI‰ÀI•ÀIàÀIáÀIíÀJÀJ<ÀJPÀJVÀJƒÀJ¥ÀJÇÀJîÀJòÀJóÀJÿÀK2ÀK4ÀK5ÀKgÀK¯ÀK°ÀKÈÀKàÀKáÀL%ÀL1ÀLhÀLiÀLuÀLµÀL¶ÀLÂÀMÀMÀMÀM3ÀM_ÀMsÀMyÀM ÀMÄÀMéÀMíÀMîÀMúÀN/ÀN1ÀN2ÀNcÀNªÀN«ÀNÃÀNÛÀNÜÀOÀO+ÀObÀOcÀOoÀO®ÀO¯ÀO»ÀOûÀOüÀPÀP+ÀPWÀPkÀPqÀP—ÀP»ÀPàÀPäÀPåÀPñÀQ&ÀQ(ÀQ)ÀQ\ÀQ­ÀQ®ÀQÏÀQğÀQñÀRÀRQÀR]ÀR”ÀR•ÀR¡ÀSÀSÀSÀSnÀSoÀS{ÀSÀSÊÀSŞÀSäÀTÀT8ÀTeÀTiÀTjÀTvÀT³ÀTµÀT¶ÀTõÀTùÀUIÀUœÀUàÀVÀVWÀVŒÀV¥ÀV¹ÀVıÀWÀWÀWOÀW•ÀWÆÀWßÀWóÀX$ÀX(ÀX)ÀXmÀX¿ÀXîÀYÀYÀYKÀYOÀYPÀY”ÀYšÀYèÀZ2ÀZcÀZ|ÀZ ÀZŞÀZäÀZøÀ[2À[6À[7À[iÀ[œÀ[µÀ[ÉÀ\À\3À\7À\8À\kÀ\ŸÀ\¸À\ÌÀ]"À]xÀ]±À]µÀ]¶À]öÀ^À^À^…À^ÌÀ^ÍÀ_6À_sÀ_tÀ_ÜÀ`À`À`sÀ`¸À`¹ÀaÀaUÀaVÀaÆÀbÀbÀbhÀbÀb«Àb­Àb®ÀbôÀc)Àc^Àc¨ÀcÄÀcàÀcîÀcïÀdÀdÀd8Àd>ÀdÀdªÀdÂÀdÒÀdóÀeÀeÀe%Àe)Àe*ÀezÀeÀe£ÀeğÀf:ÀfƒÀfÍÀfÓÀgÀg+Àg;ÀgZÀgwÀgŠÀg”Àg˜ÀgšÀg›ÀgğÀh	ÀhÀhZÀh¨ÀhõÀiEÀiIÀiÀiòÀjKÀj£ÀjöÀkÀk#Àk}Àk¢Àk¦Àk´Àk¸ÀküÀlFÀl–ÀlÀÀm
ÀmRÀmyÀmÆÀnÀn.ÀniÀnyÀnÓÀnÙÀo%ÀokÀoqÀoÉÀoéÀoïÀpRÀpµÀqÀq Àq!ÀqrÀqxÀqĞÀr.ÀrZÀr`ÀrºÀsÀsÀsƒÀséÀtNÀtZÀt[Àt®Àt´ÀuÀudÀuºÀuÕÀuÛÀv5Àv‹Àv Àv¦Àw
ÀwnÀwÑÀwÛÀwÜÀxÀx"Àx|Àx×ÀxçÀxíÀyFÀyfÀylÀyÏÀz2Àz”ÀzÀzŸÀz ÀzÑÀzùÀ{+À{TÀ{uÀ{yÀ{ŠÀ{ŒÀ{À{ÁÀ{éÀ|#À|LÀ|jÀ|À|±À|ÔÀ|óÀ}À}À}'À})À}*À}gÀ}‰À}«À}ØÀ}ñÀ~
À~#À~<À~MÀ~OÀ~PÀ~˜À~œÀ~îÀÀÀÀÀÀ‘À¶ÀëÀñÀ€@À€‘À€ÛÀ*À{ÀÌÀ‚À‚>À‚DÀ‚“À‚ÉÀ‚ÏÀƒ2Àƒ•ÀƒùÀ„_À„eÀ„°À„öÀ…À…À…dÀ…·À…÷À†
À†À†*À†DÀ†bÀ†ŠÀ†¤À†ÉÀ†ìÀ‡(À‡;À‡hÀ‡¬À‡éÀˆQÀˆeÀˆÀÀˆÄÀˆÅÀ‰À‰0À‰6À‰…À‰ÖÀŠ ÀŠoÀŠÀÀ‹À‹aÀ‹ƒÀ‹‰À‹×ÀŒÀŒÀŒvÀŒÙÀ=À£À©ÀúÀ@À[ÀaÀ®ÀÀAÀGÀ“ÀáÀ+ÀyÀÈÀíÀ‘ À‘À‘&À‘@À‘^À‘†À‘ À‘³À‘ĞÀ‘÷À’3À’FÀ’sÀ’°À“À“À“~À“ÚÀ”À”4À”À”«À•À•*À•¶À•¼À•ÀÀ•ÁÀ–À–/À–5À–€À–ÎÀ—	À—À—^À—¯À—ùÀ˜HÀ˜™À˜êÀ™:À™\À™bÀ™²À™óÀ™ùÀš[Àš½À› À›…À›‹À›ÚÀœ*ÀœMÀœSÀœ ÀœóÀ3ÀEÀXÀrÀÀ¸ÀÕÀøÀÀ9À_À›À®ÀÛÀŸÀŸ€ÀŸ”À 	À À À KÀ kÀ lÀ ÛÀ¡^À¡_À¡ŞÀ¡ûÀ¢À¢'À¢<À¢TÀ¢sÀ¢‡À¢¤À¢¥À£EÀ£cÀ£xÀ£À£§À£ºÀ£ÍÀ£åÀ£ıÀ¤À¤0À¤MÀ¤NÀ¤ÔÀ¤ğÀ¥À¥À¥4À¥SÀ¥gÀ¥€À¥—À¥³À¥´À¥×À¦À¦+À¦KÀ¦£À¦«À¦¸À¦èÀ§DÀ§LÀ§RÀ§VÀ§XÀ§YÀ§—À§¿À§åÀ§ëÀ¨'À¨vÀ¨¼À¨îÀ¨ôÀ©DÀ©“À©¡À©§À©îÀª4ÀªaÀªgÀª­ÀªıÀ«JÀ«gÀ«ƒÀ«ÑÀ«óÀ«úÀ¬À¬,À¬LÀ¬ŠÀ¬À¬¤À­À­0À­NÀ­TÀ­XÀ­YÀ­eÀ­xÀ­À­À­¡À­¢À­âÀ®À®À®À®ïÀ®ğÀ¯;À¯`À¯¨À¯ÄÀ¯ÆÀ¯ÇÀ°À°&À°*À°TÀ°¤À°âÀ°şÀ±.À±BÀ±vÀ±“À±²À±¸À±ÈÀ±åÀ±øÀ²À²À²À²À²À²cÀ²iÀ²²À²÷À³DÀ³ZÀ³˜À³İÀ´&À´pÀ´À´åÀµ/ÀµJÀµÀµ…Àµ·À¶À¶RÀ¶hÀ¶pÀ¶tÀ¶uÀ¶®À¶ÿÀ·MÀ·À·©À·öÀ¸(À¸)À¸^À¸©À¸÷À¹#À¹uÀ¹“À¹¡À¹§À¹¨À¹àÀ¹ûÀº	ÀºÀºÀºLÀºiÀºšÀº Àº¤Àº¥ÀºÁÀºàÀºáÀºıÀ»À»À»\À»|À»}À»ÙÀ¼À¼À¼AÀ¼•À¼—À¼˜À¼ËÀ¼ÏÀ½À½LÀ½œÀ½êÀ¾À¾À¾aÀ¾®À¾üÀ¿EÀ¿~À¿©ÀÀÀÀ.ÀÀ=ÀÀ_ÀÀ|ÀÀƒÀÀ‡ÀÀˆÀÀ¤ÀÀ¥ÀÀåÀÁÀÁÀÁFÀÁLÀÁšÀÁèÀÂ3ÀÂÀÂÑÀÂûÀÃÀÃHÀÃNÀÃ\ÀÃxÀÃšÀÃ¹ÀÃÔÀÃŞÀÃäÀÄ2ÀÄ<ÀÄBÀÄPÀÄ¡ÀÄÌÀÄıÀÅ.ÀÅ4ÀÅgÀÅ²ÀÅıÀÆHÀÆ“ÀÆ™ÀÆÀÀÆêÀÆòÀÆüÀÇÀÇOÀÇ¤ÀÇµÀÇ»ÀÈÀÈ0ÀÈ…ÀÈ¡ÀÈ¥ÀÈ¦ÀÈÜÀÈâÀÉ:ÀÉ}ÀÉƒÀÉĞÀÉñÀÊ"ÀÊvÀÊ¡ÀÊ¥ÀÊ¦ÀÊèÀÊîÀË=ÀË‰ÀËÄÀËĞÀËãÀËøÀÌÀÌ*ÀÌ.ÀÌ/ÀÌ”ÀÌúÀÌûÀÍfÀÍ£ÀÍ¤ÀÎ ÀÎ%ÀÎ&ÀÎyÀÎ•ÀÎ—ÀÎ˜ÀÎéÀÎíÀÏÀÏMÀÏ_ÀÏ§ÀÏ´ÀÏµÀĞÀĞÀĞÀĞfÀĞ{ÀĞÀĞÌÀÑ
ÀÑKÀÑZÀÑ\ÀÑ]ÀÑ•ÀÑ™ÀÑèÀÒ.ÀÒyÀÒÅÀÓÀÓ;ÀÓ?ÀÓŒÀÓÚÀÔ)ÀÔ9ÀÔ=ÀÔ‰ÀÔØÀÕ'ÀÕtÀÕÁÀÖÀÖ`ÀÖ­ÀÖÈÀÖÌÀ×À×cÀ×°À×ÒÀ×ÖÀØ%ÀØjÀØ·ÀÙÀÙYÀÙ©ÀÙÌÀÚÀÚJÀÚPÀÚÀÚëÀÛ9ÀÛ„ÀÛ³ÀÛ¹ÀÜÀÜ/ÀÜ5ÀÜ†ÀÜÔÀİ#Àİ`Àİ~Àİ„ÀİÓÀŞ"ÀŞ(ÀŞzÀŞ£ÀŞ©ÀŞùÀßJÀß›ÀßçÀà5Àà€ÀàËÀàÛÀàáÀá/ÀáYÀá_ÀáÀá£ÀáïÀâ@Àâ‘ÀâİÀãÀãÀã%ÀãCÀã\Àã‚ÀãšÀã¡ÀãàÀä+Àä1ÀäˆÀäßÀäåÀå Àå@ÀårÀå‘ÀåİÀæ$ÀæoÀæ|Àæ†ÀæÀæ”ÀæÚÀç*ÀçWÀçeÀç™ÀçºÀçÈÀçÿÀè$Àè2Àè3Àè£ÀèåÀèëÀèïÀèğÀéAÀépÀévÀéÄÀêÀê_ÀêªÀêÙÀêßÀë,ÀëvÀëÂÀìÀì$Àì*Àì{ÀìÊÀíÀíbÀí³ÀîÀî9Àî?ÀîÀîİÀï.ÀïwÀï°Àï¶ÀğÀğWÀğ¨ÀğøÀñBÀñÀñßÀòÀòÀò`Àò°ÀòÿÀó-Àó3ÀóqÀóÀó–Àó³ÀóÊÀóïÀôÀôÀô4Àô¤ÀôªÀôíÀõ8Àõ>Àõ•ÀõìÀõòÀöÀöMÀöƒÀö¢ÀöîÀ÷:À÷…À÷’À÷œÀ÷¤À÷ªÀ÷şÀø@ÀøFÀøJÀøKÀø­ÀøàÀùÀù;ÀùyÀù©ÀùÜÀùİÀú-ÀúPÀúcÀú{Àú‹Àú£Àú¶ÀúÀÀúĞÀúÔÀúÕÀû ÀûEÀûŠÀû¦Àû§ÀûÁÀüÀüÀü_ÀüuÀüÀü¤Àü´ÀüĞÀüãÀüíÀı^ÀıbÀıdÀıeÀı³Àı·ÀıóÀş7ÀşHÀşjÀşpÀş¾ÀÿÀÿAÀÿGÀÿ”ÀÿãÀÿùÀ À À >À DÀ ŠÀ À ÒÀ èÀ ñÀ òÀ(À.ÀpÀ†À‘À“À”ÀŞÀêÀîÀÀÀSÀaÀbÀ›À¨ÀªÀ«ÀàÀäÀ+ÀoÀ°À´ÀıÀMÀ–À³À·ÀÀPÀ…À‰ÀÖÀÀ-ÀpÀÀ”ÀİÀ%ÀuÀÄÀÀTÀZÀ¡À·À	À	À	PÀ	VÀ	‚À	ˆÀ	˜À	À	ïÀ
$À
3À
4À
…À
ÖÀ%ÀnÀ}ÀƒÀÏÀ ÀnÀ¶ÀÀNÀTÀ¡À§ÀËÀÑÀÀkÀ»ÀÀ0À6À„ÀÍÀÀlÀºÀ
ÀRÀÀ…ÀÏÀèÀîÀüÀ)ÀQÀhÀ¨ÀÑÀÀAÀ[ÀuÀ}À‡ÀÀÜÀ*ÀxÀ–ÀœÀªÀ×ÀÀBÀYÀ™ÀĞÀ	À#À+À5À;ÀŒÀÒÀÀ"À0À]ÀtÀÈÀÀÀ2À“ÀÌÀæÀîÀøÀşÀIÀ’ÀãÀÀ!ÀEÀKÀŠÀÀŞÀ,À}ÀÈÀÀeÀ°ÀûÀLÀÀ¸À¾ÀÎÀÔÀ$ÀFÀÀ¤ÀÑÀÒÀÀ1À7ÀvÀ|ÀÅÀ 	À À À xÀ ÅÀ!À!À!\À!bÀ!°À" À""À"DÀ"EÀ"ˆÀ"ÍÀ#À#IÀ#OÀ#tÀ#ŠÀ#‹À#ÛÀ$+À$SÀ$TÀ$£À$íÀ$şÀ%À%JÀ%\À%ƒÀ%„À%ÙÀ%øÀ%ùÀ&JÀ&–À&åÀ'À'1À'2À'‚À'½À'äÀ'åÀ(8À(À(ªÀ(°À)À)PÀ) À)ÍÀ)ëÀ)ìÀ*:À*QÀ*WÀ*­À*³À*÷À*ıÀ+OÀ+—À+ÀÀ+ÆÀ,À,$À,À,€À,ÎÀ,íÀ,óÀ-JÀ-PÀ-”À-šÀ-ìÀ.4À.„À.¾À.¿À/À/!À/'À/}À/ƒÀ/ÇÀ/ÍÀ0À0gÀ0À0ÇÀ0ÈÀ1À1kÀ1¾À1ÏÀ1ÕÀ2)À2|À2ÎÀ3À3lÀ3¿À4À4aÀ4²À4ÎÀ4ÔÀ5À5^À5²À6À6CÀ6IÀ6—À6¾À6ÄÀ6ÒÀ6óÀ7À7KÀ7ˆÀ7§À7áÀ8À8,À84À8>À8DÀ8•À8áÀ9<À9À9 À9¦À9ìÀ:9À:mÀ:sÀ:ÃÀ;À;^À;vÀ;‹À;¨À;©À;úÀ<LÀ<ŸÀ<¥À<õÀ=GÀ=—À=çÀ>9À>À>àÀ>íÀ>óÀ?(À?KÀ?LÀ?À?ÛÀ?øÀ@,À@-À@|À@ÄÀ@ÊÀAÀAÀA‰ÀAøÀB,ÀB-ÀB\ÀBbÀB§ÀBÂÀBáÀBâÀC2ÀCmÀCsÀCŞÀDMÀDvÀDwÀDÈÀE
ÀEÀE|ÀEìÀFÀFÀFiÀF¹ÀFßÀFåÀG*ÀGdÀGeÀG²ÀHÀH&ÀH,ÀH—ÀIÀI/ÀI0ÀI{ÀIÍÀJÀJ?ÀJEÀJ²ÀK#ÀK\ÀK]ÀK™ÀKŸÀKßÀL,ÀLvÀLÊÀMÀMkÀM—ÀMÀNÀNÀN…ÀNİÀO;ÀO<ÀOqÀOwÀOÀÀP	ÀP5ÀP^ÀP_ÀP­ÀQÀQ?ÀQ@ÀQÀQÛÀQáÀR0ÀRIÀROÀR›ÀRäÀR÷ÀS;ÀS<ÀSƒÀS‰ÀS×ÀT%ÀTrÀT¿ÀUÀUÀUVÀU£ÀUñÀV8ÀVIÀVÀV‘ÀVØÀVñÀWÀWÀWcÀWsÀWyÀWÄÀWÑÀW×ÀX#ÀXpÀX®ÀX´ÀYÀYOÀYUÀY¦ÀYóÀZ@ÀZFÀZÀZÜÀ[)À[cÀ[dÀ[©À[¯À[öÀ[üÀ\BÀ\ŒÀ\’À\¢À\¨À\øÀ]À][À]\À]¡À]§À]÷À^DÀ^JÀ^À^ÚÀ^àÀ^ğÀ^öÀ_DÀ_bÀ_®À_¯À_ùÀ_ÿÀ`KÀ`\À`bÀ`«À`üÀaÀaÀabÀa°ÀaüÀbDÀb”ÀbßÀc*ÀcyÀcÆÀdÀdJÀdPÀdwÀd}ÀdÀdŞÀe*ÀeQÀe£ÀeíÀeîÀf2Àf8Àf‰ÀfâÀg5Àg‰ÀgÁÀgÇÀhÀhhÀh·Ài	ÀiYÀi­ÀiùÀiÿÀjPÀj ÀjõÀkLÀk|ÀkĞÀlÀlbÀlhÀl»Àm
ÀmUÀm£ÀmøÀmşÀnRÀn£ÀnìÀnòÀoCÀo^ÀodÀorÀo‡Ào°ÀoÃÀoÚÀoâÀoèÀpÀpLÀpRÀp«ÀpÉÀpêÀpğÀqÀq1ÀqRÀq‰Àq½ÀqçÀrÀr"Àr_Àr}Àr›ÀráÀsÀs=ÀsNÀscÀs—ÀsÚÀtÀtÀtÀt Àt(Àt2Àt8Àt‘Àt—Àt¥ÀtºÀtşÀuÀu(Àu;ÀuTÀu\ÀubÀuÀuÆÀuÌÀv%ÀvCÀvdÀvjÀv|Àv«ÀvÌÀwÀw7ÀwaÀwŒÀw¨ÀwåÀxÀx!ÀxgÀx•ÀxÃÀxÔÀxéÀyÀy`ÀyvÀyªÀyŞÀz
ÀzÀzÀz)Àz1Àz;ÀzAÀzŠÀzÕÀ{À{À{À{$À{rÀ{‰À{§À{ÖÀ{ùÀ|À|FÀ|gÀ|†À|‡À|ËÀ|ÑÀ}"À}{À}ÎÀ~"À~tÀ~ÆÀ~ıÀÀSÀ›À¡ÀòÀ€2À€]À€cÀ€±À€ûÀÀMÀšÀêÀğÀ‚KÀ‚\À‚bÀ‚pÀ‚…À‚®À‚ÁÀ‚ØÀ‚àÀ‚æÀƒÀƒJÀƒPÀƒ©ÀƒÇÀƒèÀƒîÀ„ À„/À„À„ÎÀ…À…;À…€À…ÊÀ†À†-À†cÀ†ŒÀ†³À†ãÀ‡À‡À‡jÀ‡ÅÀˆÀˆaÀˆÀˆ¹ÀˆøÀ‰7À‰CÀ‰dÀ‰ÂÀ‰ÌÀ‰ÒÀ‰áÀ‰éÀ‰óÀ‰ùÀŠRÀŠXÀŠfÀŠ{ÀŠ¿ÀŠÒÀŠéÀŠüÀ‹À‹À‹#À‹QÀ‹‡À‹À‹æÀŒÀŒ%ÀŒ+ÀŒ=ÀŒlÀŒ¼ÀÀ\ÀxÀ½ÀÀEÀ}À¨ÀŞÀÀ.À^À†ÀŒÀçÀ>À™ÀöÀ‘AÀ‘‡À‘°À‘ÊÀ’À’!À’=À’À’­À’ÙÀ’èÀ“À“VÀ“‹À“ÀÀ“ÆÀ” À”zÀ”ÒÀ•À•HÀ•TÀ•uÀ•ãÀ•íÀ•óÀ–À–
À–À–À–*À–0À–}À–’À–³À–âÀ—	À—0À—ZÀ—~À— À—¡À—îÀ—ôÀ˜DÀ˜YÀ˜_À˜…À˜ÜÀ˜ŞÀ˜ßÀ™-À™nÀ™À™ëÀ™ñÀš%ÀšDÀšcÀš¿ÀšÃÀšÄÀ›.À›£À›¤Àœ Àœ\Àœ¡ÀœÆÀœÇÀœÓÀ!À9À:À]ÀuÀ‘ÀºÀãÀÀ5À>ÀDÀUÀYÀZÀfÀ”À®ÀêÀ÷ÀŸÀŸ€ÀŸ†ÀŸŠÀŸ‹ÀŸíÀ GÀ HÀ ½À¡@À¡AÀ¡MÀ¡À¡¹À¡ºÀ¡ÆÀ¢%À¢PÀ¢QÀ¢]À¢´À¢ÓÀ¢ÔÀ¢àÀ£CÀ£tÀ£uÀ£À£ÀÀ£ÁÀ¤ À¤NÀ¤OÀ¤[À¤³À¤ÛÀ¤ÜÀ¤èÀ¥FÀ¥rÀ¥sÀ¥À¥§À¥ÇÀ¦À¦À¦$À¦(À¦)À¦vÀ¦§À¦¨À¦´À¦ÓÀ§À§ À§4À§8À§9À§‰À§½À§¾À§ÊÀ¨&À¨FÀ¨`À¨­À¨ûÀ©=À©•À©™À©šÀªÀªˆÀª‰Àª•ÀªĞÀªòÀ«$À«(À«)À«|À«½À«¾À«ÊÀ¬À¬3À¬7À¬8À¬‘À¬ĞÀ¬ÑÀ¬İÀ¬ûÀ­*À­KÀ­‘À­•À­–À­ìÀ®%À®&À®2À®VÀ®…À®¬À®òÀ®öÀ®÷À¯SÀ¯’À¯“À¯ŸÀ¯ÔÀ°À°À°À°iÀ°ŸÀ° À°¬À°áÀ±À±!À±iÀ±mÀ±nÀ±âÀ²ZÀ²[À²gÀ²‡À²´À²¸À²¹À³À³[À³\À³hÀ³’À³²À³ÌÀ´
À´fÀ´lÀ´pÀ´qÀ´åÀµgÀµhÀµtÀµ¡ÀµÃÀ¶À¶	À¶
À¶gÀ¶ÇÀ¶ÈÀ¶ÔÀ·À·1À·SÀ·«À·¯À·°À¸À¸ŠÀ¸‹À¸—À¸ÁÀ¸áÀ¸ûÀ¹9À¹•À¹›À¹ŸÀ¹ ÀºÀº–Àº—Àº£ÀºİÀºüÀ»>À»BÀ»CÀ»±À¼"À¼#À¼/À¼À¼®À½*À½.À½/À½¸À½ÒÀ½åÀ½÷À¾À¾ À¾9À¾RÀ¾hÀ¾‹À¾¦À¾§À¾³À¾İÀ¿À¿"À¿#À¿†À¿äÀ¿åÀ¿ñÀÀ-ÀÀOÀÀsÀÀõÀÁÀÁ\ÀÁbÀÁfÀÁgÀÁäÀÂnÀÂoÀÂ{ÀÂÀÀÂâÀÃÀÃ ÀÃWÀÃŠÀÃ¼ÀÃğÀÄ%ÀÄXÀÄŠÀÄ¾ÀÄóÀÅ,ÀÅbÀÅ§ÀÅÀÀÆÀÆÀÆÀÆÀÆÊÀÆíÀÇÀÇÀÇ,ÀÇCÀÇ[ÀÇqÀÇ†ÀÇÀÇµÀÇØÀÇòÀÈÀÈÀÈÀÈfÀÈˆÀÈªÀÈÉÀÉ ÀÉ6ÀÉkÀÉ¢ÀÉÚÀÊÀÊ?ÀÊsÀÊ¨ÀÊáÀËÀË\ÀËuÀËÃÀËÉÀËÍÀËÎÀÌÀÌ¢ÀÌ¶ÀÌÏÀÌçÀÍÀÍÀÍ2ÀÍGÀÍ^ÀÍvÀÍ™ÀÍ³ÀÍÒÀÍÓÀÍßÀÎÀÎ)ÀÎVÀÎZÀÎ[ÀÎ±ÀÎçÀÎèÀÎôÀÏ/ÀÏ{ÀÏ§ÀÏËÀÏöÀĞ.ÀĞ2ÀĞ3ÀĞ?ÀĞŠÀĞãÀĞçÀĞèÀĞôÀÑAÀÑcÀÑ®ÀÑ´ÀÑûÀÑÿÀÒ ÀÒeÀÒÖÀÒ×ÀÒãÀÓ.ÀÓSÀÓÀÓ¢ÀÓ£ÀÔÀÔƒÀÔ„ÀÔÀÔ®ÀÔİÀÕ ÀÕ&ÀÕMÀÕnÀÕÀÕ°ÀÕóÀÕôÀÖÀÖFÀÖ‘ÀÖ—ÀÖäÀ×LÀ×RÀ×SÀ×šÀ×ÙÀ×ÚÀØÀØ$ÀØIÀØnÀØ“ÀØÉÀØëÀÙÀÙCÀÙyÀÙ­ÀÙáÀÚÀÚ,ÀÚSÀÚ{ÀÚÀÚ‚ÀÚëÀÛ,ÀÛdÀÛeÀÛ‹ÀÛêÀÜ0ÀÜ7ÀÜ8ÀÜQÀÜŸÀÜ¥ÀÜ©ÀÜªÀÜ¶ÀÜ×ÀİÀİ-ÀİTÀİ~Àİ¢ÀİÅÀİöÀİ÷ÀŞÀŞLÀŞšÀŞ ÀŞ¾ÀßÀß"Àß^Àß×ÀßİÀàÀàÀà<Àà‘ÀàÛÀàâÀàãÀàüÀáJÀáPÀáTÀáUÀáéÀâÀâ+ÀâEÀâcÀâwÀâ˜Àâ±ÀâÊÀâßÀâıÀâşÀã
ÀãbÀãµÀã¹ÀãºÀä%Àä‹ÀäÀäÀä¼ÀäûÀäüÀåDÀåHÀå|Àå€ÀåÇÀæ	ÀæKÀædÀæ£Àæ©ÀæôÀç6ÀçWÀç€ÀçÀçÂÀçÈÀèÀèVÀèwÀè¡Àè¢ÀèÌÀèÒÀé!ÀépÀé¹ÀééÀéêÀê,Àê2ÀêiÀê¸ÀëÀëPÀëVÀë¦ÀëôÀì!Àì'ÀìwÀìÀÀìÙÀìßÀí.ÀíCÀíoÀípÀíÀÀíãÀíõÀíöÀî<ÀîBÀîÀî¦ÀîÀÀîÁÀï
ÀïÀïaÀï“Àï³ÀïµÀï¶ÀğÀğPÀğlÀğrÀğ¨Àğ¾Àğ¿ÀğËÀğüÀñÀñ9ÀñmÀñsÀñ‰ÀñÙÀñöÀòÀò!Àò`ÀòjÀòtÀò{ÀòÀò€ÀòŞÀó3Àó4Àó@ÀómÀó…ÀóªÀóŞÀóäÀóåÀô
Àô2ÀôhÀôlÀômÀôÍÀõÀõÀõ Àõ3ÀõKÀõ[ÀõsÀõ†ÀõÀõ³ÀõÃÀõÇÀõÈÀöÀö8Àö|Àö˜Àö™Àö³Àö´ÀöÀÀöÛÀöïÀöÿÀ÷À÷.À÷8À÷¨À÷¬À÷­À÷¹ÀøÀø@ÀøBÀøCÀøŠÀøÀøÓÀùÀù9ÀùzÀùÁÀùİÀúÀúÀúOÀúUÀú™ÀúàÀûÀû\Àû˜Àû°Àû±ÀûàÀûæÀü1ÀüÀüÆÀüàÀüâÀüãÀıCÀırÀısÀı·Àı×ÀıØÀıäÀşÀşÀşÀş7ÀşRÀş–ÀşœÀşÓÀşïÀÿÀÿ"ÀÿuÀÿ¼ÀÿáÀÿõÀÿùÀÿúÀ SÀ À À ¨À ªÀ «À ÀÀ ÄÀ ÀÀ)À/ÀzÀÅÀßÀåÀ&À,À{À”À¥ÀÓÀòÀÀbÀcÀ“À·ÀáÀÀ3ÀZÀ„À…ÀµÀ»ÀÀ0ÀEÀFÀ…À‹ÀÙÀ%ÀgÀ~ÀÀÑÀìÀíÀÀ%ÀXÀ^À‹ÀşÀ4ÀhÀlÀmÀ©À¯ÀâÀ	À	À	lÀ	rÀ	¯À	şÀ
%À
+À
oÀ
¸ÀÀ)À=ÀPÀfÀ©À­À®À ÀÀ.ÀAÀUÀtÀ›À¢À¦À§À×ÀİÀ&ÀkÀÀ•À»ÀÀRÀÀéÀ7À‡ÀÔÀÀÀmÀÀ¢ÀÚÀïÀÀÀ*ÀKÀSÀ`ÀwÀ’À¡À¸ÀëÀ"ÀdÀoÀwÀ}ÀÀ‚À»ÀÁÀ	ÀÀ2À€À¢ÀµÀ»ÀÑÀçÀÀNÀ~À­À³ÀêÀÀÀNÀoÀuÀˆÀŒÀÀ™À¼ÀŞÀñÀ÷ÀÀ2ÀTÀÀƒÀ„ÀÀÎÀÏÀÀmÀ‰ÀÃÀŞÀøÀşÀÿÀ<ÀrÀsÀÀÚÀÀAÀBÀ{ÀÂÀÃÀúÀ'À(À_ÀŒÀÀÜÀÀ<ÀBÀCÀ[À_À`ÀlÀ¯À±À²ÀùÀıÀLÀbÀ ÀÃÀÄÀÀ'ÀhÀ­ÀßÀÀ*À.À/ÀiÀoÀ¨ÀæÀ+ÀtÀ¾ÀëÀ 3À nÀ ŸÀ ÛÀ öÀ!À!<À!DÀ!mÀ!uÀ!yÀ!zÀ!«À!±À!êÀ"'À"bÀ"“À"ÈÀ"ãÀ"ıÀ#7À#?À#hÀ#pÀ#tÀ#uÀ#ÉÀ$À$À$kÀ$¸À$¹À%À%aÀ%bÀ%–À%³À%ÂÀ%ÃÀ%âÀ%ãÀ&À&À&cÀ&~À&–À&¦À&ÇÀ&ÚÀ&äÀ&ùÀ&ıÀ&şÀ'NÀ'qÀ'wÀ'ÄÀ(À([À(¨À(öÀ)À)'À)7À)VÀ)sÀ)†À)À) À)¤À)¥À)ğÀ*À*aÀ*}À*À*€À*ËÀ*ÏÀ+À+6À+WÀ+À+–À+æÀ,8À,RÀ,XÀ,¦À,ùÀ-:À-wÀ-–À-´À-ÌÀ-åÀ-øÀ.À.AÀ.BÀ.À.ĞÀ/À/LÀ/„À/¤À/¨À/©À/ÓÀ/ÙÀ0À0%À0&À0QÀ0WÀ0’À0¤À0¥À0×À0İÀ1À1-À1.À1~À1¡À1§À1òÀ2À2)À2*À2xÀ2”À2šÀ2åÀ32À3CÀ3IÀ3—À3¿À4À4
À4À4kÀ4‰À4ŠÀ4ÃÀ4ÉÀ5À5kÀ5…À5‹À5ÙÀ6,À6mÀ6ªÀ6ÈÀ6æÀ6şÀ7À7*À7PÀ7WÀ7kÀ7À7ÆÀ7ŞÀ8,À80À81À8“À8æÀ8çÀ9PÀ9ŞÀ9ßÀ9îÀ9ïÀ:HÀ:dÀ:eÀ:qÀ:œÀ:À:­À:®À;À;%À;&À;2À;`À;aÀ;xÀ;yÀ;ÚÀ;şÀ;ÿÀ<À<NÀ<OÀ<[À<§À<ÂÀ<ÃÀ<ÏÀ=À=RÀ=lÀ=rÀ=§À=ÂÀ=ÈÀ=ÉÀ> À>À>8À>vÀ>µÀ>óÀ?)À?/À?PÀ?rÀ?sÀ?À?ØÀ?êÀ?îÀ?ïÀ@ZÀ@°À@²À@³À@èÀAÀAÀAWÀAŸÀA ÀAØÀAÜÀB&ÀB3ÀBvÀBwÀB¸ÀBÔÀC)ÀC*ÀCyÀCÀC‘ÀCŞÀCûÀCşÀDJÀDMÀD_ÀDbÀDmÀD¡ÀD¤ÀDßÀEÀE!ÀE$ÀECÀEsÀExÀEÀE‚ÀE×ÀF-ÀFYÀF\ÀF²ÀFæÀGÀGcÀG§ÀGäÀGúÀH&ÀH;ÀHOÀH|ÀH‹ÀHËÀHÓÀHàÀHıÀIÀI	ÀIÀI2ÀINÀIRÀImÀIoÀIpÀI³ÀIùÀJ/ÀJvÀJºÀJ÷ÀKÀKHÀK]ÀKzÀK‡ÀK›ÀKÑÀKàÀL)ÀL1ÀL7ÀL=ÀLOÀLfÀL‚ÀL†ÀL¡ÀL£ÀL¤ÀLóÀMAÀMEÀM•ÀMåÀNÀNUÀNšÀN›ÀNĞÀNèÀNéÀO;ÀOVÀOWÀOcÀOyÀOÓÀOìÀPÀPKÀPtÀPzÀP˜ÀPœÀP       ,‡ŞªŒĞ„ë/// An immutable 32 bit color value in ARGB format.
///
/// Consider the light teal of the Flutter logo. It is fully opaque, with a red
/// channel value of 0x42 (66), a green channel value of 0xA5 (165), and a blue
/// channel value of 0xF5 (245). In the common "hash syntax" for color values,
/// it would be described as `#42A5F5`.
///
/// Here are some ways it could be constructed:
///
/// ```dart
/// Color c1 = const Color(0xFF42A5F5);
/// Color c2 = const Color.fromARGB(0xFF, 0x42, 0xA5, 0xF5);
/// Color c3 = const Color.fromARGB(255, 66, 165, 245);
/// Color c4 = const Color.fromRGBO(66, 165, 245, 1.0);
/// ```
///
/// If you are having a problem with `Color` wherein it seems your color is just
/// not painting, check to make sure you are specifying the full 8 hexadecimal
/// digits. If you only specify six, then the leading two digits are assumed to
/// be zero, which means fully-transparent:
///
/// ```dart
/// Color c1 = const Color(0xFFFFFF); // fully transparent white (invisible)
/// Color c2 = const Color(0xFFFFFFFF); // fully opaque white (visible)
/// ```
///
/// See also:
///
///  * [Colors](https://api.flutter.dev/flutter/material/Colors-class.html), which
///    defines the colors found in the Material Design specification. ŒÚ‚Ñ }‚‚|/// Construct a color from the lower 32 bits of an [int].
///
/// The bits are interpreted as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value.
///
/// In other words, if AA is the alpha value in hex, RR the red value in hex,
/// GG the green value in hex, and BB the blue value in hex, a color can be
/// expressed as `const Color(0xAARRGGBB)`.
///
/// For example, to get a fully opaque orange, you would use `const
/// Color(0xFFFF9000)` (`FF` for the alpha, `FF` for the red, `90` for the
/// green, and `00` for the blue).ƒ	ˆ  –˜ ¯‚‚‘v‘w‘£/// Construct a color from the lower 8 bits of four integers.
///
/// * `a` is the alpha value, with 0 being transparent and 255 being fully
///   opaque.
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromRGBO], which takes the alpha value as a floating point
/// value.‘€‘…  ‘‡‘Œ  ‘‘“  ‘•‘š  -‘¨‘¢’$‘ª’"’‘à‘¾‘«‘¼‘·‘¬‘µ‘¯‘­‘±‘º‘Í‘Ş‘Ù‘Î‘×‘Ñ‘Ï‘Ó‘Ü‘ï‘ÿ‘û‘ğ‘ù‘ó‘ñ‘õ‘ş’’!’’’’’’’ ’&’5ƒ ”!”"”*Ê/// Create a color from red, green, blue, and opacity, similar to `rgba()` in CSS.
///
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
/// * `opacity` is alpha channel of this color as a double, with 0.0 being
///   transparent and 1.0 being fully opaque.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromARGB], which takes the opacity as an integer value.”+”0  ”2”7  ”9”>  ”@”H  3”\”V•(”^•&”ò”¼”†”_”„””`”}”w”a”u”q”j”b”l”t”y”‚”–”º”µ”—”³”­”˜”¯”¸”Ì”ï”ë”Í”é”ã”Î”å”î••%•!••••••$•*•9–?€ë/// A 32 bit value representing this color.
///
/// The bits are assigned as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value. –I€Ü—€§/// The alpha channel of this color in an 8 bit value.
///
/// A value of 0 means this color is fully transparent. A value of 255 means
/// this color is fully opaque.   —)€Ï—à€£/// The alpha channel of this color as a double.
///
/// A value of 0.0 means this color is fully transparent. A value of 1.0 means
/// this color is fully opaque.   —üa˜;4/// The red channel of this color in an 8 bit value.   ˜ad˜¢6/// The green channel of this color in an 8 bit value.   ˜Éb™	5/// The blue channel of this color in an 8 bit value.   ±Y/±m   ±Y±Z™/	™ò€´/// Returns a new color that matches this color with the alpha channel
/// replaced with `a` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ™üš   š<U›€Æ/// Returns a new color that matches this color with the alpha channel
/// replaced with the given `opacity` (which ranges from 0.0 to 1.0).
///
/// Out of range values will have unexpected effects. ››%   ›•œV€²/// Returns a new color that matches this color with the red channel replaced
/// with `r` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. œ^œc   œ 	c€´/// Returns a new color that matches this color with the green channel
/// replaced with `g` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. mr   ­o€³/// Returns a new color that matches this color with the blue channel replaced
/// with `b` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. x}   ÷€ÅŸ  ŸŸ&   ŸÀ‚K Î€ú/// Returns a brightness value between 0 for darkest and 1 for lightest.
///
/// Represents the relative luminance of the color. This value is computationally
/// expensive to calculate.
///
/// See <https://en.wikipedia.org/wiki/Relative_luminance>.   ¢‡A§„Ç/// Linearly interpolate between two colors.
///
/// This is intended to be fast but as a result may be ugly. Consider
/// [HSVColor] or writing custom logic for interpolating colors.
///
/// If either color is null, this function linearly interpolates from a
/// transparent instance of the other color. This is usually preferable to
/// interpolating from [material.Colors.transparent] (`const
/// Color(0x00000000)`), which is specifically transparent _black_.
///
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]). Each channel
/// will be clamped to the range 0 to 255.
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController]. §§  § §(  §*§2   ©T† «hö/// Combine the foreground color as a transparent color over top
/// of a background color, and return the resulting combined color.
///
/// This uses standard alpha blending ("SRC over DST") rules to produce a
/// blended color from two colors. This can be used as a performance
/// enhancement when trying to avoid needless alpha blending compositing
/// operations for two things that are solid colors with the same shape, but
/// overlay each other: instead, just paint one with the combined color. «s«z  «…«Œ   ¯x€í°w/// Returns an alpha value representative of the provided [opacity] value.
///
/// The [opacity] value may not be null. °°   °i€ì°ƒ  °†°  °i°j±ŒW±Ÿ   ±Œ± À ¬…À BáÀ ­6€ª/// A description of the style to use when drawing on a [Canvas].
///
/// Most APIs on [Canvas] take a [Paint] object to describe the style
/// to use for that operation. À ­@f À ­À ­£Y/// Constructs an empty [Paint] object with all fields initialized to
/// their defaults.  $À °†LÀ °± 	À °†À °‡À °À °À °À °¹À °ÁÀ °ÑÀ °ÂÀ °×'À °è À °ıÀ ±!À ± À ±"À ±'%À ±8 À ±KÀ ±P!À ±a À ±pÀ ±u'À ±† À ±›À ± %À ±± À ±ÄÀ ±É&À ±Ú À ±îÀ ±ó,À ² À ²À ²#)À ²4 À ²KÀ ²P&À ²a À ²uÀ ²z0À ²‹ À ²¨À ²®,À ²¿ À ²ØÀ ²Ş(À ²ï À ³À ³>À ³ À ³EÀ ³2À ³HÀ ³M2À ³^ À ³{À ³nÀ ³~À ³ƒ:À ³” À ³¹À ³¨À ³¼À ³Á2À ³Ò À ³ïÀ ³âÀ ³òÀ ³÷>À ´ À ´1À ´À ´4À ´9:À ´J À ´oÀ ´^À ´rÀ ´w<À ´ˆ À ´¯À ´À ´²À ´·HÀ ´È À ´ûÀ ´ãÀ ´şÀ µBÀ µ À µAÀ µ,À µDÀ µI<À µZ À µÀ µoÀ µ„À µ‰NÀ µš À µÓÀ µ¸À µÖÀ µÛFÀ µì À ¶À ¶À ¶ À ¶%>À ¶6 À ¶_À ¶LÀ ¶bÀ ¶©%À ¶º À ¶ÌÀ ·Q3À ·| À ·QÀ ·RÀ ·XÀ ·iÀ ·YÀ ·ÿ"À ¸ À ¸ À ¸%'À ¸6 À ¸KÀ ¸P'À ¸a À ¸vÀ ¸{"À ¸Œ À ¸œÀ ºè,À ºù À »
À ¾=À ¾  À ¾5À ¾>À ¾?À ¾FÀ ¾GÀ ÍF3À ÍZ À ÍvÀ ¸Ğ€ÓÀ ¹Ki/// Whether to apply anti-aliasing to lines and images drawn on the
/// canvas.
///
/// Defaults to true.   À ¹¦À ¹ª  À ¹¶
À ¹¼   À »‚'À ¼À„/// The color to use when stroking or filling a shape.
///
/// Defaults to opaque black.
///
/// See also:
///
///  * [style], which controls whether to stroke or fill (or both).
///  * [colorFilter], which overrides [color].
///  * [shader], which overrides [color] with more elaborate effects.
///
/// This color is not used when compositing. To colorize a layer, use
/// [colorFilter].   À ½C€À ½G  À ½MÀ ½T   À ¾QƒœÀ ÁV‚Ò/// A blend mode to apply when a shape is drawn or a layer is composited.
///
/// The source colors are from the shape being drawn (e.g. from
/// [Canvas.drawPath]) or layer being composited (the graphics that were drawn
/// between the [Canvas.saveLayer] and [Canvas.restore] calls), after applying
/// the [colorFilter], if any.
///
/// The destination colors are from the background onto which the shape or
/// layer is being composited.
///
/// Defaults to [BlendMode.srcOver].
///
/// See also:
///
///  * [Canvas.saveLayer], which uses its [Paint]'s [blendMode] to composite
///    the layer when [Canvas.restore] is called.
///  * [BlendMode], which discusses the user of [Canvas.saveLayer] with
///    [blendMode].   À Áğ€ À Áô  À ÁşÀ Â	   À Â”€áÀ Ãk/// Whether to paint inside shapes, the edges of shapes, or both.
///
/// Defaults to [PaintingStyle.fill].   À Ãx€‡À Ã|  À Ã‚À Ã‘   À ÄiÀ Å€ş/// How wide to make edges drawn when [style] is set to
/// [PaintingStyle.stroke]. The width is given in logical pixels measured in
/// the direction orthogonal to the direction of the path.
///
/// Defaults to 0.0, which correspond to a hairline width.   À Åo€‹À Ås  À ÅÀ Å‡   À ÅşÀ Æµ€ /// The kind of finish to place on the end of lines drawn when
/// [style] is set to [PaintingStyle.stroke].
///
/// Defaults to [StrokeCap.butt], i.e. no caps.   À Ç€‹À Ç  À Ç'À Ç2   À Ç¨„ÑÀ Ì„+/// The kind of finish to place on the joins between segments.
///
/// This applies to paths drawn when [style] is set to [PaintingStyle.stroke],
/// It does not apply to points drawn as lines with [Canvas.drawPoints].
///
/// Defaults to [StrokeJoin.miter], i.e. sharp corners.
///
/// Some examples of joins:
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeMiterLimit] to control when miters are replaced by bevels when
///    this is set to [StrokeJoin.miter].
///  * [strokeCap] to control what is drawn at the ends of the stroke.
///  * [StrokeJoin] for the definitive list of stroke joins.   À Ì|€À Ì€  À Ì‹À Ì—   À Í~…rÀ Ò‘„Ó/// The limit for miters to be drawn on segments when the join is set to
/// [StrokeJoin.miter] and the [style] is set to [PaintingStyle.stroke]. If
/// this limit is exceeded, then a [StrokeJoin.bevel] join will be drawn
/// instead. This may cause some 'popping' of the corners of a path if the
/// angle between line segments is animated, as seen in the diagrams below.
///
/// This limit is expressed as a limit on the length of the miter.
///
/// Defaults to 4.0.  Using zero as a limit will cause a [StrokeJoin.bevel]
/// join to be used all the time.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_0_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_6_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeJoin] to control the kind of finish to place on the joins
///    between segments.
///  * [strokeCap] to control what is drawn at the ends of the stroke.   À Òó€±À Ò÷  À ÓÀ Ó   À Ó¨‚WÀ Ôp€¯/// A mask filter (for example, a blur) to apply to a shape after it has been
/// drawn but before it has been composited into the image.
///
/// See [MaskFilter] for details.   À Ö‚°À Ö  À ÖÀ Ö   À Ø¶ìÀ Ú5/// Controls the performance vs quality trade-off to use when sampling bitmaps,
/// as with an [ImageShader], or when drawing images, as with [Canvas.drawImage],
/// [Canvas.drawImageRect], [Canvas.drawImageNine] or [Canvas.drawAtlas].
///
/// Defaults to [FilterQuality.none].   À Ú¥€—À Ú©  À Ú·À ÚÆ   À Û@ÈÀ ÜÌk/// The shader to use when stroking or filling a shape.
///
/// When this is null, the [color] is used instead.
///
/// See also:
///
///  * [Gradient], a shader that paints a color gradient.
///  * [ImageShader], a shader that tiles an [Image].
///  * [colorFilter], which overrides [shader].
///  * [color], which is used if [shader] and [colorFilter] are null.   À İïÀ İ  À İÀ İ   À ŞşvÀ ßê€Î/// A color filter to apply when a shape is drawn or when a layer is
/// composited.
///
/// See [ColorFilter] for details.
///
/// When a shape is being drawn, [colorFilter] overrides [color] and [shader].   À àw<À à{  À à‡À à•   À á·‚ˆÀ ãµÈ/// The [ImageFilter] to use when drawing raster images.
///
/// For example, to blur an image using [Canvas.drawImage], apply an
/// [ImageFilter.blur]:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.drawImage(
///     _image,
///     ui.Offset.zero,
///     Paint()..imageFilter = ui.ImageFilter.blur(sigmaX: 0.5, sigmaY: 0.5),
///   );
/// }
/// ```
///
/// See also:
///
///  * [MaskFilter], which is used for drawing geometry.   À äB·À äF  À äRÀ ä`   À åınÀ ç/// Whether the colors of the image are inverted when drawn.
///
/// Inverting the colors of an image applies a new color filter that will
/// be composed with any user provided color filters. This is primarily
/// used for implementing smart invert on iOS.   À çnlÀ çr  À ç
À ç…   À ·‰rÀ ·—    À çŞ‡†À çñ   À çŞÀ çß À ÿø¦hÀ„/// Opaque handle to raw decoded image data (pixels).
///
/// To obtain an [Image] object, use the [ImageDescriptor] API.
///
/// To draw an [Image], use one of the methods on the [Canvas] class, such as
/// [Canvas.drawImage].
///
/// A class or method that receives an image object must call [dispose] on the
/// handle when it is no longer needed. To create a shareable reference to the
/// underlying image, call [clone]. The method or object that receives
/// the new instance will then be responsible for disposing it, and the
/// underlying image itself will be disposed when all outstanding handles are
/// disposed.
///
/// If `dart:ui` passes an `Image` object and the recipient wishes to share
/// that handle with other callers, [clone] must be called _before_ [dispose].
/// A handle that has been disposed cannot create new handles anymore.
///
/// See also:
///
///  * [Image](https://api.flutter.dev/flutter/widgets/Image-class.html), the class in the [widgets] library.
///  * [ImageDescriptor], which allows reading information about the image and
///    creating a codec to decode it.
///  * [instantiateImageCodec], a utility method that wraps [ImageDescriptor]. À§€ÁÀ¬À­À® À¯Àµ  À¼
ÀÂ  ÀÈÀÎ   À/À¶ ÀÀÀ”À¥À•ÀÁÀÎ€ç/// A callback that is invoked to report an image creation.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onCreate] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀÛÀê€é/// A callback that is invoked to report the image disposal.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onDispose] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀøÀ  ÀSÀbA/// The number of image pixels along the image's horizontal axis. ÀlRÀ¸?/// The number of image pixels along the image's vertical axis. ÀÃÀÈ ÀÔÀ•À¾€¥/// Whether this reference to the underlying image is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   ÀnƒÀÕÌ/// The color space that is used by the [Image]'s colors.
///
/// This value is a consequence of how the [Image] has been created.  For
/// example, loading a PNG that is in the Display P3 color space will result
/// in a [ColorSpace.extendedSRGB] image.
///
/// On rendering backends that don't support wide gamut colors (anything but
/// iOS impeller), wide gamut images will still report [ColorSpace.sRGB] if
/// rendering wide gamut colors isn't supported.   Àİƒ&À
İæ/// Release this handle's claim on the underlying Image. This handle is no
/// longer usable after this method is called.
///
/// Once all outstanding handles have been disposed, the underlying image will
/// be disposed as well.
///
/// In debug mode, [debugGetOpenHandleStackTraces] will return a list of
/// [StackTrace] objects from all open handles' creation points. This is
/// useful when trying to determine what parts of the program are keeping an
/// image resident in memory.   À ƒÊÀËÍ/// Converts the [Image] object into a byte array.
///
/// The [format] argument specifies the format in which the bytes will be
/// returned.
///
/// Using [ImageByteFormat.rawRgba] on an image in the color space
/// [ColorSpace.extendedSRGB] will result in the gamut being squished to fit
/// into the sRGB gamut, resulting in the loss of wide-gamut colors.
///
/// Returns a future that completes with the binary image data or an error
/// if encoding fails. À×0Àè  ÀğÀÿÀ À¢ÀÍ€°/// If asserts are enabled, returns the [StackTrace]s of each open handle from
/// [clone], in creation order.
///
/// If asserts are disabled, this method always returns null.   À¨ŒàÀ!éŠ¢/// Creates a disposable handle to this image.
///
/// Holders of an [Image] must dispose of the image when they no longer need
/// to access it or draw it. However, once the underlying image is disposed,
/// it is no longer possible to use it. If a holder of an image needs to share
/// access to that image with another object or method, [clone] creates a
/// duplicate handle. The underlying image will only be disposed once all
/// outstanding handles are disposed. This allows for safe sharing of image
/// references while still disposing of the underlying resources when all
/// consumers are finished.
///
/// It is safe to pass an [Image] handle to another object or method if the
/// current holder no longer needs it.
///
/// To check whether two [Image] references are referring to the same
/// underlying image memory, use [isCloneOf] rather than the equality operator
/// or [identical].
///
/// The following example demonstrates valid usage.
///
/// ```dart
/// import 'dart:async';
/// import 'dart:typed_data';
/// import 'dart:ui';
///
/// Future<Image> _loadImage(int width, int height) {
///   final Completer<Image> completer = Completer<Image>();
///   decodeImageFromPixels(
///     Uint8List.fromList(List<int>.filled(width * height * 4, 0xFF)),
///     width,
///     height,
///     PixelFormat.rgba8888,
///     // Don't worry about disposing or cloning this image - responsibility
///     // is transferred to the caller, and that is safe since this method
///     // will not touch it again.
///     (Image image) => completer.complete(image),
///   );
///   return completer.future;
/// }
///
/// Future<void> main() async {
///   final Image image = await _loadImage(5, 5);
///   // Make sure to clone the image, because MyHolder might dispose it
///   // and we need to access it again.
///   final MyImageHolder holder = MyImageHolder(image.clone());
///   final MyImageHolder holder2 = MyImageHolder(image.clone());
///   // Now we dispose it because we won't need it again.
///   image.dispose();
///
///   final PictureRecorder recorder = PictureRecorder();
///   final Canvas canvas = Canvas(recorder);
///
///   holder.draw(canvas);
///   holder.dispose();
///
///   canvas.translate(50, 50);
///   holder2.draw(canvas);
///   holder2.dispose();
/// }
///
/// class MyImageHolder {
///   MyImageHolder(this.image);
///
///   final Image image;
///
///   void draw(Canvas canvas) {
///     canvas.drawImage(image, Offset.zero, Paint());
///   }
///
///   void dispose() => image.dispose();
/// }
/// ```
///
/// The returned object behaves identically to this image. Calling
/// [dispose] on it will only dispose the underlying native resources if it
/// is the last remaining handle.   À#Œ‚›À%ö‚R/// Returns true if `other` is a [clone] of this and thus shares the same
/// underlying image memory, even if this or `other` is [dispose]d.
///
/// This method may return false for two images that were decoded from the
/// same underlying asset, if they are not sharing the same memory. For
/// example, if the same file is decoded using [instantiateImageCodec] twice,
/// or the same bytes are decoded using [decodeImageFromPixels] twice, there
/// will be two distinct [Image]s that render the same but do not share
/// underlying memory, and so will not be treated as clones of each other. À& À&   À&+3À&>   À&+À&, À&b‡ØÀ&‡  À'Œ'À'®À'¯À'°  À'ŒÀ'À'“À'¤À'”À+À+# À+/À-o%À-€ À-’À-“À-‹À-‘À-ŒÀ'·fÀ(   À'·À'¸À'¾À'ÜÀ'ÅÀ'¿À'ÍÀ'ÛÀ'ÎÀ'ÕÀ'ÚÀ'ÖÀ'İÀ(À'äÀ'ŞÀ'æÀ'üÀ'öÀ'şÀ(!hÀ(‚   À(!À("À((À(FÀ(/À()À(7À(EÀ(8À(?À(DÀ(@À(GÀ(mÀ(NÀ(HÀ(PÀ(gÀ(aÀ(iÀ-™bÀ-ğ   À-™À-šÀ- À-¾À-§À-¡À-¯À-½À-°À-·À-¼À-¸À-¿À-ÛÀ-ÆÀ-ÀÀ-ÈÀ(¡À(Ÿ  À(«0À(¼  À(ÄÀ(ÓÀ(ÔÀ*2€èÀ*Õ9/// Returns an error message on failure, null on success. À*á
À*æ  À*í+À+  À*nÀ*oÀ*uÀ*£À*}À*vÀ*…À*¢À*†À*À*’À*À*•À*œÀ*¤À*ÀÀ*«À*¥À*­À+8dÀ+=    À, €ËÀ-`k/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À-À-À-À-4À-À-À-%À-3À-&À--À-2À-.À-5À-NÀ-<À-6À->À-ÿ9À.   À-ÿÀ. À&bÀ&cÀ&iÀ&zÀ&jÀ/‰_À5î†Ê/// Information for a single frame of an animation.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].
///
/// The recipient of an instance of this class is responsible for calling
/// [Image.dispose] on [image]. To share the image with other interested
/// parties, use [Image.clone]. If the [FrameInfo] object itself is passed to
/// another method or object, that method or object must assume it is
/// responsible for disposing the image when done, and the passer must not
/// access the [image] after that point.
///
/// For example, the following code sample is incorrect:
///
/// ```dart
/// /// BAD
/// Future<void> nextFrameRoutine(ui.Codec codec) async {
///   final ui.FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo);
///   // ERROR - _cacheImage is now responsible for disposing the image, and
///   // the image may not be available any more for this drawing routine.
///   _drawImage(frameInfo);
///   // ERROR again - the previous methods might or might not have created
///   // handles to the image.
///   frameInfo.image.dispose();
/// }
/// ```
///
/// Correct usage is:
///
/// ```dart
/// /// GOOD
/// Future<void> nextFrameRoutine(ui.Codec codec) async {
///   final ui.FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo.image.clone(), frameInfo.duration);
///   _drawImage(frameInfo.image.clone(), frameInfo.duration);
///   // This method is done with its handle, and has passed handles to its
///   // clients already.
///   // The image will live until those clients dispose of their handles, and
///   // this one must not be disposed since it will not be used again.
///   frameInfo.image.dispose();
/// }
/// ``` À5üÀ6ËÀ6ÌÀ6Í€»/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].À6ÏÀ6Ş  À6çÀ6ö   À7€™À7’{/// The duration this frame should be shown.
///
/// A zero duration indicates that the frame should be shown indefinitely. À7Ÿ€ÚÀ8t€¾/// The [Image] object for this frame.
///
/// This object must be disposed by the recipient of this frame info.
///
/// To share this image with other interested parties, use [Image.clone].    À8~„>À9l€Ş/// A handle to an image codec.
///
/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [Codec] interface, see
/// [instantiateImageCodec].   À9v9À9¤#/// Number of frames in this image.   À9³€¦À:I€…/// Number of times to repeat the animation.
///
/// * 0 when the animation should be played once.
/// * -1 for infinity repetitions.   À:]aÀ;¯//// Fetches the next animation frame.
///
/// Wraps back to the first frame after returning the last frame.
///
/// The returned future can complete with an error if the decoding has failed.
///
/// The caller of this method is responsible for disposing the
/// [FrameInfo.image] on the returned object.   À;Â€øÀ<°€Ş/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).    À<¾‡5À<É  À=ÑÀ=İÀ=ŞÀ=ß   À=æÀ=ë  À>¾À>Ã  À>DÀ>   À>À>À>IqÀ>®   À>IÀ>JÀ>PÀ>nÀ>WÀ>QÀ>_À>mÀ>`À>gÀ>lÀ>hÀ>oÀ>™À>vÀ>pÀ>xÀ>“À>À>•À>ŞSÀ>ò   À>ŞÀ>ßÀ?5{À?Ÿ   À?5À?6À?<À?ZÀ?CÀ?=À?KÀ?YÀ?LÀ?SÀ?XÀ?TÀ?[À?ŠÀ?bÀ?\À?dÀ?„À?~À?†À?´‚õÀ?Ò   À?´À?µÀB­€ÚÀCK9/// Returns an error message on failure, null on success. ÀCY,ÀC~  ÀBéÀBêÀBğÀCÀBøÀBñÀC ÀCÀCÀCÀCÀC	ÀCÀCÀC6ÀCÀCÀC!ÀC‹fÀCç   ÀC‹ÀCŒÀC—ÀC˜ÀCÀC»ÀC¤ÀCŸÀC¬ÀCºÀC­ÀC´ÀC¹ÀCµÀC¼ÀCÕÀCÃÀC½ÀCÅ Àc:†jÀdM/// A specification of the size to which an image should be decoded.
///
/// See also:
///
///  * [TargetImageSizeCallback], a callback that returns instances of this
///    class when consulted by image decoding methods such as
///    [instantiateImageCodecWithSize]. Àda# Àe Àe€/// Creates a new instance of this class.
///
/// The `width` and `height` may both be null, but if they're non-null, they
/// must be positive.Àe
Àe  ÀeÀe#  Àe3Àe9ÀeTÀeHÀe@Àe:ÀeCÀeQÀeKÀeSÀe_ÀeeÀe‚ÀeuÀemÀefÀepÀeÀexÀeÀeˆåÀghÂ/// The width into which to load the image.
///
/// If this is non-null, the image will be decoded into the specified width.
/// If this is null and [height] is also null, the image will be decoded into
/// its intrinsic size. If this is null and [height] is non-null, the image
/// will be decoded into a width that maintains its intrinsic aspect ratio
/// while respecting the [height] value.
///
/// If this value is non-null, it must be positive. ÀgræÀiRÂ/// The height into which to load the image.
///
/// If this is non-null, the image will be decoded into the specified height.
/// If this is null and [width] is also null, the image will be decoded into
/// its intrinsic size. If this is null and [width] is non-null, the image
/// will be decoded into a height that maintains its intrinsic aspect ratio
/// while respecting the [width] value.
///
/// If this value is non-null, it must be positive.  Ài]EÀip   Ài]Ài^ ÀƒGƒ˜Àƒ§P/// A handle for the framework to hold and retain an engine layer across frames.    Àƒ·ƒ&À†Ó‚ø/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// EngineLayers indirectly retain platform specific graphics resources. Some
/// of these resources, such as images, may be memory intensive. It is
/// important to dispose of EngineLayer objects that will no longer be used as
/// soon as possible to avoid retaining these resources until the next
/// garbage collection.
///
/// Once this EngineLayer is disposed, it is no longer eligible for use as a
/// retained layer, and must not be passed as an `oldLayer` to any of the
/// [SceneBuilder] methods which accept that parameter.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).    À†áIÀ†ì  À‡;}À‡³À‡´À‡µa/// This class is created by the engine, and should not be instantiated
/// or extended directly.    À‡¼lÀˆ   À‡¼À‡½À‡ÈÀ‡ÉÀ‡ÏÀ‡ìÀ‡ÕÀ‡ĞÀ‡İÀ‡ëÀ‡ŞÀ‡åÀ‡êÀ‡æÀ‡íÀˆÀ‡ôÀ‡îÀ‡ö Àˆ,¸XÀŠô‚¸/// A complex, one-dimensional subset of a plane.
///
/// A path consists of a number of sub-paths, and a _current point_.
///
/// Sub-paths consist of segments of various types, such as lines,
/// arcs, or beziers. Sub-paths can be open or closed, and can
/// self-intersect.
///
/// Closed sub-paths enclose a (possibly discontiguous) region of the
/// plane based on the current [fillType].
///
/// The _current point_ is initially at the origin. After each
/// operation adding a segment to a sub-path, the current point is
/// updated to the end of that segment.
///
/// Paths can be drawn on canvases using [Canvas.drawPath], and can
/// used to create clip regions using [Canvas.clipPath]. ÀŠı À‹À‹	   À‹iÀ‹ôÀ‹õÀ‹ù€Á/// Creates a copy of another [Path].
///
/// This copy is fast and does not require additional memory unless either
/// the `source` path or the path returned by this constructor are modified.À‹úÀŒ     ÀŒ‹€£À%€‚/// Determines how the interior of this path is calculated.
///
/// Defaults to the non-zero winding rule, [PathFillType.nonZero].   À1!À5  À>ÀL   ÀVUÀ2/// Starts a new sub-path at the given coordinate. À—ÀŸ  À¡À©   À¯rÀüE/// Starts a new sub-path at the given offset from the current point. À	À  À	À   À%tÀ~O/// Adds a straight line segment from the current point to the given
/// point. À…À  ÀÀ—   À€£Àt/// Adds a straight line segment from the current point to the point
/// at the given offset from the current point. À*	À2  À5	À=   ÀDÁÀÇq/// Adds a quadratic bezier segment that curves from the current
/// point to the given point (x2,y2), using the control point
/// (x1,y1).
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_quadratic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_quadratic_to_dark.png#gh-dark-mode-only) ÀÙ	Àá  Àä	Àì  Àï	À÷  Àú	À‘   À‘	'À‘ê€Ó/// Adds a quadratic bezier segment that curves from the current
/// point to the point at the offset (x2,y2) from the current point,
/// using the control point at the offset (x1,y1) from the current
/// point. À’	À’  À’	À’  À’	À’"  À’%	À’-   À’4ÎÀ“¸r/// Adds a cubic bezier segment that curves from the current point
/// to the given point (x3,y3), using the control points (x1,y1) and
/// (x2,y2).
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_cubic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_cubic_to_dark.png#gh-dark-mode-only) À“À	À“È  À“Ë	À“Ó  À“Ö	À“Ş  À“á	À“é  À“ì	À“ô  À“÷	À“ÿ   À”=À”ñ€İ/// Adds a cubic bezier segment that curves from the current point
/// to the point at the offset (x3,y3) from the current point, using
/// the control points at the offsets (x1,y1) and (x2,y2) from the
/// current point. À•	À•	  À•	À•  À•	À•  À•"	À•*  À•-	À•5  À•8	À•@   À•G‚bÀ—k‚/// Adds a bezier segment that curves from the current point to the
/// given point (x2,y2), using the control points (x1,y1) and the
/// weight w. If the weight is greater than 1, then the curve is a
/// hyperbola; if the weight equals 1, it's a parabola; and if it is
/// less than 1, it is an ellipse.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_conic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_conic_to_dark.png#gh-dark-mode-only) À—s	À—{  À—~	À—†  À—‰	À—‘  À—”	À—œ  À—ŸÀ—§   À—­ÏÀ™6w/// Adds a bezier segment that curves from the current point to the
/// point at the offset (x2,y2) from the current point, using the
/// control point at the offset (x1,y1) from the current point and
/// the weight w. If the weight is greater than 1, then the curve is
/// a hyperbola; if the weight equals 1, it's a parabola; and if it
/// is less than 1, it is an ellipse. À™F	À™N  À™Q	À™Y  À™\	À™d  À™g	À™o  À™rÀ™z   À™€ƒrÀœ©ƒ/// If the `forceMoveTo` argument is false, adds a straight line
/// segment and an arc segment.
///
/// If the `forceMoveTo` argument is true, starts a new sub-path
/// consisting of an arc segment.
///
/// In either case, the arc segment consists of the arc that follows
/// the edge of the oval bounded by the given rectangle, from
/// startAngle radians around the oval up to startAngle + sweepAngle
/// radians around the oval, with zero radians being the point on
/// the right hand side of the oval that crosses the horizontal line
/// that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval.
///
/// The line segment added if `forceMoveTo` is false starts at the
/// current point and ends at the start of the arc. Àœ¯	Àœµ  ÀœºÀœÂ  ÀœÍÀœÕ  ÀœàÀœæ   Àœöƒ!ÀŸ„‚p/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEnd`. The curves follow a path in a direction determined by
/// `clockwise` and `largeArc` in such a way that the sweep angle
/// is always less than 360 degrees.
///
/// A simple line is appended if either radii are zero or the last
/// point in the path is `arcEnd`. The radii are scaled to fit the last path
/// point if both are greater than zero but too small to describe an arc.
/// ÀŸÀŸ—  ÀŸ¤ÀŸ¬  ÀŸÅÀŸÍ  ÀŸàÀŸæ  ÀŸûÀ   ÀŸ´ÀŸºÀŸ»ÀŸ×ÀŸğÀ À ƒ£À£‚Ü/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The last path point is described by (px, py).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEndDelta.dx + px` and `arcEndDelta.dy + py`. The curves follow a
/// path in a direction determined by `clockwise` and `largeArc`
/// in such a way that the sweep angle is always less than 360 degrees.
///
/// A simple line is appended if either radii are zero, or, both
/// `arcEndDelta.dx` and `arcEndDelta.dy` are zero. The radii are scaled to
/// fit the last path point if both are greater than zero but too small to
/// describe an arc. À£1À£9  À£KÀ£S  À£lÀ£t  À£‡À£  À£¢À£¨  À£[À£aÀ£bÀ£~À£—À£³À£ÂvÀ¤%Y/// Adds a new sub-path that consists of four lines that outline the
/// given rectangle. À¤-	À¤3   À¤<.À¥W/// Adds a new sub-path that consists of a curve that forms the
/// ellipse that fills the given rectangle.
///
/// To add a circle, pass an appropriate rectangle as `oval`. [Rect.fromCircle]
/// can be used to easily describe the circle's center [Offset] and radius. À¥_	À¥e   À¥nƒèÀ©ƒ/// Adds a new sub-path with one arc segment that consists of the arc
/// that follows the edge of the oval bounded by the given
/// rectangle, from startAngle radians around the oval up to
/// startAngle + sweepAngle radians around the oval, with zero
/// radians being the point on the right hand side of the oval that
/// crosses the horizontal line that intersects the center of the
/// rectangle and with positive angles going clockwise around the
/// oval.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_dark.png#gh-dark-mode-only)
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_ccw.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_ccw_dark.png#gh-dark-mode-only) À©%	À©+  À©0À©8  À©CÀ©K   À©ZXÀª†/// Adds a new sub-path with a sequence of line segments that connect the given
/// points.
///
/// If `close` is true, a final line segment will be added that connects the
/// last point to the first point.
///
/// The `points` argument is interpreted as offsets from the origin. Àª‘ÀªŸ  Àª¦
Àª¬   Àª¶€°À«P€/// Adds a new sub-path that consists of the straight lines and
/// curves needed to form the rounded rectangle described by the
/// argument. À«YÀ«`   À«jQÀ¬/// Adds the sub-paths of `path`, offset by `offset`, to this path.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given offset. The matrix is a 4x4
/// matrix stored in column major order. À¬‰	À¬  À¬”À¬œ  À¬¤À¬²   À¬¿×À®U‚/// Adds the sub-paths of `path`, offset by `offset`, to this path.
/// The current sub-path is extended with the first sub-path
/// of `path`, connecting them with a lineTo if necessary.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given `offset`.  The matrix is a 4x4
/// matrix stored in column major order. À®d	À®j  À®oÀ®w  À®À®   À®š€“À¯%€/// Closes the last sub-path, as if a straight line had been drawn
/// from the current point to the first point of the sub-path.   À¯1€±À¯Ú€/// Clears the [Path] object of all sub-paths, returning it to the
/// same state it had when it was created. The _current point_ is
/// reset to the origin.   À¯æqÀ±@F/// Tests to see if the given point is within the path. (That is, whether the
/// point would be in the visible portion of the path if the path was used
/// with [Canvas.clipPath].)
///
/// The `point` argument is interpreted as an offset from the origin.
///
/// Returns true if the point is in the path, and false otherwise. À±IÀ±Q   À±[€‰À±Ïj/// Returns a copy of the path with all the segments of every
/// sub-path translated by the given offset. À±ÕÀ±İ   À±è€”À²]k/// Returns a copy of the path with all the segments of every
/// sub-path transformed by the given matrix. À²gÀ²t   À²€ƒ£À¶ƒ0/// Computes the bounding rectangle for this path.
///
/// A path containing only axis-aligned points on the same straight line will
/// have no area, and therefore `Rect.isEmpty` will return true for such a
/// path. Consider checking `rect.width + rect.height > 0.0` instead, or
/// using the [computeMetrics] API to check the path length.
///
/// For many more elaborate paths, the bounds may be inaccurate.  For example,
/// when a path contains a circle, the points used to compute the bounds are
/// the circle's implied control points, which form a square around the circle;
/// if the circle has a transformation applied using [transform] then that
/// square is rotated, and the (axis-aligned, non-rotated) bounding box
/// therefore ends up grossly overestimating the actual area covered by the
/// circle.   À¶'‚”À·p0/// Combines the two paths according to the manner specified by the given
/// `operation`.
///
/// The resulting path will be constructed from non-overlapping contours. The
/// curve order is reduced where possible so that cubics may be turned into
/// quadratics, and quadratics maybe turned into lines. À·xÀ·‡  À·‘
À·—  À·
À·£   À¸¿‡ÃÀÀW‡M/// Creates a [PathMetrics] object for this path, which can describe various
/// properties about the contours of the path.
///
/// A [Path] is made up of zero or more contours. A contour is made up of
/// connected curves and segments, created via methods like [lineTo],
/// [cubicTo], [arcTo], [quadraticBezierTo], their relative counterparts, as
/// well as the add* methods such as [addRect]. Creating a new [Path] starts
/// a new contour once it has any drawing instructions, and another new
/// contour is started for each [moveTo] instruction.
///
/// A [PathMetric] object describes properties of an individual contour,
/// such as its length, whether it is closed, what the tangent vector of a
/// particular offset along the path is. It also provides a method for
/// creating sub-paths: [PathMetric.extractPath].
///
/// Calculating [PathMetric] objects is not trivial. The [PathMetrics] object
/// returned by this method is a lazy [Iterable], meaning it only performs
/// calculations when the iterator is moved to the next [PathMetric]. Callers
/// that wish to memoize this iterable can easily do so by using
/// [Iterable.toList] on the result of this method. In particular, callers
/// looking for information about how many contours are in the path should
/// either store the result of `path.computeMetrics().length`, or should use
/// `path.computeMetrics().toList()` so they can repeatedly check the length,
/// since calling `Iterable.length` causes traversal of the entire iterable.
///
/// In particular, callers should be aware that [PathMetrics.length] is the
/// number of contours, **not the length of the path**. To get the length of
/// a contour in a path, use [PathMetric.length].
///
/// If `forceClosed` is set to true, the contours of the path will be measured
/// as if they had been closed, even if they were not explicitly closed. ÀÀgÀÀm  ÀÀz ÀÀ†¥EÀÀ‘  ÀÀÒI ÀÀúÀÁ%/// Create a new empty [Path] object.  ÀÁ€£ÀÁ½ÀÁ¾ÀÁ¿€/// Avoids creating a new native backing for the path for methods that will
/// create it later, such as [Path.from], [shift] and [transform].   ÀÂMÀÂ«   ÀÂÀÂÀÂŞJÀÂî  ÀÂ÷ÀÃ  ÀÂŞÀÂß0ÀÁÆVÀÂ   ÀÁÆÀÁÇÀÁÍÀÁãÀÁÓÀÁÎÀÁÛÀÁâÀÁÜÀÁäÀÁûÀÁëÀÁåÀÁíÀÂ jÀÂu  ÀÂ|ÀÂ‚  ÀÂ ÀÂ!ÀÂ'ÀÂLÀÂ-ÀÂ(ÀÂ5ÀÂKÀÂ6ÀÂ=ÀÂBÀÂ>ÀÂEÀÂMÀÂcÀÂTÀÂNÀÂVÀÃ,pÀÃ   ÀÃ,ÀÃ-ÀÃ3ÀÃQÀÃ:ÀÃ4ÀÃBÀÃPÀÃCÀÃJÀÃOÀÃKÀÃRÀÃ|ÀÃYÀÃSÀÃ[ÀÃvÀÃpÀÃxÀÃ €ƒÀÄ  ÀÄÀÄ  ÀÃ ÀÃ¡ÀÃ§ÀÃËÀÃ­ÀÃ¨ÀÃµÀÃÊÀÃ¶ÀÃ½ÀÃÂÀÃ¾ÀÃÅÀÃÌÀÃöÀÃÓÀÃÍÀÃÕÀÃğÀÃêÀÃòÀÄ'€“ÀÄŸ  ÀÄ¦ÀÄ®  ÀÄ°ÀÄ¸  ÀÄ'ÀÄ(ÀÄ3ÀÄ4ÀÄ:ÀÄgÀÄ@ÀÄ;ÀÄHÀÄfÀÄIÀÄPÀÄUÀÄQÀÄXÀÄ`ÀÄhÀÄÀÄoÀÄiÀÄqÀÄ‡ÀÄÀÄ‰ÀÄ¾€¥ÀÅ>  ÀÅM	ÀÅU  ÀÅX	ÀÅ`  ÀÄ¾ÀÄ¿ÀÄÊÀÄËÀÄÑÀÄşÀÄ×ÀÄÒÀÄßÀÄıÀÄàÀÄçÀÄìÀÄèÀÄïÀÄ÷ÀÄÿÀÅ,ÀÅÀÅ ÀÅÀÅ&ÀÅ ÀÅ(ÀÅg€“ÀÅß  ÀÅæÀÅî  ÀÅğÀÅø  ÀÅgÀÅhÀÅsÀÅtÀÅzÀÅ§ÀÅ€ÀÅ{ÀÅˆÀÅ¦ÀÅ‰ÀÅÀÅ•ÀÅ‘ÀÅ˜ÀÅ ÀÅ¨ÀÅÍÀÅ¯ÀÅ©ÀÅ±ÀÅÇÀÅÁÀÅÉÀÅş€¥ÀÆ~  ÀÆ	ÀÆ•  ÀÆ˜	ÀÆ   ÀÅşÀÅÿÀÆ
ÀÆÀÆÀÆ>ÀÆÀÆÀÆÀÆ=ÀÆ ÀÆ'ÀÆ,ÀÆ(ÀÆ/ÀÆ7ÀÆ?ÀÆlÀÆFÀÆ@ÀÆHÀÆfÀÆ`ÀÆhÀÆ§€ÑÀÇ:  ÀÇL	ÀÇT  ÀÇW	ÀÇ_  ÀÇb	ÀÇj  ÀÇm	ÀÇu  ÀÆ§ÀÆ¨ÀÆ³ÀÆ´ÀÆºÀÆ÷ÀÆÀÀÆ»ÀÆÈÀÆöÀÆÉÀÆĞÀÆÕÀÆÑÀÆØÀÆàÀÆèÀÆğÀÆøÀÇ(ÀÆÿÀÆùÀÇÀÇ"ÀÇÀÇ$ÀÇ|€èÀÈ  ÀÈ8	ÀÈ@  ÀÈC	ÀÈK  ÀÈN	ÀÈV  ÀÈY	ÀÈa  ÀÇ|ÀÇ}ÀÇˆÀÇ‰ÀÇÀÇÌÀÇ•ÀÇÀÇÀÇËÀÇÀÇ¥ÀÇªÀÇ¦ÀÇ­ÀÇµÀÇ½ÀÇÅÀÇÍÀÈÀÇÔÀÇÎÀÇÖÀÇÿÀÇùÀÈÀÈh€ãÀÉ  ÀÉ		ÀÉ  ÀÉ	ÀÉ  ÀÉ	ÀÉ'  ÀÉ*	ÀÉ2  ÀÉ5	ÀÉ=  ÀÉ@	ÀÉH  ÀÈhÀÈiÀÈtÀÈuÀÈ{ÀÈÈÀÈÀÈ|ÀÈ‰ÀÈÇÀÈŠÀÈ‘ÀÈ–ÀÈ’ÀÈ™ÀÈ¡ÀÈ©ÀÈ±ÀÈ¹ÀÈÁÀÈÉÀÈïÀÈĞÀÈÊÀÈÒÀÈéÀÈãÀÈëÀÉO€óÀÉğ  ÀÊ 	ÀÊ  ÀÊ	ÀÊ  ÀÊ	ÀÊ  ÀÊ!	ÀÊ)  ÀÊ,	ÀÊ4  ÀÊ7	ÀÊ?  ÀÉOÀÉPÀÉ[ÀÉ\ÀÉbÀÉ¯ÀÉhÀÉcÀÉpÀÉ®ÀÉqÀÉxÀÉ}ÀÉyÀÉ€ÀÉˆÀÉÀÉ˜ÀÉ ÀÉ¨ÀÉ°ÀÉŞÀÉ·ÀÉ±ÀÉ¹ÀÉØÀÉÒÀÉÚÀÊF€ÏÀÊ×  ÀÊß	ÀÊç  ÀÊê	ÀÊò  ÀÊõ	ÀÊı  ÀË 	ÀË  ÀËÀË  ÀÊFÀÊGÀÊRÀÊSÀÊYÀÊÀÊ_ÀÊZÀÊgÀÊÀÊhÀÊoÀÊtÀÊpÀÊwÀÊÀÊ‡ÀÊÀÊ—ÀÊŸÀÊÅÀÊ¦ÀÊ ÀÊ¨ÀÊ¿ÀÊ¹ÀÊÁÀË€ßÀË²  ÀËÂ	ÀËÊ  ÀËÍ	ÀËÕ  ÀËØ	ÀËà  ÀËã	ÀËë  ÀËîÀËö  ÀËÀËÀË%ÀË&ÀË,ÀËqÀË2ÀË-ÀË:ÀËpÀË;ÀËBÀËGÀËCÀËJÀËRÀËZÀËbÀËjÀËrÀË ÀËyÀËsÀË{ÀËšÀË”ÀËœÀËü€ŞÀÌ  ÀÌ	ÀÌ  ÀÌÀÌ&  ÀÌ1ÀÌ9  ÀÌDÀÌJ  ÀËüÀËıÀÌŞÀÍo  ÀÍvÀÍ~  ÀÍƒ
ÀÍ‹  ÀÍÀÍ—  ÀÍÀÍ¥  ÀÍ¬ÀÍ´  ÀÍ¿ÀÍÇ  ÀÍÒÀÍØ  ÀÌŞÀÌßÀÌåÀÍ8ÀÌëÀÌæÀÌóÀÍ7ÀÌôÀÌûÀÍ ÀÌüÀÍÀÍÀÍÀÍÀÍ#ÀÍ+ÀÍ3ÀÍ9ÀÍ]ÀÍ@ÀÍ:ÀÍBÀÍWÀÍQÀÍYÀÍèKÀÍù  ÀÎÀÎ  ÀÎÀÎ!  ÀÎ:ÀÎB  ÀÎUÀÎ[  ÀÎpÀÎv  ÀÍèÀÍéÀÎ)ÀÎ/ÀÎ0ÀÎLÀÎeÀÎÀÏ7ÀÏË  ÀÏ×ÀÏß  ÀÏçÀÏï  ÀÏ÷ÀÏÿ  ÀĞÀĞ  ÀĞÀĞ  ÀĞ(ÀĞ.  ÀĞ7ÀĞ=  ÀÏ7ÀÏ8ÀÏ>ÀÏÀÏDÀÏ?ÀÏLÀÏÀÏMÀÏTÀÏYÀÏUÀÏ\ÀÏdÀÏlÀÏtÀÏ|ÀÏ„ÀÏŠÀÏÀÏ¹ÀÏ—ÀÏ‘ÀÏ™ÀÏ³ÀÏ­ÀÏµÀĞKtÀĞ\  ÀĞtÀĞ|  ÀĞÀĞ–  ÀĞ¯ÀĞ·  ÀĞÊÀĞĞ  ÀĞåÀĞë  ÀĞKÀĞLÀĞÀĞ¤ÀĞ¥ÀĞÁÀĞÚÀĞöÀÑÃKÀÒ_  ÀÒzÀÒ‚  ÀÒÀÒ˜  ÀÒ¦ÀÒ®  ÀÒ¼ÀÒÄ  ÀÒÒÀÒÚ  ÀÒéÀÒï  ÀÒşÀÓ  ÀÑÃÀÑÄÀÑÊÀÒÀÑĞÀÑËÀÑØÀÒÀÑÙÀÑàÀÑåÀÑáÀÑèÀÑğÀÑøÀÒ ÀÒÀÒÀÒÀÒÀÒMÀÒ#ÀÒÀÒ%ÀÒGÀÒAÀÒIÀÓ€…ÀÓ#  ÀÓ+	ÀÓ1  ÀÓÀÓÀÓ›€¼ÀÔ  ÀÔ!ÀÔ)  ÀÔ.
ÀÔ6  ÀÔ:ÀÔB  ÀÔHÀÔP  ÀÓ›ÀÓœÀÓ¢ÀÓßÀÓ¨ÀÓ£ÀÓ°ÀÓŞÀÓ±ÀÓ¸ÀÓ½ÀÓ¹ÀÓÀÀÓÈÀÓĞÀÓØÀÓàÀÔÀÓçÀÓáÀÓéÀÔ ÀÓúÀÔÀÔ[€…ÀÔl  ÀÔt	ÀÔz  ÀÔ[ÀÔ\ÀÔä€¼ÀÕa  ÀÕjÀÕr  ÀÕw
ÀÕ  ÀÕƒÀÕ‹  ÀÕ‘ÀÕ™  ÀÔäÀÔåÀÔëÀÕ(ÀÔñÀÔìÀÔùÀÕ'ÀÔúÀÕÀÕÀÕÀÕ	ÀÕÀÕÀÕ!ÀÕ)ÀÕOÀÕ0ÀÕ*ÀÕ2ÀÕIÀÕCÀÕKÀÕ¤€ÁÀÕµ  ÀÕ¼	ÀÕÂ  ÀÕÇÀÕÏ  ÀÕÚÀÕâ  ÀÕ¤ÀÕ¥ÀÖi€ğÀÖõ  ÀÖıÀ×  À×

À×  À×À×  À×$À×,  À×3À×;  À×FÀ×N  ÀÖiÀÖjÀÖpÀÖ½ÀÖvÀÖqÀÖ~ÀÖ¼ÀÖÀÖ†ÀÖ‹ÀÖ‡ÀÖÀÖ–ÀÖÀÖ¦ÀÖ®ÀÖ¶ÀÖ¾ÀÖãÀÖÅÀÖ¿ÀÖÇÀÖİÀÖ×ÀÖßÀ×]tÀ×n  À×yÀ×‡  À×
À×”  À×]À×^À×Õ€ŒÀØ5  ÀØAÀØN  ÀØU
ÀØ[  À×ÕÀ×ÖÀ×ÜÀØÀ×âÀ×İÀ×êÀØÀ×ëÀ×òÀ×÷À×óÀ×úÀØÀØÀØ#ÀØÀØ	ÀØÀØerÀØv  ÀØÀØ†  ÀØeÀØfÀØÛuÀÙ3  ÀÙ=ÀÙJ  ÀØÛÀØÜÀØâÀÙÀØèÀØãÀØğÀÙÀØñÀØøÀØıÀØùÀÙ ÀÙÀÙ!ÀÙÀÙ	ÀÙÀÙTSÀÙe  ÀÙm	ÀÙs  ÀÙxÀÙ€  ÀÙˆÀÙ–  ÀÙTÀÙUÀÚ«€ŸÀÛ  ÀÛ"ÀÛ/  ÀÛ4	ÀÛ<  ÀÛ?	ÀÛG  ÀÚ«ÀÚ¬ÀÚ²ÀÚîÀÚ¸ÀÚ³ÀÚÀÀÚíÀÚÁÀÚÈÀÚÍÀÚÉÀÚĞÀÚ×ÀÚÜÀÚØÀÚßÀÚçÀÚïÀÛÀÚöÀÚğÀÚøÀÛN€ÏÀÛÎ  ÀÛáÀÛî  ÀÛó	ÀÛû  ÀÛş	ÀÜ  ÀÜ	ÀÜ  ÀÛNÀÛOÀÛUÀÛ™ÀÛ[ÀÛVÀÛcÀÛ˜ÀÛdÀÛkÀÛpÀÛlÀÛsÀÛzÀÛÀÛ{ÀÛ‚ÀÛŠÀÛ’ÀÛšÀÛ¼ÀÛ¡ÀÛ›ÀÛ£ÀÜ!gÀÜ2  ÀÜA	ÀÜG  ÀÜLÀÜT  ÀÜ\ÀÜj  ÀÜ!ÀÜ"ÀİŒ€­ÀŞ  ÀŞÀŞ  ÀŞ#	ÀŞ+  ÀŞ.	ÀŞ6  ÀİŒÀİÀİ“ÀİÏÀİ™Àİ”Àİ¡ÀİÎÀİ¢Àİ©Àİ®ÀİªÀİ±Àİ¸Àİ½Àİ¹ÀİÀÀİÈÀİĞÀİïÀİ×ÀİÑÀİÙÀŞ=€ÛÀŞÃ  ÀŞÜÀŞé  ÀŞî	ÀŞö  ÀŞù	Àß  ÀßÀß  ÀŞ=ÀŞ>ÀŞDÀŞˆÀŞJÀŞEÀŞRÀŞ‡ÀŞSÀŞZÀŞ_ÀŞ[ÀŞbÀŞiÀŞnÀŞjÀŞqÀŞyÀŞÀŞ‰ÀŞ±ÀŞÀŞŠÀŞ’ÀßoÀßƒ   ÀßÀßÀß(Àß)Àß/ÀßLÀß5Àß0Àß=ÀßKÀß>ÀßEÀßJÀßFÀßMÀßqÀßTÀßNÀßVÀßkÀßeÀßmÀßoÀßö   ÀßÀßÀß›ÀßœÀß¢Àß¿Àß¨Àß£Àß°Àß¾Àß±Àß¸Àß½Àß¹ÀßÀÀßäÀßÇÀßÁÀßÉÀßŞÀßØÀßàÀàzÀà  ÀàÀà$  ÀàÀàÀà€€ŒÀàî  ÀàøÀá   ÀáÀá
  Àà€ÀàÀà‡Àà´ÀàÀàˆÀà•Àà³Àà–ÀàÀà¢ÀàÀà¥Àà­ÀàµÀàÜÀà¼Àà¶Àà¾ÀàÖÀàĞÀàØÀá€¶Àá!  Àá'Àá/  ÀáÀáÀáÊ€Àâ/  Àâ6Àâ<  ÀâD	ÀâL  ÀâO	ÀâW  ÀáÊÀáËÀáÑÀâÀá×ÀáÒÀáßÀâÀáàÀáçÀáìÀáèÀáïÀá÷ÀáÿÀâÀâÀâÀâÀâÀâ^€¹Àâo  ÀâyÀâ†  Àâ^Àâ_Àã€Àã|  Àã‡Àã  Àã•Àã¢  ÀãÀãÀã"ÀãOÀã(Àã#Àã0ÀãNÀã1Àã8Àã=Àã9Àã@ÀãHÀãPÀãjÀãWÀãQÀãYÀã®€‹Àã¿   Àã®Àã¯Àä=gÀä—   Àä=Àä>ÀäDÀäcÀäLÀäEÀäTÀäbÀäUÀä\ÀäaÀä]ÀädÀä~ÀäkÀäeÀämÀä¨€¨Àå  ÀåÀå(  Àå.Àå;  ÀåAÀåF  Àä¨Àä©Àä¯ÀäñÀäµÀä°Àä½ÀäğÀä¾ÀäÅÀäÊÀäÆÀäÍÀäÔÀäÙÀäÕÀäÜÀäãÀäèÀääÀäëÀäòÀåÀäùÀäóÀäûÀåTuÀål  Àå|Àå‚  ÀåTÀåUÀå ÀåÍ‡DÀæ…€±/// The geometric description of a tangent: the angle at a point.
///
/// See also:
///  * [PathMetric.getTangentForOffset], which returns the tangent of an offset along a path. Àæ‘€‡ ÀæôÀæûV/// Creates a [Tangent] with the given values.
///
/// The arguments must not be null.ÀæüÀç  ÀçÀç   ÀçRÀç÷ÀçøÀè€Ã/// Creates a [Tangent] based on the angle rather than the vector.
///
/// The [vector] is computed to be the unit vector at the given angle, interpreted
/// as clockwise radians from the x axis.ÀèÀè
  ÀèÀè   Àèr€ÑÀé;€³/// Position of the tangent.
///
/// When used with [PathMetric.getTangentForOffset], this represents the precise
/// position that the given offset along the path corresponds to. ÀéHÀêG€ç/// The vector of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the vector of the
/// curve that is at the given offset along the path (i.e. the direction of the
/// curve at [position]). ÀêR‚½Àìä‚+/// The direction of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the angle of the
/// curve that is the given offset along the path (i.e. the direction of the
/// curve at [position]).
///
/// This value is in radians, with 0.0 meaning pointing along the x axis in
/// the positive x-axis direction, positive numbers pointing downward toward
/// the negative y-axis, i.e. in a clockwise direction, and negative numbers
/// pointing upward toward the positive y-axis, i.e. in a counter-clockwise
/// direction.     Àí„#Àğ‚ô/// An iterable collection of [PathMetric] objects describing a [Path].
///
/// A [PathMetrics] object is created by using the [Path.computeMetrics] method,
/// and represents the path as it stood at the time of the call. Subsequent
/// modifications of the path do not affect the [PathMetrics] object.
///
/// Each path metric corresponds to a segment, or contour, of a path.
///
/// For example, a path consisting of a [Path.lineTo], a [Path.moveTo], and
/// another [Path.lineTo] will contain two contours and thus be represented by
/// two [PathMetric] objects.
///
/// This iterable does not memoize. Callers who need to traverse the list
/// multiple times, or who need to randomly access elements of the list, should
/// use [toList] on this object. ÀğJ€‚ÀğUÀğVÀğW ÀğX	Àğ^  ÀğcÀği  Àğ…Àğ{Àğ‡Àğ™ÀğšÀğ›ÀğÊÀğœÀğ¨ÀğÉÀğ®Àğ©Àğ±Àğ¾ÀğĞ$Àğë  Àğù;Àñ   ÀğùÀğú  Àñ8ƒÂÀñ§h/// Used by [PathMetrics] to track iteration from one segment of a path to the
/// next for measurement. ÀñŞ(ÀñğÀññÀñò ÀñóÀñù   Àò
Àò  Àò%Àò8  ÀòIğÀòd   ÀòIÀòJÀô=€»ÀôN   Àô=Àô> ÀôükÀ÷ã‚à/// Utilities for measuring a [Path] and extracting sub-paths.
///
/// Iterate over the object returned by [Path.computeMetrics] to obtain
/// [PathMetric] objects. Callers that want to randomly access elements or
/// iterate multiple times should use `path.computeMetrics().toList()`, since
/// [PathMetrics] does not memoize.
///
/// Once created, the metrics are only valid for the path as it was specified
/// when [Path.computeMetrics] was called. If additional contours are added or
/// any contours are updated, the metrics need to be recomputed. Previously
/// created metrics will still refer to a snapshot of the path at the time they
/// were computed, rather than to the actual metrics for the new mutations to
/// the path. À÷ò€ÎÀ÷üÀ÷ıÀ÷ş À÷ÿÀø  ÀøÀøÀøÀø%Àø&Àø,ÀøIÀø-Àø5Àø6Àø[ÀøRÀø]ÀøeÀøfÀønÀø‹ÀøoÀøwÀøxÀø¡Àø”Àø£Àø«Àø¬ÀøÄ+Àùé/// Return the total length of the current contour.
///
/// The length may be calculated from an approximation of the geometry
/// originally added. For this reason, it is not recommended to rely on
/// this property for mathematically correct lengths of common shapes. ÀùôAÀû-!/// Whether the contour is closed.
///
/// Returns true if the contour ends with a call to [Path.close] (which may
/// have been implied when using methods like [Path.addRect]) or if
/// `forceClosed` was specified as true in the call to [Path.computeMetrics].
/// Returns false otherwise. Àû:‚àÀş‚±/// The zero-based index of the contour.
///
/// [Path] objects are made up of zero or more contours. The first contour is
/// created once a drawing command (e.g. [Path.lineTo]) is issued. A
/// [Path.moveTo] command after a drawing command may create a new contour,
/// although it may not if optimizations are applied that determine the move
/// command did not actually result in moving the pen.
///
/// This property is only valid with reference to its original iterator and
/// the contours of the path at the time the path's metrics were computed. If
/// additional contours were added or existing contours updated, this metric
/// will be invalid for the current state of the path. ÀşÀş2   Àş?‚,À  £/// Computes the position of the current contour at the given offset, and the
/// angle of the path at that point.
///
/// For example, calling this method with a distance of 1.41 for a line from
/// 0.0,0.0 to 2.0,2.0 would give a point 1.0,1.0 and the angle 45 degrees
/// (but in radians).
///
/// Returns null if the contour has zero [length].
///
/// The distance is clamped to the [length] of the current contour. À À    À oÀI€Ì/// Given a start and end distance, return the intervening segment(s).
///
/// `start` and `end` are clamped to legal values (0..[length])
/// Begin the segment with a moveTo if `startWithMoveTo` is true. ÀUÀ]  Àc
Àk  ÀpÀv  À‡ÀôqÀ   ÀôÀõ Ài‹Àt  À¦[ À¦À² À³ÀÀ  ÀÅÀË   ÀÎ€¯Àe€Œ/// The index of the current contour in the list of contours in the path.
///
/// [nextContour] will increment this to the zero based index.À{À| À€”Àh  ÀuÀ‚  À‡À  ÀÀÀÀ7ÀÀÀÀ6ÀÀ#À*À/À+À2À8ÀVÀ?À9ÀAÀ€½À¤  À«À°   À^€‹ÀÏ  À×ÀÜ  À^À_ÀeÀ‹ÀmÀfÀuÀŠÀvÀ}À‚À~À…ÀŒÀ»À“ÀÀ•ÀµÀ¯À·ÀííÀö  À
À  ÀÀ$   ÀŞ€ÀN  ÀYÀ^  ÀkÀs  ÀŞÀßÀåÀÀíÀæÀõÀÀöÀıÀÀşÀÀÀÀ5ÀÀÀÀ€_À…  À‘À–  À£À«  À±
À¹  ÀÄÀÊ  ÀÛÀã€ÛÀ	a  À	nÀ	t  À	|À	  À	À	–  À	œ
À	¤  À	¨À	®  ÀãÀäÀêÀ	,ÀğÀëÀøÀ	+ÀùÀ	 À	À	À	À	À	À	À	'À	-À	OÀ	4À	.À	6À	Â€¿À	Ç  À	ĞÀ	Õ   À
…€ˆÀ
ñ  À
ûÀ   À
…À
†À
ŒÀ
°À
’À
À
šÀ
¯À
›À
¢À
§À
£À
ªÀ
±À
ßÀ
¸À
²À
ºÀ
ÙÀ
ÓÀ
ÛÀÀ€‰ÀÅ    ÀM}Àµ   ÀMÀNÀTÀqÀZÀUÀbÀpÀcÀjÀoÀkÀrÀ£ÀyÀsÀ{ÀÀ—ÀŸ Àÿ†|À	/// A mask filter to apply to shapes as they are painted. A mask filter is a
/// function that takes a bitmap of color pixels, and returns another bitmap of
/// color pixels.
///
/// Instances of this class are used with [Paint.maskFilter] on [Paint] objects. ÀƒÀòÀóÀ÷‚¥/// Creates a mask filter that takes the shape being drawn and blurs it.
///
/// This is commonly used to approximate shadows.
///
/// The `style` argument controls the kind of effect to draw; see [BlurStyle].
///
/// The `sigma` argument controls the size of the effect. It is the standard
/// deviation of the Gaussian blur to apply. The value must be greater than
/// zero. The sigma corresponds to very roughly half the radius of the effect
/// in pixels.
///
/// A blur is an expensive operation and should therefore be used sparingly.
///
/// The arguments must not be null.
///
/// See also:
///
///  * [Canvas.drawShadow], which is a more efficient way to draw shadows.ÀıÀ  ÀÀ   À#À3  À=ÀJ  ÀæÀ÷ ÀÀÀ! À-Àß<Àó   ÀßÀàÀG€”Àa  ÀdÀl  ÀGÀHÀZÀ2   ÀÀ  À}™kÀHÄ/// A description of a color filter to apply when drawing a shape or compositing
/// a layer with a particular [Paint]. A color filter is a function that takes
/// two colors, and outputs one color. When applied during compositing, it is
/// independently applied to each pixel of the layer being drawn before the
/// entire layer is merged with the destination.
///
/// Instances of this class are used with [Paint.colorFilter] on [Paint]
/// objects. Ào‚XÀ4À5À9¥/// Creates a color filter that applies the blend mode given as the second
/// argument. The source color is the one given as the first argument, and the
/// destination color is the one from the layer being composited.
///
/// The output of this filter is then composited into the background according
/// to the [Paint.blendMode], using the output of this filter as the source
/// and the background as the destination.À:ÀA  ÀGÀR  ÀkÀdÀmÀ‡À|À‰À¤ÀœÀ¦ÀºÀ´À¼ÀËˆEÀ#ŠÀ#‹À#‘‡7/// Construct a color filter from a 4x5 row-major matrix. The matrix is
/// interpreted as a 5x5 matrix, where the fifth row is the identity
/// configuration.
///
/// Every pixel's color value, represented as an `[R, G, B, A]`, is matrix
/// multiplied to create a new color:
///
///     | R' |   | a00 a01 a02 a03 a04 |   | R |
///     | G' |   | a10 a11 a12 a13 a14 |   | G |
///     | B' | = | a20 a21 a22 a23 a24 | * | B |
///     | A' |   | a30 a31 a32 a33 a34 |   | A |
///     | 1  |   |  0   0   0   0   1  |   | 1 |
///
/// The matrix is in row-major order and the translation column is specified
/// in unnormalized, 0...255, space. For example, the identity matrix is:
///
/// ```dart
/// const ColorFilter identity = ColorFilter.matrix(<double>[
///   1, 0, 0, 0, 0,
///   0, 1, 0, 0, 0,
///   0, 0, 1, 0, 0,
///   0, 0, 0, 1, 0,
/// ]);
/// ```
///
/// ## Examples
///
/// An inversion color matrix:
///
/// ```dart
/// const ColorFilter invert = ColorFilter.matrix(<double>[
///   -1,  0,  0, 0, 255,
///    0, -1,  0, 0, 255,
///    0,  0, -1, 0, 255,
///    0,  0,  0, 1,   0,
/// ]);
/// ```
///
/// A sepia-toned color matrix (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#sepiaEquivalent)):
///
/// ```dart
/// const ColorFilter sepia = ColorFilter.matrix(<double>[
///   0.393, 0.769, 0.189, 0, 0,
///   0.349, 0.686, 0.168, 0, 0,
///   0.272, 0.534, 0.131, 0, 0,
///   0,     0,     0,     1, 0,
/// ]);
/// ```
///
/// A greyscale color filter (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#grayscaleEquivalent)):
///
/// ```dart
/// const ColorFilter greyscale = ColorFilter.matrix(<double>[
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0,      0,      0,      1, 0,
/// ]);
/// ```À#’À#   À#¶À#¯À#¸À#ÑÀ#ÆÀ#ÓÀ#éÀ#áÀ#ëÀ$À#ûÀ$À$€ôÀ$À$‚À$“W/// Construct a color filter that applies the sRGB gamma curve to the RGB
/// channels. À$¥À$À$§À$ÀÀ$µÀ$ÂÀ$ØÀ$ĞÀ$ÚÀ$îÀ$èÀ$ğÀ%À%†À%‡À%˜d/// Creates a color filter that applies the inverse of the sRGB gamma curve
/// to the RGB channels. À%ªÀ%£À%¬À%ÅÀ%ºÀ%ÇÀ%İÀ%ÕÀ%ßÀ%óÀ%íÀ%õÀ&À&  À&(À&9  À&GÀ&[  À&fÀ&p  À&ªÀ&» À&ÈÀ&ß!À&ğ À&ÿÀ'#,À'4 À'NÀ'l,À'} À'—À,A€¯À,U   À,AÀ,BÀ,ôÁÀ-   À,ôÀ,õÀ'ÎVÀ'ç   À'ÎÀ'ÏÀ((‚×À(6    À+:À+  À+ À+(  À+À+À.¹‚-À.Ì   À.¹À.º À0ê‡jÀ2:D/// A [ColorFilter] that is backed by a native DlColorFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ColorFilter, because we want ColorFilter to be const constructible and
/// efficiently comparable, so that widgets can check for ColorFilter equality to
/// avoid repainting. À2l€°À2xÀ2yÀ2} À2~À2„  
À2’À2˜À2ÀÀ2§À2™À2 À2¡À2ªÀ2µÀ2¶À3 €¬À3,À3-À33 À34À3:  
À3HÀ3NÀ3xÀ3]À3OÀ3VÀ3WÀ3`À3kÀ3lÀ3Ï€§À3ÛÀ3ÜÀ3í À3îÀ3ô  
À4À4À4=À4À4	À4À4À4À4%À4&À4z€§À4†À4‡À4˜ À4™À4Ÿ  
À4­À4³À4èÀ4ÂÀ4´À4»À4¼À4ÅÀ4ĞÀ4ÑÀ5%€À5«o/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À5·]À6   À5·À5¸À5¾À5ÔÀ5ÄÀ5¿À5ÌÀ5ÓÀ5ÍÀ5ÕÀ5óÀ5ÜÀ5ÖÀ5ŞÀ6€—À6‹  À6•	À6š  À6 À6¥  À6À6À6À6JÀ6%À6 À6-À6IÀ6.À65À6:À66À6=À6DÀ6KÀ6yÀ6RÀ6LÀ6TÀ6sÀ6mÀ6uÀ6³€À7  À7 À7-  À6³À6´À6ºÀ6ßÀ6ÀÀ6»À6ÈÀ6ŞÀ6ÉÀ6ĞÀ6ÕÀ6ÑÀ6ØÀ6àÀ7À6çÀ6áÀ6éÀ78€‹À7ª   À78À79À7?À7\À7EÀ7@À7MÀ7[À7NÀ7UÀ7ZÀ7VÀ7]À7˜À7dÀ7^À7fÀ7’À7ŒÀ7”À7Ç€‹À89   À7ÇÀ7ÈÀ7ÎÀ7ëÀ7ÔÀ7ÏÀ7ÜÀ7êÀ7İÀ7äÀ7éÀ7åÀ7ìÀ8'À7óÀ7íÀ7õÀ8!À8À8# À8V‹À:8Ò/// A filter operation to apply to a raster image.
///
/// See also:
///
///  * [BackdropFilter], a widget that applies [ImageFilter] to its rendering.
///  * [ImageFiltered], a widget that applies [ImageFilter] to its children.
///  * [SceneBuilder.pushBackdropFilter], which is the low-level API for using
///    this class as a backdrop filter.
///  * [SceneBuilder.pushImageFilter], which is the low-level API for using
///    this class as a child layer filter. À:šÀ:¥À:¦À:§   À:ÈÀ;À;À;9/// Creates an image filter that applies a Gaussian blur.À;À;'  À;4À;<  À;I"À;S  À;/À;DÀ;]À;eÀ;fÀ;Ñ&À<wÀ<xÀ<~€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.À<À<‰  À<—À<Ÿ  À<’À<¨À<û'À=¤À=¥À=ª€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.À=­À=µ  À=ÃÀ=Ë  À=¾À=ÔÀ>&‚'À?À?À?"€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.À?#À?0  À?O/À?^  À?mÀ?zÀ?{À@Q ÀA_ÀA`ÀAg€ğ/// Composes the `inner` filter with `outer`, to combine their effects.
///
/// Creates a single [ImageFilter] that when applied, has the same effect as
/// subsequently applying `inner` and `outer`, i.e.,
/// result = outer(inner(source)).ÀAjÀA€  ÀA†ÀAœ    ÀC<ÀCG    ÀB“$ÀB      ÀC]ƒ`ÀCc  ÀC‘H ÀC‘ÀC£ ÀC¦ÀCµ  ÀCºÀCÉ   ÀCİÀCï  ÀC÷!ÀD  ÀD>@ÀDV ÀDeÀDqÀDrÀDxÀD}ÀDyÀDÆLÀDİ   ÀDÆÀDÇÀFjQÀF~   ÀFjÀFkÀD‚@ÀD›   ÀD‚ÀDƒÀEMÀE)   ÀEÀEÀEg€ÿÀE  ÀE„ÀEŒ  ÀEgÀEh ÀF¿„tÀFÅ  ÀFùa ÀFùÀG ÀGÀG#  ÀG*ÀG9  ÀG@ÀGO   ÀG^ÀGk  ÀGuÀG‚  ÀGŒÀG›  ÀG¼>ÀGÔ ÀGãÀGïÀGğÀGôÀGùÀGõÀHB€îÀHM    ÀI4SÀIK   ÀI4ÀI5ÀJõ<ÀK	   ÀJõÀJöÀGş@ÀH   ÀGşÀGÿÀI‹TÀI   ÀI‹ÀIŒÀIãÀIı  ÀJ ÀJ  ÀIãÀIä ÀK5‚ûÀK;  ÀKiE ÀKiÀK{ ÀK~ÀK  ÀK•ÀK¤   ÀK²ÀK¿  ÀKÊÀK×  ÀKã@ÀKû ÀL
ÀLÀLÀLÀL"ÀLÀLkIÀL‚   ÀLkÀLlÀMğ>ÀN   ÀMğÀMñÀL'@ÀL@   ÀL'ÀL(ÀL¸JÀLË   ÀL¸ÀL¹ÀM€æÀM   ÀM#ÀM+  ÀMÀM ÀN2‚õÀN8  ÀNeD ÀNeÀNv ÀNyÀNˆ  ÀNÀNŸ   ÀN­ÀNº  ÀNÅÀNÒ  ÀNŞ?ÀNö ÀOÀOÀOÀOÀOÀOÀOeHÀO|   ÀOeÀOfÀPç>ÀPû   ÀPçÀPèÀO!@ÀO:   ÀO!ÀO"ÀO±IÀOÄ   ÀO±ÀO²ÀOş€åÀP  ÀPÀP#  ÀOşÀOÿ ÀQ)ƒ‹ÀQ/  ÀQ^N ÀQ^ÀQq ÀQtÀQƒ  ÀQÀQ   ÀQ°ÀQÂ  ÀQÑÀQã  ÀRBÀR% ÀR4ÀR@ÀRAÀRIÀRNÀRJÀR—sÀR®   ÀR—ÀR˜ÀTlFÀT€   ÀTlÀTmÀRS@ÀRl   ÀRSÀRTÀS_ÀS!   ÀSÀSÀSq€÷ÀS‹  ÀSÀS–  ÀSqÀSr ÀT¶öÀUë)/// An [ImageFilter] that is backed by a native DlImageFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ImageFilter, because we want ImageFilter to be efficiently comparable, so that
/// widgets can check for ImageFilter equality to avoid repainting. ÀV€ãÀVeÀVfÀVj9/// Creates an image filter that applies a Gaussian blur.ÀVkÀV…  ÀVšÀV’ÀVœÀW#ÀW£ÀW¤ÀWª€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.ÀW«ÀW¿  ÀWÔÀWÌÀWÖÀX+#ÀXÍÀXÎÀXÓ€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.ÀXÔÀXç  ÀXüÀXôÀXşÀYRãÀZ@ÀZAÀZG€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.ÀZHÀZ\  ÀZqÀZiÀZsÀ[9€ıÀ[wÀ[xÀ[‡//// Converts a color filter to an image filter.À[ˆÀ[•  À[ªÀ[¢À[¬À\:zÀ\yÀ\zÀ\‚0/// Composes `_innerFilter` with `_outerFilter`.À\ƒÀ\˜  À\­À\¥À\¯Àb€Àb¢o/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À]¸]À^   À]¸À]¹À]¿À]ÕÀ]ÅÀ]ÀÀ]ÍÀ]ÔÀ]ÎÀ]ÖÀ]ôÀ]İÀ]×À]ßÀ^€²À^•  À^ŸÀ^§  À^®À^¶  À^½À^Â  À^À^À^ À^TÀ^&À^!À^.À^SÀ^/À^6À^;À^7À^>À^FÀ^NÀ^UÀ^ƒÀ^\À^VÀ^^À^}À^wÀ^À^Ï€£À_F  À_RÀ_Z  À_bÀ_j  À^ÏÀ^ĞÀ^ÖÀ_À^ÜÀ^×À^äÀ_À^åÀ^ìÀ^ñÀ^íÀ^ôÀ^üÀ_À_4À_À_À_À_.À_(À_0À_v€¡À_ì  À_÷À_ÿ  À`À`  À_vÀ_wÀ_}À_ªÀ_ƒÀ_~À_‹À_©À_ŒÀ_“À_˜À_”À_›À_£À_«À_ÚÀ_²À_¬À_´À_ÔÀ_ÎÀ_ÖÀ`€œÀ`ƒ  À`À`œ  À`¤À`©  À`À`À`"À`NÀ`(À`#À`0À`MÀ`1À`8À`=À`9À`@À`HÀ`OÀ`qÀ`VÀ`PÀ`XÀ`»€™Àa(  Àa9ÀaH  À`»À`¼À`ÂÀ`îÀ`ÈÀ`ÃÀ`ĞÀ`íÀ`ÑÀ`ØÀ`İÀ`ÙÀ`àÀ`çÀ`ìÀ`èÀ`ïÀaÀ`öÀ`ğÀ`øÀaX€ÀÀaÖ  ÀaäÀaò  ÀaşÀb  ÀaXÀaYÀa_ÀašÀaeÀa`ÀamÀa™ÀanÀauÀazÀavÀa}Àa„Àa‰Àa…ÀaŒÀa“Àa˜Àa”Àa›ÀaÄÀa¢ÀaœÀa¤ Àb®„ëÀc4z/// Base class for objects such as [Gradient] and [ImageShader] which
/// correspond to shaders as used by [Paint.shader]. Àc`€ÀcèÀcéÀcêa/// This class is created by the engine, and should not be instantiated
/// or extended directly. ÀcÆÀcÇÀcÍÀcŞÀcÎÀcñÀcö ÀdÀdÀdšy/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   Àe,‚kÀgÛ/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, a [Picture] that has not been disposed that
/// refers to an [ImageShader] may keep its underlying resources alive.
///
/// Classes that override this method must call `super.dispose()`.    À~P©Àœ@/// A shader (as used by [Paint.shader]) that renders a color gradient.
///
/// There are several types of gradients, represented by the various constructors
/// on this class.
///
/// See also:
///
///  * [Gradient](https://api.flutter.dev/flutter/painting/Gradient-class.html), the class in the [painting] library.
/// À¸‰À†À†À††/// Creates a linear gradient from `from` to `to`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before `from` and after `to` is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
///
/// If `from`, `to`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.À†À†  À†	À†'  À†.À†;  À†HÀ†W  À†f"À†p  À†À†œ  !À†zÀ†‚À†ƒÀ†«À†±À†ÆÀ†²À†ÀÀ†ÅÀ†ÁÀ†ĞÀ†ÖÀ†éÀ†×À†åÀ†èÀ†æÀ†óÀ†ùÀ‡%À‡
À‡À†úÀ‡À‡À‡À‡$À‡À‡/À‡4À‡5À‡6À‡7ÀˆÇŒøÀ÷ÀøÀş‡ã/// Creates a radial gradient centered at `center` that ends at `radius`
/// distance from the center.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before and after the radius is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
///
/// If `center`, `radius`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.
///
/// If `focal` is provided and not equal to `center` and `focalRadius` is
/// provided and not equal to 0.0, the generated shader will be a two point
/// conical radial gradient, with `focal` being the center of the focal
/// circle and `focalRadius` being the radius of that circle. If `focal` is
/// provided and not equal to `center`, at least one of the two offsets must
/// not be equal to [Offset.zero].À‘À‘  À‘À‘  À‘*À‘7  À‘DÀ‘S  À‘b"À‘l  À‘ŠÀ‘˜  À‘¤À‘­  À‘·À‘¿  À‘vÀ‘~À‘À‘ÌÀ‘×À‘İÀ‘ôÀ‘ŞÀ‘ìÀ‘óÀ‘íÀ‘şÀ’À’0À’À’À’À’À’À’'À’/À’(À’:À’?À’@À’AÀ’BÀ•ÃŠIÀ=À>ÀC‡3/// Creates a sweep gradient centered at `center` that starts at `startAngle`
/// and ends at `endAngle`.
///
/// `startAngle` and `endAngle` should be provided in radians, with zero
/// radians being the horizontal line to the right of the `center` and with
/// positive angles going clockwise around the `center`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before `startAngle` and after `endAngle` is described by the
/// `tileMode` argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png)
///
/// If `center`, `colors`, `tileMode`, `startAngle`, or `endAngle` are null,
/// or if `colors` or `colorStops` contain null values, this constructor will
/// throw a [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.ÀIÀQ  À\Ài  ÀvÀ…  À”"À  À¼ÀÄ  ÀÙÀá  ÀüÀ
  &À¨À°À±ÀĞÀóÀëÀïÀğÀõÀÀÀ6À À.À5À/À@ÀFÀ\ÀRÀGÀTÀfÀlÀ˜À}ÀuÀmÀxÀ€ÀÀ—ÀÀ¢À§À¨À©Àª  À ZÀ [   À À À À -À À À %À ,À &À .À IÀ 5À /À 7À n€ïÀ ë  À ÷À¡  À¡À¡  À¡ À¡.  À¡9À¡>  À¡GÀ¡U  À nÀ oÀ uÀ ¹À {À vÀ ƒÀ ¸À „À ‹À À ŒÀ “À ›À £À «À ²À ºÀ ÙÀ ÁÀ »À ÃÀ¡aBÀ¡î  À¢À¢	  À¢À¢  À¢-À¢5  À¢BÀ¢M  À¢ZÀ¢h  À¢yÀ¢~  À¢À¢›  À¡aÀ¡bÀ¡hÀ¡¼À¡nÀ¡iÀ¡vÀ¡»À¡wÀ¡~À¡ƒÀ¡À¡†À¡À¡–À¡À¡¦À¡®À¡µÀ¡½À¡ÜÀ¡ÄÀ¡¾À¡ÆÀ¢§¥À£U  
À£iÀ£q  À£~À£†  À£“À£›  À£­À£µ  À£ÀÀ£È  À£ÓÀ£Û  À£ëÀ£ö  À¤À¤  À¤"À¤'  À¤6À¤D  À¢§À¢¨À¢®À£À¢´À¢¯À¢¼À£À¢½À¢ÄÀ¢ÉÀ¢ÅÀ¢ÌÀ¢ÔÀ¢ÜÀ¢äÀ¢ìÀ¢ôÀ¢üÀ£À£À£À£À£CÀ£"À£À£$À¤PbÀ¤ä  À¤öÀ¤ş  À¥À¥  À¥"À¥-  À¥:À¥H  À¥YÀ¥^  À¥mÀ¥u  À¥†À¥  À¥À¥«  À¤PÀ¤QÀ¤WÀ¤³À¤]À¤XÀ¤eÀ¤²À¤fÀ¤mÀ¤rÀ¤nÀ¤uÀ¤}À¤…À¤À¤•À¤œÀ¤¤À¤¬À¤´À¤ÒÀ¤»À¤µÀ¤½À¥¶ŸÀ¥Â  À¥İÀ¥ê  À¥ñÀ¦     À§YˆlÀ§¢=/// A shader (as used by [Paint.shader]) that tiles an image. À§Á…– À«…À«ƒ/// Creates an image-tiling shader.
///
/// The first argument specifies the image to render. The
/// [decodeImageFromList] function can be used to decode an image from bytes
/// into the form expected here. (In production code, starting from
/// [instantiateImageCodec] may be preferable.)
///
/// The second and third arguments specify the [TileMode] for the x direction
/// and y direction respectively. [TileMode.repeated] can be used for tiling
/// images.
///
/// The fourth argument gives the matrix to apply to the effect. The
/// expression `Matrix4.identity().storage` creates a [Float64List]
/// prepopulated with the identity matrix.
///
/// All the arguments are required and must not be null, except for
/// [filterQuality]. If [filterQuality] is not specified at construction time
/// it will be deduced from the environment where it is used, such as from
/// [Paint.filterQuality].À«‘À«˜  À«À«¨  À«¬À«¶  À«ºÀ«Ç  À«ÕÀ«å  À«iÀ«jÀ«pÀ«À«qÀ«şÀ¬À¬À¬À¬À¬À¬À¬ À¬%À¬&À¬'À¬(  À­[EÀ­l   À­[À­\À­¤]À­ò   À­¤À­¥À­«À­ÁÀ­±À­¬À­¹À­ÀÀ­ºÀ­ÂÀ­àÀ­ÉÀ­ÃÀ­ËÀ®€éÀ®’  À®¡À®©  À®¯À®´  À®¸À®½  À®ÁÀ®Æ  À®ÙÀ®æ  À®À®À®À®WÀ®À®À®À®VÀ®À®$À®)À®%À®,À®3À®8À®4À®;À®BÀ®IÀ®PÀ®XÀ®}À®_À®YÀ®aÀ®ò€ÑÀ¯¸k/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À¯bÀ¯cÀ¯iÀ¯†À¯oÀ¯jÀ¯wÀ¯…À¯xÀ¯À¯„À¯€À¯‡À¯¦À¯À¯ˆÀ¯ À¯ÇŒÏÀ°¯€Ü/// An instance of [FragmentProgram] creates [Shader] objects (as used by
/// [Paint.shader]).
///
/// For more information, see the website
/// [documentation]( https://docs.flutter.dev/development/ui/advanced/shaders). À°ä!À±À±À± À±À±#  À°äÀ°åÀ°ëÀ°üÀ°ìÀ²	À²  À·«{À·ä 	À¸$À¸%À·üÀ¸#À·ıÀ¸À¸À¸"À¸Àº§7ÀºÌ Àº§Àº¨Àº®Àº¿Àº¯Àºã2À» ÀºãÀºäÀºêÀºûÀºë À² „SÀ³{//// Creates a fragment program from the asset with key [assetKey].
///
/// The asset must be a file produced as the output of the `impellerc`
/// compiler. The constructed object should then be reused via the
/// [fragmentShader] method to create [Shader] objects that can be used by
/// [Paint.shader]. À³…À³   À¸+‚xÀ¸7  À¸KÀ¸S   À»aÀ»l   À»À»À»!À»7À»'À»"À»/À»6À»0À»8À»ZÀ»?À»9À»AÀ»€ŒÀ»ë  À»úÀ¼  À»À»€À»†À»­À»À»‡À»–À»¬À»—À»À»£À»ŸÀ»¦À»®À»×À»µÀ»¯À»·À¼€…À¼R1/// Returns a fresh instance of [FragmentShader].    À¼˜‘şÀ¿‰‚å/// A [Shader] generated from a [FragmentProgram].
///
/// Instances of this class can be obtained from the
/// [FragmentProgram.fragmentShader] method. The float uniforms list is
/// initialized to the size expected by the shader and is zero-filled. Uniforms
/// of float type can then be set by calling [setFloat]. Sampler uniforms are
/// set by calling [setImageSampler].
///
/// A [FragmentShader] can be re-used, and this is an efficient way to avoid
/// allocating and re-initializing the uniform buffer and samplers. However,
/// if two [FragmentShader] objects with different float uniforms or samplers
/// are required to exist simultaneously, they must be obtained from two
/// different calls to [FragmentProgram.fragmentShader]. À¿«€ÛÀ¿¹À¿ºÀ¿» À¿¼À¿Í  À¿×À¿à  À¿ùÀ¿îÀ¿ûÀÀÀÀÀÀÀÀÀÀÀÀŠÀÀ˜  ÀÀ§<ÀÀÀ ÀÀÕÀÀàÀÀâÀÀáÀÀç(ÀÀó ÀÀı ÀÁ‡ÀÈ†œ/// Sets the float uniform at [index] to [value].
///
/// All uniforms defined in a fragment shader that are not samplers must be
/// set through this method. This includes floats and vec2, vec3, and vec4.
/// The correct index for each uniform is determined by the order of the
/// uniforms as defined in the fragment program, ignoring any samplers. For
/// data types that are composed of multiple floats such as a vec4, more than
/// one call to [setFloat] is required.
///
/// For example, given the following uniforms in a fragment program:
///
/// ```glsl
/// uniform float uScale;
/// uniform sampler2D uTexture;
/// uniform vec2 uMagnitude;
/// uniform vec4 uColor;
/// ```
///
/// Then the corresponding Dart code to correctly initialize these uniforms
/// is:
///
/// ```dart
/// void updateShader(ui.FragmentShader shader, Color color, ui.Image image) {
///   shader.setFloat(0, 23);  // uScale
///   shader.setFloat(1, 114); // uMagnitude x
///   shader.setFloat(2, 83);  // uMagnitude y
///
///   // Convert color to premultiplied opacity.
///   shader.setFloat(3, color.red / 255 * color.opacity);   // uColor r
///   shader.setFloat(4, color.green / 255 * color.opacity); // uColor g
///   shader.setFloat(5, color.blue / 255 * color.opacity);  // uColor b
///   shader.setFloat(6, color.opacity);                     // uColor a
///
///   // initialize sampler uniform.
///   shader.setImageSampler(0, image);
/// }
/// ```
///
/// Note how the indexes used does not count the `sampler2D` uniform. This
/// uniform will be set separately with [setImageSampler], with the index starting
/// over at 0.
///
/// Any float uniforms that are left uninitialized will default to `0`. ÀÈ	ÀÈ  ÀÈ ÀÈ(   ÀÈ¨üÀÉø</// Sets the sampler uniform at [index] to [image].
///
/// The index provided to setImageSampler is the index of the sampler uniform defined
/// in the fragment program, excluding all non-sampler uniforms.
///
/// All the sampler uniforms that a shader expects must be provided or the
/// results will be undefined. ÀÊ	ÀÊ  ÀÊÀÊ   ÀÊ¨…ÀË×/// Releases the native resources held by the [FragmentShader].
///
/// After this method is called, calling methods on the shader, or attaching
/// it to a [Paint] object will fail with an exception. Calling [dispose]
/// twice will also result in an exception being thrown.  ÀËÆÀËÇÀÌ1€ÈÀÌ«  ÀÌ¸ÀÌÉ  ÀÌÑÀÌÖ  ÀÌäÀÌé  ÀÌ1ÀÌ2ÀÌ8ÀÌhÀÌ@ÀÌ9ÀÌHÀÌgÀÌIÀÌQÀÌYÀÌaÀÌiÀÌ’ÀÌpÀÌjÀÌrÀÌı€¥ÀÍv  ÀÍ‡	ÀÍŒ  ÀÍ’ÀÍš  ÀÌıÀÌşÀÍÀÍ1ÀÍ
ÀÍÀÍÀÍ0ÀÍÀÍÀÍÀÍÀÍ"ÀÍ*ÀÍ2ÀÍdÀÍ9ÀÍ3ÀÍ;ÀÍ¦~ÀÎ   ÀÍ¦ÀÍ§ÀÍ­ÀÍÊÀÍ³ÀÍ®ÀÍ»ÀÍÉÀÍ¼ÀÍÃÀÍÈÀÍÄÀÍËÀÍşÀÍÒÀÍÌÀÍÔÀÎ(lÀÎ‰   ÀÎ(ÀÎ)ÀÎ/ÀÎLÀÎ5ÀÎ0ÀÎ=ÀÎKÀÎ>ÀÎEÀÎJÀÎFÀÎMÀÎwÀÎTÀÎNÀÎV ÀÑ]¬ÀÙ×ˆn/// A set of vertex data used by [Canvas.drawVertices].
///
/// Vertex data consists of a series of points in the canvas coordinate space.
/// Based on the [VertexMode], these points are interpreted either as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single shared
/// point ([VertexMode.triangleFan]).
///
/// Each point can be associated with a color. Each triangle is painted as a
/// gradient that blends between the three colors at the three points of that
/// triangle. If no colors are specified, transparent black is assumed for all
/// the points.
///
/// These colors are then blended with the [Paint] specified in the call to
/// [Canvas.drawVertices]. This paint is either a solid color ([Paint.color]),
/// or a bitmap, specified using a shader ([Paint.shader]), typically either a
/// gradient ([Gradient]) or image ([ImageFilter]). The bitmap uses the same
/// coordinate space as the canvas (in the case of an [ImageFilter], this is
/// notably different than the coordinate space of the source image; the source
/// image is tiled according to the filter's configuration, and the image that
/// is sampled when painting the triangles is the infinite one after all the
/// repeating is applied.)
///
/// Each point in the [Vertices] is associated with a specific point on this
/// image. Each triangle is painted by sampling points from this image by
/// interpolating between the three points of the image corresponding to the
/// three points of the triangle.
///
/// The [Vertices.new] constructor configures all this using lists of [Offset]
/// and [Color] objects. The [Vertices.raw] constructor instead uses
/// [Float32List], [Int32List], and [Uint16List] objects, which more closely
/// corresponds to the data format used internally and therefore reduces some of
/// the conversion overhead. The raw constructor is useful if the data is coming
/// from another source (e.g. a file) and can therefore be parsed directly into
/// the underlying representation. ÀÚé ÀãÀãˆ¬/// Creates a set of vertex data for use with [Canvas.drawVertices].
///
/// The `mode` parameter describes how the points should be interpreted: as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single
/// shared point ([VertexMode.triangleFan]).
///
/// The `positions` parameter provides the points in the canvas space that
/// will be use to draw the triangles.
///
/// The `colors` parameter, if specified, provides the color for each point in
/// `positions`. Each triangle is painted as a gradient that blends between
/// the three colors at the three points of that triangle. (These colors are
/// then blended with the [Paint] specified in the call to
/// [Canvas.drawVertices].)
///
/// The `textureCoordinates` parameter, if specified, provides the points in
/// the [Paint] image to sample for the corresponding points in `positions`.
///
/// If the `colors` or `textureCoordinates` parameters are specified, they must
/// be the same length as `positions`.
///
/// The `indices` parameter specifies the order in which the points should be
/// painted. If it is omitted (or present but empty), the points are processed
/// in the order they are given in `positions`, as if the `indices` was a list
/// from 0 to n-1, where _n_ is the number of entries in `positions`. The
/// `indices` parameter, if present and non-empty, must have at least three
/// entries, but may be of any length beyond this. Indicies may refer to
/// offsets in the positions array multiple times, or may skip positions
/// entirely.
///
/// If the `indices` parameter is specified, all values in the list must be
/// valid index values for `positions`.
///
/// The `mode` and `positions` parameters must not be null.
///
/// This constructor converts its parameters into [dart:typed_data] lists
/// (e.g. using [Float32List]s for the coordinates) before sending them to the
/// Flutter engine. If the data provided to this constructor is not already in
/// [List] form, consider using the [Vertices.raw] constructor instead to
/// avoid converting the data twice.ÀãÀã   Àã)Àã7  ÀãGÀãU  Àã` Àão  Àã†Àã’   ÀèòWÀó{Àó|ÀóŠ(/// Creates a set of vertex data for use with [Canvas.drawVertices], using the
/// encoding expected by the Flutter engine.
///
/// The `mode` parameter describes how the points should be interpreted: as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single
/// shared point ([VertexMode.triangleFan]).
///
/// The `positions` parameter provides the points in the canvas space that
/// will be use to draw the triangles. Each point is represented as two
/// numbers in the list, the first giving the x coordinate and the second
/// giving the y coordinate. (As a result, the list must have an even number
/// of entries.)
///
/// The `colors` parameter, if specified, provides the color for each point in
/// `positions`. Each color is represented as ARGB with 8 bit color channels
/// (like [Color.value]'s internal representation), and the list, if
/// specified, must therefore be half the length of `positions`. Each triangle
/// is painted as a gradient that blends between the three colors at the three
/// points of that triangle. (These colors are then blended with the [Paint]
/// specified in the call to [Canvas.drawVertices].)
///
/// The `textureCoordinates` parameter, if specified, provides the points in
/// the [Paint] image to sample for the corresponding points in `positions`.
/// Each point is represented as two numbers in the list, the first giving the
/// x coordinate and the second giving the y coordinate. This list, if
/// specified, must be the same length as `positions`.
///
/// The `indices` parameter specifies the order in which the points should be
/// painted. If it is omitted (or present but empty), the points are processed
/// in the order they are given in `positions`, as if the `indices` was a list
/// from 0 to n-2, where _n_ is the number of pairs in `positions` (i.e. half
/// the length of `positions`). The `indices` parameter, if present and
/// non-empty, must have at least three entries, but may be of any length
/// beyond this. Indicies may refer to offsets in the positions array multiple
/// times, or may skip positions entirely.
///
/// If the `indices` parameter is specified, all values in the list must be
/// valid index values for pairs in `positions`. For example, if there are 12
/// numbers in `positions` (representing 6 coordinates), the `indicies` must
/// be numbers in the range 0..5 inclusive.
///
/// The `mode` and `positions` parameters must not be null.Àó…Àó‘  ÀóšÀó§  Àó·ÀóÃ  ÀóÎÀóÜ  ÀóóÀô    Àû©Àû® ÀûºÀûÃÀü€€«/// Whether this reference to the underlying vertex data is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   ÀøMÀøÄ  ÀøÊÀøÔ  ÀøıÀù  Àù$Àù1  ÀùXÀùf  Àù–Àù¢  ÀùÆÀùÓ  ÀøMÀøNÀøTÀø‘ÀøZÀøUÀøbÀøÀøcÀøkÀørÀøzÀø‚ÀøŠÀø’Àø«Àø™Àø“Àø›Àùß€ôÀúWn/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   Àú×€ÎÀûšk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  ÀûGÀûHÀûNÀûkÀûTÀûOÀû\ÀûjÀû]ÀûdÀûiÀûeÀûlÀûˆÀûsÀûmÀûu À«À –2À$ƒi/// An interface for recording graphical operations.
///
/// [Canvas] objects are used in creating [Picture] objects, which can
/// themselves be used with a [SceneBuilder] to build a [Scene]. In
/// normal usage, however, this is all handled by the framework.
///
/// A canvas has a current transformation matrix which is applied to all
/// operations. Initially, the transformation matrix is the identity transform.
/// It can be modified using the [translate], [scale], [rotate], [skew],
/// and [transform] methods.
///
/// A canvas also has a current clip region which is applied to all operations.
/// Initially, the clip region is infinite. It can be modified using the
/// [clipRect], [clipRRect], and [clipPath] methods.
///
/// The current transform and clip can be saved and restored using the stack
/// managed by the [save], [saveLayer], and [restore] methods. À/‚× ÀÁÀÇ‚q/// Creates a canvas for recording graphical operations into the
/// given picture recorder.
///
/// Graphical operations that affect pixels entirely outside the given
/// `cullRect` might be discarded by the implementation. However, the
/// implementation might draw outside these bounds if, for example, a command
/// draws partially inside and outside the `cullRect`. To ensure that pixels
/// outside a given region are discarded, consider using a [clipRect]. The
/// `cullRect` is optional; by default, all operations are kept.
///
/// To end the recording, call [PictureRecorder.endRecording] on the
/// given recorder.ÀÈÀÙ  ÀäÀë     %À	
(À
+/// Saves a copy of the current transform and clip on the save stack.
///
/// Call [restore] to pop the save stack.
///
/// See also:
///
///  * [saveLayer], which does the same thing but additionally also groups the
///    commands done until the matching [restore].   À
6”šÀ«“•/// Saves a copy of the current transform and clip on the save stack, and then
/// creates a new group which subsequent calls will become a part of. When the
/// save stack is later popped, the group will be flattened into a layer and
/// have the given `paint`'s [Paint.colorFilter] and [Paint.blendMode]
/// applied.
///
/// This lets you create composite effects, for example making a group of
/// drawing commands semi-transparent. Without using [saveLayer], each part of
/// the group would be painted individually, so where they overlap would be
/// darker than where they do not. By using [saveLayer] to group them
/// together, they can be drawn with an opaque color at first, and then the
/// entire group can be made transparent using the [saveLayer]'s paint.
///
/// Call [restore] to pop the save stack and apply the paint to the group.
///
/// ## Using saveLayer with clips
///
/// When a rectangular clip operation (from [clipRect]) is not axis-aligned
/// with the raster buffer, or when the clip operation is not rectilinear
/// (e.g. because it is a rounded rectangle clip created by [clipRRect] or an
/// arbitrarily complicated path clip created by [clipPath]), the edge of the
/// clip needs to be anti-aliased.
///
/// If two draw calls overlap at the edge of such a clipped region, without
/// using [saveLayer], the first drawing will be anti-aliased with the
/// background first, and then the second will be anti-aliased with the result
/// of blending the first drawing and the background. On the other hand, if
/// [saveLayer] is used immediately after establishing the clip, the second
/// drawing will cover the first in the layer, and thus the second alone will
/// be anti-aliased with the background when the layer is clipped and
/// composited (when [restore] is called).
///
/// For example, this [CustomPainter.paint] method paints a clean white
/// rounded rectangle:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.saveLayer(rect, Paint());
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.restore();
/// }
/// ```
///
/// On the other hand, this one renders a red outline, the result of the red
/// paint being anti-aliased with the background at the clip edge, then the
/// white paint being similarly anti-aliased with the background _including
/// the clipped red paint_:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   // (this example renders poorly, prefer the example above)
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// This point is moot if the clip only clips one draw operation. For example,
/// the following paint method paints a pair of clean white rounded
/// rectangles, even though the clips are not done on a separate layer:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(Offset.zero & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(size.center(Offset.zero) & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// (Incidentally, rather than using [clipRRect] and [drawPaint] to draw
/// rounded rectangles like this, prefer the [drawRRect] method. These
/// examples are using [drawPaint] as a proxy for "complicated draw operations
/// that will get clipped", to illustrate the point.)
///
/// ## Performance considerations
///
/// Generally speaking, [saveLayer] is relatively expensive.
///
/// There are a several different hardware architectures for GPUs (graphics
/// processing units, the hardware that handles graphics), but most of them
/// involve batching commands and reordering them for performance. When layers
/// are used, they cause the rendering pipeline to have to switch render
/// target (from one layer to another). Render target switches can flush the
/// GPU's command buffer, which typically means that optimizations that one
/// could get with larger batching are lost. Render target switches also
/// generate a lot of memory churn because the GPU needs to copy out the
/// current frame buffer contents from the part of memory that's optimized for
/// writing, and then needs to copy it back in once the previous render target
/// (layer) is restored.
///
/// See also:
///
///  * [save], which saves the current state, but does not create a new layer
///    for subsequent commands.
///  * [BlendMode], which discusses the use of [Paint.blendMode] with
///    [saveLayer]. ÀµÀ¼  ÀÃÀÊ   ÀÔFÀ (/// Pops the current save stack, if there is anything to pop.
/// Otherwise, does nothing.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If the state was pushed with [saveLayer], then this call will also
/// cause the new layer to be composited into the previous layer.   À ‚%À")ó/// Restores the save stack to a previous level as might be obtained from [getSaveCount].
/// If [count] is less than 1, the stack is restored to its initial state.
/// If [count] is greater than the current [getSaveCount] then nothing happens.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If any of the state stack levels restored by this call were pushed with
/// [saveLayer], then this call will also cause those layers to be composited
/// into their previous layers. À"8	À"=   À"GBÀ#z"/// Returns the number of items on the save stack, including the
/// initial state. This means it returns 1 for a clean canvas, and
/// that each call to [save] and [saveLayer] increments it, and that
/// each matching call to [restore] decrements it.
///
/// This number cannot go below 1.   À#€ÅÀ$2€›/// Add a translation to the current transform, shifting the coordinate space
/// horizontally by the first argument and vertically by the second argument. À$<	À$D  À$G	À$O   À$V,À%c€û/// Add an axis-aligned scale to the current transform, scaling by the first
/// argument in the horizontal direction and the second in the vertical
/// direction.
///
/// If [sy] is unspecified, [sx] will be used for the scale in both
/// directions. À%i	À%q  À%u
À%~   À%†qÀ%àR/// Add a rotation to the current transform. The argument is in radians clockwise. À%çÀ%ï   À%û5À'/// Add an axis-aligned skew to the current transform, with the first argument
/// being the horizontal skew in rise over run units clockwise around the
/// origin, and the second argument being the vertical skew in rise over run
/// units clockwise around the origin. À'	À'"  À'%	À'-   À'4€¯À'Ä€ˆ/// Multiply the current transform by the specified 4â¨‰4 transformation matrix
/// specified as a list of values in column-major order. À'ÎÀ'Û   À'ç‚À)Û×/// Returns the current transform including the combined result of all transform
/// methods executed since the creation of this [Canvas] object, and respecting the
/// save/restore history.
///
/// Methods that can change the current transform include [translate], [scale],
/// [rotate], [skew], and [transform]. The [restore] method can also modify
/// the current transform by restoring it to the same value it had before its
/// associated [save] or [saveLayer] call.   À)î‚À,+‚/// Reduces the clip region to the intersection of the current clip and the
/// given rectangle.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_rect.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that.
///
/// Use [ClipOp.difference] to subtract the provided rectangle from the
/// current clip. À,4	À,:  À,A À,I  À,cÀ,i  À,QÀ,WÀ,XÀ,vÀ,‚‚;À.‹ï/// Reduces the clip region to the intersection of the current clip and the
/// given rounded rectangle.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_rrect.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that and some examples of using [clipRRect]. À.•À.œ  À.£À.©  À.¶À.Á‚À0—¼/// Reduces the clip region to the intersection of the current clip and the
/// given [Path].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_path.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that. À0 	À0¦  À0¬À0²  À0¿À0ÊŠİÀ;’ŠZ/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the local coordinate space under which rendering operations are currently
/// performed.
///
/// The combined clip results are rounded out to an integer pixel boundary before
/// they are transformed back into the local coordinate space which accounts for
/// the pixel roundoff in rendering operations, particularly when antialiasing.
/// Because the [Picture] may eventually be rendered into a scene within the
/// context of transforming widgets or layers, the result may thus be overly
/// conservative due to premature rounding. Using the [getDestinationClipBounds]
/// method combined with the external transforms and rounding in the true device
/// coordinate system will produce more accurate results, but this value may
/// provide a more convenient approximation to compare rendering operations to
/// the established clip.
///
/// {@template dart.ui.canvas.conservativeClipBounds}
/// The conservative estimate of the bounds is based on intersecting the bounds
/// of each clip method that was executed with [ClipOp.intersect] and potentially
/// ignoring any clip method that was executed with [ClipOp.difference]. The
/// [ClipOp] argument is only present on the [clipRect] method.
///
/// To understand how the bounds estimate can be conservative, consider the
/// following two clip method calls:
///
/// ```dart
/// void draw(Canvas canvas) {
///   canvas.clipPath(Path()
///     ..addRect(const Rect.fromLTRB(10, 10, 20, 20))
///     ..addRect(const Rect.fromLTRB(80, 80, 100, 100)));
///   canvas.clipPath(Path()
///     ..addRect(const Rect.fromLTRB(80, 10, 100, 20))
///     ..addRect(const Rect.fromLTRB(10, 80, 20, 100)));
///   // ...
/// }
/// ```
///
/// After executing both of those calls there is no area left in which to draw
/// because the two paths have no overlapping regions. But, in this case,
/// [getLocalClipBounds] would return a rectangle from `10, 10` to `100, 100` because it
/// only intersects the bounds of the two path objects to obtain its conservative
/// estimate.
///
/// The clip bounds are not affected by the bounds of any enclosing
/// [saveLayer] call as the engine does not currently guarantee the strict
/// enforcement of those bounds during rendering.
///
/// Methods that can change the current clip include [clipRect], [clipRRect],
/// and [clipPath]. The [restore] method can also modify the current clip by
/// restoring it to the same value it had before its associated [save] or
/// [saveLayer] call.
/// {@endtemplate}   À;«ƒŸÀ?/ƒb/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the destination coordinate space in which the [Picture] will be rendered.
///
/// Unlike [getLocalClipBounds], the bounds are not rounded out to an integer
/// pixel boundary as the Destination coordinate space may not represent pixels
/// if the [Picture] being constructed will be further transformed when it is
/// rendered or added to a scene. In order to determine the true pixels being
/// affected, those external transforms should be applied first before rounding
/// out the result to integer pixel boundaries. Most typically, [Picture] objects
/// are rendered in a scene with a scale transform representing the Device Pixel
/// Ratio.
///
/// {@macro dart.ui.canvas.conservativeClipBounds}   À?N€İÀ?ÿ€¥/// Paints the given [Color] onto the canvas, applying the given
/// [BlendMode], with the given color being the source and the background
/// being the destination. À@	À@  À@À@!   À@/üÀAÿ¼/// Draws a line between the given points using the given paint. The line is
/// stroked, the value of the [Paint.style] is ignored for this call.
///
/// The `p1` and `p2` arguments are interpreted as offsets from the origin.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_line.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_line_dark.png#gh-dark-mode-only) ÀB	ÀB  ÀB	ÀB  ÀBÀB%   ÀB/€±ÀBÉ€Œ/// Fills the canvas with the given [Paint].
///
/// To fill the canvas with a solid color and blend mode, consider
/// [drawColor] instead. ÀBÓÀBÚ   ÀBä‘ÀDT`/// Draws a rectangle with the given [Paint]. Whether the rectangle is filled
/// or stroked (or both) is controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rect.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rect_dark.png#gh-dark-mode-only) ÀD]	ÀDc  ÀDhÀDo   ÀDyÀEój/// Draws a rounded rectangle with the given [Paint]. Whether the rectangle is
/// filled or stroked (or both) is controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rrect.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rrect_dark.png#gh-dark-mode-only) ÀEıÀF  ÀF
ÀF   ÀFHÀG1/// Draws a shape consisting of the difference between two rounded rectangles
/// with the given [Paint]. Whether this shape is filled or stroked (or both)
/// is controlled by [Paint.style].
///
/// This shape is almost but not quite entirely unlike an annulus. ÀG<ÀGC  ÀGIÀGP  ÀGVÀG]   ÀGgÇÀI”/// Draws an axis-aligned oval that fills the given axis-aligned rectangle
/// with the given [Paint]. Whether the oval is filled or stroked (or both) is
/// controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_oval.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_oval_dark.png#gh-dark-mode-only) ÀI	ÀI  ÀI!ÀI(   ÀI2‚)ÀK*ä/// Draws a circle centered at the point given by the first argument and
/// that has the radius given by the second argument, with the [Paint] given in
/// the third argument. Whether the circle is filled or stroked (or both) is
/// controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_circle.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_circle_dark.png#gh-dark-mode-only) ÀK5ÀK=  ÀK?ÀKG  ÀKNÀKU   ÀK_ƒÛÀNäƒc/// Draw an arc scaled to fit inside the given rectangle.
///
/// It starts from `startAngle` radians around the oval up to
/// `startAngle` + `sweepAngle` radians around the oval, with zero radians
/// being the point on the right hand side of the oval that crosses the
/// horizontal line that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval. If `useCenter` is true, the arc is
/// closed back to the center, forming a circle sector. Otherwise, the arc is
/// not closed, forming a circle segment.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_draw_arc.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_draw_arc_dark.png#gh-dark-mode-only)
///
/// This method is optimized for drawing arcs and should be faster than [Path.arcTo]. ÀNì	ÀNò  ÀN÷ÀNÿ  ÀO
ÀO  ÀOÀO#  ÀO-ÀO4   ÀO>ÀP<€î/// Draws the given [Path] with the given [Paint].
///
/// Whether this shape is filled or stroked (or both) is controlled by
/// [Paint.style]. If the path is filled, then sub-paths within it are
/// implicitly closed (see [Path.close]). ÀPE	ÀPK  ÀPPÀPW   ÀPa€İÀQ€ /// Draws the given [Image] into the canvas with its top-left corner at the
/// given [Offset]. The image is composited into the canvas using the given [Paint]. ÀQÀQ  ÀQ"ÀQ*  ÀQ1ÀQ8   ÀQBøÀRş¤/// Draws the subset of the given image described by the `src` argument into
/// the canvas in the axis-aligned rectangle given by the `dst` argument.
///
/// This might sample from outside the `src` rect by up to half the width of
/// an applied filter.
///
/// Multiple calls to this method with different arguments (from the same
/// image) can be batched into a single call to [drawAtlas] to improve
/// performance. ÀSÀS  ÀSÀS  ÀS#ÀS)  ÀS-ÀS4   ÀS>ƒQÀVP‚ò/// Draws the given [Image] into the canvas using the given [Paint].
///
/// The image is drawn in nine portions described by splitting the image by
/// drawing two horizontal lines and two vertical lines, where the `center`
/// argument describes the rectangle formed by the four points where these
/// four lines intersect each other. (This forms a 3-by-3 grid of regions,
/// the center region being described by the `center` argument.)
///
/// The four regions in the corners are drawn, without scaling, in the four
/// corners of the destination rectangle described by `dst`. The remaining
/// five regions are drawn by stretching them to fit such that they exactly
/// cover the destination rectangle while maintaining their relative
/// positions. ÀV^ÀVe  ÀVkÀVq  ÀVxÀV~  ÀV‚ÀV‰   ÀV“€‚ÀVø[/// Draw the given picture onto the canvas. To create a picture, see
/// [PictureRecorder]. ÀWÀW   ÀW„IÀ[0ƒé/// Draws the text in the given [Paragraph] into this canvas at the given
/// [Offset].
///
/// The [Paragraph] object must have had [Paragraph.layout] called on it
/// first.
///
/// To align the text, set the `textAlign` on the [ParagraphStyle] object
/// passed to the [ParagraphBuilder.new] constructor. For more details see
/// [TextAlign] and the discussion at [ParagraphStyle.new].
///
/// If the text is left aligned or justified, the left margin will be at the
/// position specified by the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is right aligned or justified, the right margin will be at the
/// position described by adding the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is centered, the centering axis will be at the position
/// described by adding half of the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate. À[>À[I  À[SÀ[[   À[fôÀ]–/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as offsets from the origin.
///
/// The `paint` is used for each point ([PointMode.points]) or line
/// ([PointMode.lines] or [PointMode.polygon]), ignoring [Paint.style].
///
/// See also:
///
///  * [drawRawPoints], which takes `points` as a [Float32List] rather than a
///    [List<Offset>]. À]#À].  À]8À]F  À]MÀ]T   À]^‚OÀ_ií/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as a list of pairs of floating point
/// numbers, where each pair represents an x and y offset from the origin.
///
/// The `paint` is used for each point ([PointMode.points]) or line
/// ([PointMode.lines] or [PointMode.polygon]), ignoring [Paint.style].
///
/// See also:
///
///  * [drawPoints], which takes `points` as a [List<Offset>] rather than a
///    [List<Float32List>]. À_wÀ_‚  À_ŒÀ_™  À_ À_§   À_±†;Àeª…»/// Draws a set of [Vertices] onto the canvas as one or more triangles.
///
/// The [Paint.color] property specifies the default color to use for the
/// triangles.
///
/// The [Paint.shader] property, if set, overrides the color entirely,
/// replacing it with the colors from the specified [ImageShader], [Gradient],
/// or other shader.
///
/// The `blendMode` parameter is used to control how the colors in the
/// `vertices` are combined with the colors in the `paint`. If there are no
/// colors specified in `vertices` then the `blendMode` has no effect. If
/// there are colors in the `vertices`, then the color taken from the
/// [Paint.shader] or [Paint.color] in the `paint` is blended with the colors
/// specified in the `vertices` using the `blendMode` parameter. For the
/// purposes of this blending, the colors from the `paint` parameter are
/// considered the source, and the colors from the `vertices` are considered
/// the destination. [BlendMode.dst] ignores the `paint` and uses only the
/// colors of the `vertices`; [BlendMode.src] ignores the colors of the
/// `vertices` and uses only the colors in the `paint`.
///
/// All parameters must not be null.
///
/// See also:
///   * [Vertices.new], which creates a set of vertices to draw on the canvas.
///   * [Vertices.raw], which creates the vertices using typed data lists
///     rather than unencoded lists.
///   * [paint], Image shaders can be used to draw images on a triangular mesh. Àe·ÀeÁ  ÀeÊÀeÕ  ÀeßÀeæ   Àeğ–•À{””/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color.
///
/// The method takes a list of [Rect] objects that each define a piece of the
/// [atlas] image to be drawn independently. Each [Rect] is associated with an
/// [RSTransform] entry in the [transforms] list which defines the location,
/// rotation, and (uniform) scale with which to draw that portion of the image.
/// Each [Rect] can also be associated with an optional [Color] which will be
/// composed with the associated image part using the [blendMode] before blending
/// the result onto the canvas. The full operation can be broken down as:
///
/// - Blend each rectangular portion of the image specified by an entry in the
/// [rects] argument with its associated entry in the [colors] list using the
/// [blendMode] argument (if a color is specified). In this part of the operation,
/// the image part will be considered the source of the operation and the associated
/// color will be considered the destination.
/// - Blend the result from the first step onto the canvas using the translation,
/// rotation, and scale properties expressed in the associated entry in the
/// [transforms] list using the properties of the [Paint] object.
///
/// If the first stage of the operation which blends each part of the image with
/// a color is needed, then both the [colors] and [blendMode] arguments must
/// not be null and there must be an entry in the [colors] list for each
/// image part. If that stage is not needed, then the [colors] argument can
/// be either null or an empty list and the [blendMode] argument may also be null.
///
/// The optional [cullRect] argument can provide an estimate of the bounds of the
/// coordinates rendered by all components of the atlas to be compared against
/// the clip to quickly reject the operation if it does not intersect.
///
/// An example usage to render many sprites from a single sprite atlas with no
/// rotations or scales:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center);
///   int index;
///   Offset center;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (final Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: 0.0,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.center.dx,
///           translateY: sprite.center.dy,
///         ),
///     ], <Rect>[
///       for (final Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], null, null, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center, this.alpha, this.rotation);
///   int index;
///   Offset center;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (final Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: sprite.rotation,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.center.dx,
///           translateY: sprite.center.dy,
///         ),
///     ], <Rect>[
///       for (final Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], <Color>[
///       for (final Sprite sprite in allSprites)
///         Colors.white.withAlpha(sprite.alpha),
///     ], BlendMode.srcIn, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// The length of the [transforms] and [rects] lists must be equal and
/// if the [colors] argument is not null then it must either be empty or
/// have the same length as the other two lists.
///
/// See also:
///
///  * [drawRawAtlas], which takes its arguments as typed data lists rather
///    than objects. À{šÀ{¡  À{¸À{Ë  À{çÀ{ó  À|
À|  À|0À|<  À|WÀ|^  À|xÀ|   À|‰›À–™˜ä/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color. It is also more efficient
/// than [drawAtlas] as the data in the arguments is already packed in a format
/// that can be directly used by the rendering code.
///
/// A full description of how this method uses its arguments to draw onto the
/// canvas can be found in the description of the [drawAtlas] method.
///
/// The [rstTransforms] argument is interpreted as a list of four-tuples, with
/// each tuple being ([RSTransform.scos], [RSTransform.ssin],
/// [RSTransform.tx], [RSTransform.ty]).
///
/// The [rects] argument is interpreted as a list of four-tuples, with each
/// tuple being ([Rect.left], [Rect.top], [Rect.right], [Rect.bottom]).
///
/// The [colors] argument, which can be null, is interpreted as a list of
/// 32-bit colors, with the same packing as [Color.value]. If the [colors]
/// argument is not null then the [blendMode] argument must also not be null.
///
/// An example usage to render many sprites from a single sprite atlas with no rotations
/// or scales:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center);
///   int index;
///   Offset center;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     for (int i = 0; i < allSprites.length; i++) {
///       Sprite sprite = allSprites[i];
///       final double rectX = sprite.index * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example sets the RSTransform values directly for a common case of no
///       // rotations or scales and just a translation to position the atlas entry. For
///       // more complicated transforms one could use the RSTransform class to compute
///       // the necessary values or do the same math directly.
///       transformList[i * 4 + 0] = 1.0;
///       transformList[i * 4 + 1] = 0.0;
///       transformList[i * 4 + 2] = sprite.center.dx - 5.0;
///       transformList[i * 4 + 3] = sprite.center.dy - 5.0;
///     }
///     Paint paint = Paint();
///     canvas.drawRawAtlas(spriteAtlas, transformList, rectList, null, null, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center, this.alpha, this.rotation);
///   int index;
///   Offset center;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     Int32List colorList = Int32List(allSprites.length);
///     for (int i = 0; i < allSprites.length; i++) {
///       Sprite sprite = allSprites[i];
///       final double rectX = sprite.index * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example uses an RSTransform object to compute the necessary values for
///       // the transform using a factory helper method because the sprites contain
///       // rotation values which are not trivial to work with. But if the math for the
///       // values falls out from other calculations on the sprites then the values could
///       // possibly be generated directly from the sprite update code.
///       final RSTransform transform = RSTransform.fromComponents(
///         rotation: sprite.rotation,
///         scale: 1.0,
///         // Center of the sprite relative to its rect
///         anchorX: 5.0,
///         anchorY: 5.0,
///         // Location at which to draw the center of the sprite
///         translateX: sprite.center.dx,
///         translateY: sprite.center.dy,
///       );
///       transformList[i * 4 + 0] = transform.scos;
///       transformList[i * 4 + 1] = transform.ssin;
///       transformList[i * 4 + 2] = transform.tx;
///       transformList[i * 4 + 3] = transform.ty;
///
///       // This example computes the color value directly, but one could also compute
///       // an actual Color object and use its Color.value getter for the same result.
///       // Since we are using BlendMode.srcIn, only the alpha component matters for
///       // these colors which makes this a simple shift operation.
///       colorList[i] = sprite.alpha << 24;
///     }
///     Paint paint = Paint();
///     canvas.drawRawAtlas(spriteAtlas, transformList, rectList, colorList, BlendMode.srcIn, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// See also:
///
///  * [drawAtlas], which takes its arguments as objects rather than typed
///    data lists. À–¦À–­  À–ÇÀ–Ô  À–öÀ—  À—À—)  À—DÀ—P  À—nÀ—u  À—’À—™   À—£8À˜Œ€×/// Draws a shadow for a [Path] representing the given material elevation.
///
/// The `transparentOccluder` argument should be true if the occluding object
/// is not opaque.
///
/// The arguments must not be null. À˜—	À˜  À˜¢À˜©  À˜¯À˜·  À˜ÁÀ˜Ç    À˜ßÀ K­À˜ê  À™/“ À™/À™< À™=À™N  À™YÀ™`   Àœ£!Àœ»   CÀšÆ€ÜÀ›>  À›KÀ›c  À›lÀ›t  À›y
À›  À›…À›  À›“À››  ÀšÆÀšÇÀšÍÀ›ÀšÓÀšÎÀšÛÀ›ÀšÜÀšäÀšëÀšğÀšìÀšóÀšûÀ›À›À›À›,À›À›À›ÀœÉoÀ1   ÀœÉÀœÊÀœÕÀœÖÀœÜÀœùÀœâÀœİÀœêÀœøÀœëÀœòÀœ÷ÀœóÀœúÀÀÀœûÀÀÀÀÀ<ÀH  ÀP	ÀV   À\-Àm  ÀwÀ~  À…ÀŒ  À\À]ÀŸ€¹ÀŸı  À À %  À 2À <  ÀŸÀŸÀŸ”ÀŸÁÀŸšÀŸ•ÀŸ¢ÀŸÀÀŸ£ÀŸªÀŸ¯ÀŸ«ÀŸ²ÀŸºÀŸÂÀŸëÀŸÉÀŸÃÀŸËÀ J€õÀ Í  À ØÀ à  À å
À í  À ñÀ ù  À ÿÀ¡  À¡À¡  À¡+À¡5  À JÀ KÀ QÀ À WÀ RÀ _À À `À gÀ lÀ hÀ oÀ wÀ À ‡À À —À ŸÀ »À ¦À  À ¨À¡CuÀ¡®   À¡CÀ¡DÀ¡OÀ¡PÀ¡VÀ¡sÀ¡\À¡WÀ¡dÀ¡rÀ¡eÀ¡lÀ¡qÀ¡mÀ¡tÀ¡œÀ¡{À¡uÀ¡}À¡–À¡À¡˜À¡¼€“À¢5  À¢D	À¢I  À¡¼À¡½À¡ÈÀ¡ÉÀ¡ÏÀ¡óÀ¡ÕÀ¡ĞÀ¡İÀ¡òÀ¡ŞÀ¡åÀ¡êÀ¡æÀ¡íÀ¡ôÀ¢#À¡ûÀ¡õÀ¡ıÀ¢À¢À¢À¢SÀ¢Ã   À¢SÀ¢TÀ¢_À¢`À¢fÀ¢„À¢mÀ¢gÀ¢uÀ¢ƒÀ¢vÀ¢}À¢‚À¢~À¢…À¢²À¢ŒÀ¢†À¢À¢¬À¢¦À¢®À¢Ö€À£S  À£]	À£e  À£h	À£p  À¢ÖÀ¢×À¢âÀ¢ãÀ¢éÀ£À¢ïÀ¢êÀ¢÷À£À¢øÀ¢ÿÀ£À£ À£À£À£À£AÀ£À£À£ À£;À£5À£=À£wHÀ£ˆ  À£	À£–  À£š
À££  À£wÀ£xÀ£Ã€ŠÀ¤0  À¤7	À¤?  À¤B	À¤J  À£ÃÀ£ÄÀ£ÊÀ£÷À£ĞÀ£ËÀ£ØÀ£öÀ£ÙÀ£àÀ£åÀ£áÀ£èÀ£ğÀ£øÀ¤À£ÿÀ£ùÀ¤À¤À¤À¤À¤Q€‰À¤Ã  À¤ÊÀ¤Ò  À¤QÀ¤RÀ¤]À¤^À¤dÀ¤‰À¤jÀ¤eÀ¤rÀ¤ˆÀ¤sÀ¤zÀ¤À¤{À¤‚À¤ŠÀ¤±À¤‘À¤‹À¤“À¤«À¤¥À¤­À¤Ş€“À¥V  À¥[	À¥c  À¥f	À¥n  À¤ŞÀ¤ßÀ¤êÀ¤ëÀ¤ñÀ¥À¤÷À¤òÀ¤ÿÀ¥À¥ À¥À¥À¥À¥À¥À¥À¥DÀ¥&À¥ À¥(À¥>À¥8À¥@À¥u€²À¥†  À¥À¥  À¥uÀ¥vÀ¦+{À¦†  À¦‘À¦  À¦+À¦,À¦2À¦WÀ¦8À¦3À¦@À¦VÀ¦AÀ¦HÀ¦MÀ¦IÀ¦PÀ¦XÀ¦tÀ¦_À¦YÀ¦aÀ¦ª€À¦Â   À¦ªÀ¦«À§;€À§™  À§§À§´  À§;À§<À§BÀ§gÀ§HÀ§CÀ§PÀ§fÀ§QÀ§XÀ§]À§YÀ§`À§hÀ§‡À§oÀ§iÀ§qÀ§ÀØÀ§Ñ  À§Ú	À§à  À§ç À§ï  À¨	À¨  À§ÀÀ§ÁÀ§÷À§ıÀ§şÀ¨À©œ€ëÀª)  Àª3Àª;  Àª@
ÀªH  ÀªLÀªT  ÀªZÀªb  Àªi
Àªn  ÀªuÀª{  À©œÀ©À©£À©íÀ©©À©¤À©±À©ìÀ©²À©¹À©¾À©ºÀ©ÁÀ©ÉÀ©ÑÀ©ÙÀ©áÀ©èÀ©îÀªÀ©õÀ©ïÀ©÷ÀªÀªÀªÀª‹€œÀªœ  Àª¦Àª­  Àª´Àªº  Àª‹ÀªŒÀªÇÀ«+€‘À«Œ  À«—À«¤  À«ªÀ«°  À«+À«,À«2À«]À«8À«3À«@À«\À«AÀ«HÀ«MÀ«IÀ«PÀ«XÀ«^À«zÀ«eÀ«_À«gÀ«ÀvÀ«Ñ  À«Ú	À«à  À«æÀ«ì  À«ÀÀ«ÁÀ«ùÀ¬:€•À¬¡  À¬«À¬¸  À¬½À¬Ã  À¬:À¬;À¬AÀ¬sÀ¬GÀ¬BÀ¬OÀ¬rÀ¬PÀ¬WÀ¬\À¬XÀ¬_À¬fÀ¬kÀ¬gÀ¬nÀ¬tÀ¬À¬{À¬uÀ¬}À¬Ó€ÁÀ¬ä   À¬ÓÀ¬ÔÀ­˜€ŒÀ­ü  À®À®  À­˜À­™À­ŸÀ­ÄÀ­¥À­ À­­À­ÃÀ­®À­µÀ­ºÀ­¶À­½À­ÅÀ­êÀ­ÌÀ­ÆÀ­ÎÀ®(€ÍÀ®9   À®(À®)À®ù€˜À¯c  À¯}À¯Š  À®ùÀ®úÀ¯ À¯%À¯À¯À¯À¯$À¯À¯À¯À¯À¯À¯&À¯QÀ¯-À¯'À¯/À¯•pÀ¯¦  À¯°À¯·  À¯½À¯È  À¯•À¯–À°	€•À°y  À°„	À°‰  À°À°”  À°	À°
À°À°<À°À°À°À°;À°À°&À°+À°'À°.À°6À°=À°gÀ°DÀ°>À°FÀ°aÀ°[À°cÀ°¢€ÊÀ°³  À°¼	À°Ä  À°Ç	À°Ï  À°ÒÀ°Ù  À°¢À°£À±p€éÀ±ò  À±ü	À²  À²	À²  À²	À²  À²	À²%  À²(À²8  À²EÀ²O  À±pÀ±qÀ±wÀ±ÄÀ±}À±xÀ±…À±ÃÀ±†À±À±’À±À±•À±À±¥À±­À±µÀ±½À±ÅÀ±àÀ±ÌÀ±ÆÀ±ÎÀ²]ZÀ²n  À²xÀ²  À²]À²^À²»€ŸÀ³  À³)À³9  À³FÀ³P  À²»À²¼À²ÂÀ²ïÀ²ÈÀ²ÃÀ²ĞÀ²îÀ²ÑÀ²ØÀ²İÀ²ÙÀ²àÀ²èÀ²ğÀ³À²÷À²ñÀ²ùÀ³^À³o  À³x	À³~  À³ƒÀ³Š  À³^À³_À´s€óÀ´õ  À´ÿÀµ  Àµ
Àµ  ÀµÀµ   Àµ&Àµ.  Àµ5ÀµE  ÀµRÀµ\  À´sÀ´tÀ´zÀ´ÇÀ´€À´{À´ˆÀ´ÆÀ´‰À´À´•À´‘À´˜À´ À´¨À´°À´¸À´ÀÀ´ÈÀ´ãÀ´ÏÀ´ÉÀ´ÑÀµj€Àµ{  Àµ…ÀµŒ  Àµ’Àµ™  ÀµjÀµkÀ¶€ºÀ¶w  À¶‚À¶  À¶•À¶¥  À¶²À¶¼  À¶À¶À¶À¶HÀ¶À¶À¶!À¶GÀ¶"À¶)À¶.À¶*À¶1À¶9À¶AÀ¶IÀ¶eÀ¶PÀ¶JÀ¶RÀ¶Ê€äÀ¶Û  À¶æÀ¶í  À¶óÀ¶ú  À· À·  À¶ÊÀ¶ËÀ·²€×À¸&  À¸2À¸?  À¸EÀ¸R  À¸XÀ¸h  À¸uÀ¸  À·²À·³À·¹À·öÀ·¿À·ºÀ·ÇÀ·õÀ·ÈÀ·ÏÀ·ÔÀ·ĞÀ·×À·ßÀ·çÀ·ïÀ·÷À¸À·şÀ·øÀ¸ À¸À¸  À¸§	À¸­  À¸²À¸¹  À¸À¸À¹¢€óÀº$  Àº.Àº6  Àº;
ÀºC  ÀºGÀºO  ÀºUÀº]  ÀºdÀºt  ÀºÀº‹  À¹¢À¹£À¹©À¹öÀ¹¯À¹ªÀ¹·À¹õÀ¹¸À¹¿À¹ÄÀ¹ÀÀ¹ÇÀ¹ÏÀ¹×À¹ßÀ¹çÀ¹ïÀ¹÷ÀºÀ¹şÀ¹øÀº Àº™€¨Àºª  ÀºµÀº½  Àº¿ÀºÇ  ÀºÎÀºÕ  Àº™ÀºšÀ»E€ÜÀ»Á  À»ÍÀ»Õ  À»×À»ß  À»áÀ»é  À»ğÀ¼   À¼À¼  À»EÀ»FÀ»LÀ»‘À»RÀ»MÀ»ZÀ»À»[À»bÀ»gÀ»cÀ»jÀ»rÀ»zÀ»‚À»ŠÀ»’À»¯À»™À»“À»›À¼%À¼6  À¼>	À¼D  À¼IÀ¼Q  À¼\À¼d  À¼oÀ¼u  À¼À¼†  À¼%À¼&À½1tÀ½È  	À½ØÀ½à  À½ë
À½ó  À½ıÀ¾  À¾À¾  À¾&À¾.  À¾?À¾G  À¾XÀ¾^  À¾nÀ¾~  À¾‘À¾›  À½1À½2À½8À½›À½>À½9À½FÀ½šÀ½GÀ½NÀ½SÀ½OÀ½VÀ½^À½fÀ½nÀ½vÀ½~À½†À½ŒÀ½”À½œÀ½¶À½£À½À½¥À¾©xÀ¾º  À¾Ã	À¾É  À¾ÎÀ¾Õ  À¾©À¾ªÀ¿%€¾À¿–  À¿ À¿­  À¿²À¿Â  À¿ÏÀ¿Ù  À¿%À¿&À¿,À¿hÀ¿2À¿-À¿:À¿gÀ¿;À¿BÀ¿GÀ¿CÀ¿JÀ¿QÀ¿VÀ¿RÀ¿YÀ¿aÀ¿iÀ¿„À¿pÀ¿jÀ¿rÀ¿ç~À¿ø  ÀÀÀÀ	  ÀÀÀÀ  ÀÀÀÀ%  À¿çÀ¿èÀÁiÀÁ÷  ÀÂÀÂ
  ÀÂÀÂ  ÀÂÀÂ"  ÀÂ$ÀÂ4  ÀÂAÀÂK  ÀÂUÀÂZ  ÀÁiÀÁjÀÁpÀÁÅÀÁxÀÁqÀÁ€ÀÁÄÀÁÀÁˆÀÁÀÁ‰ÀÁÀÁ—ÀÁœÀÁ˜ÀÁŸÀÁ§ÀÁ¯ÀÁ·ÀÁ¿ÀÁÆÀÁâÀÁÍÀÁÇÀÁÏÀÂqƒ¦ÀÂ‚  ÀÂÀÂ—  ÀÂÀÂ£  ÀÂ§ÀÂ­  ÀÂ±ÀÂ¸  ÀÂqÀÂrÀÆõÀÆİ  ÀÆóÀÆû  ÀÇÀÇ  ÀÇÀÇ%  ÀÇ2ÀÇ:  ÀÇIÀÇQ  ÀÇaÀÇi  ÀÇwÀÇ  ÀÇŒÀÇ”  ÀÇ£ÀÇ«  ÀÇ»ÀÇË  ÀÇŞÀÇè  ÀÇøÀÇı   ÀÆÀÆÀÆ"ÀÆ§ÀÆ*ÀÆ#ÀÆ2ÀÆ¦ÀÆ3ÀÆ:ÀÆ?ÀÆ;ÀÆBÀÆIÀÆNÀÆJÀÆQÀÆYÀÆaÀÆiÀÆqÀÆyÀÆÀÆ‰ÀÆ‘ÀÆ™ÀÆ¡ÀÆ¨ÀÆÈÀÆ¯ÀÆ©ÀÆ±ÀÈƒ¸ÀÈ%  ÀÈ3ÀÈ:  ÀÈ@ÀÈF  ÀÈMÀÈS  ÀÈWÀÈ^  ÀÈÀÈÀËĞ‚ÀÌ’  ÀÌ¨ÀÌ°  ÀÌ¼ÀÌÄ  ÀÌÕÀÌİ  ÀÌíÀÌõ  ÀÍÀÍ  ÀÍ"ÀÍ*  ÀÍ8ÀÍ@  ÀÍMÀÍU  ÀÍdÀÍl  ÀÍ|ÀÍŒ  ÀÍŸÀÍ©  ÀÍ¹ÀÍ¾   ÀËĞÀËÑÀË×ÀÌ\ÀËßÀËØÀËçÀÌ[ÀËèÀËïÀËôÀËğÀË÷ÀËşÀÌÀËÿÀÌÀÌÀÌÀÌÀÌ&ÀÌ.ÀÌ6ÀÌ>ÀÌFÀÌNÀÌVÀÌ]ÀÌ}ÀÌdÀÌ^ÀÌfÀÍÕ€„ÀÍæ  ÀÍòÀÍû  ÀÍÕÀÍÖÀÎ]€‰ÀÎÁ  ÀÎÎÀÎŞ  ÀÎ]ÀÎ^ÀÎdÀÎÀÎjÀÎeÀÎrÀÎÀÎsÀÎzÀÎÀÎ{ÀÎ‚ÀÎ‰ÀÎÀÎŠÀÎ‘ÀÎ¯ÀÎ˜ÀÎ’ÀÎšÀÎêGÀÎû  ÀÏ	ÀÏ  ÀÏÀÏ&  ÀÎêÀÎëÀĞ5€±ÀĞF  ÀĞQÀĞ\  ÀĞfÀĞt  ÀĞ{ÀĞ‚  ÀĞ5ÀĞ6ÀĞêÀĞû  ÀÑ	ÀÑ  ÀÑÀÑ+  ÀÑ2ÀÑ9  ÀĞêÀĞëÀÒ€ÓÀÒu  ÀÒÀÒ‘  ÀÒÀÒ¨  ÀÒ²ÀÒ·  ÀÒÁÀÒÎ  ÀÒÀÒÀÒ	ÀÒEÀÒÀÒ
ÀÒÀÒDÀÒÀÒÀÒ$ÀÒ ÀÒ'ÀÒ/ÀÒ7ÀÒ>ÀÒFÀÒcÀÒMÀÒGÀÒOÀÒÙ€ÈÀÒê  ÀÒ÷ÀÓ  ÀÓ
ÀÓ  ÀÓÀÓ&  ÀÒÙÀÒÚÀÓ¥€İÀÔ!  ÀÔ/ÀÔ9  ÀÔBÀÔG  ÀÔQÀÔa  ÀÔnÀÔx  ÀÓ¥ÀÓ¦ÀÓ¬ÀÓïÀÓ²ÀÓ­ÀÓºÀÓîÀÓ»ÀÓÂÀÓÇÀÓÃÀÓÊÀÓÑÀÓÖÀÓÒÀÓÙÀÓàÀÓèÀÓğÀÔÀÓ÷ÀÓñÀÓùÀÔ†ˆ"ÀÔ—  ÀÔ¡ÀÔ¨  ÀÔ¿ÀÔÒ  ÀÔîÀÔú  ÀÕÀÕ  ÀÕ7ÀÕC  ÀÕ^ÀÕe  ÀÕÀÕ†  ÀÔ†ÀÔ‡ÀÜ¬„§ÀÜ½  ÀÜÊÀÜÑ  ÀÜëÀÜø  ÀİÀİ'  ÀİAÀİM  ÀİhÀİt  Àİ’Àİ™  Àİ¶Àİ½  ÀÜ¬ÀÜ­ÀáW¥Àáü  	ÀâÀâ  Àâ1Àâ;  ÀâKÀâP  ÀâiÀâq  Àâ}ÀâŠ  ÀâÀâ«  Àâ·ÀâÃ  ÀâĞÀâÕ  ÀâåÀâó  ÀáWÀáXÀá^ÀáÊÀáfÀá_ÀánÀáÉÀáoÀávÀá{ÀáwÀá~Àá†ÀáÀá•ÀáœÀá¡ÀáÀá¤Àá¬Àá´Àá¼ÀáÃÀáËÀáçÀáÒÀáÌÀáÔÀã €¸Àã  Àã	Àã"  Àã'Àã.  Àã4Àã<  ÀãFÀãL  Àã ÀãÀã¼€ÎÀä5  ÀäAÀäN  ÀäS	ÀäX  Àä^Àäf  ÀäpÀäv  Àã¼Àã½ÀãÃÀäÀãÉÀãÄÀãÑÀäÀãÒÀãÙÀãŞÀãÚÀãáÀãèÀãíÀãéÀãğÀãøÀä ÀäÀä#ÀäÀäÀä ÀäüŠ¸ÀæZN/// An object representing a sequence of recorded graphical operations.
///
/// To create a [Picture], use a [PictureRecorder].
///
/// A [Picture] can be placed in a [Scene] using a [SceneBuilder], via
/// the [SceneBuilder.addPicture] method. A [Picture] can also be
/// drawn into a [Canvas], using the [Canvas.drawPicture] method.  ÀæfÀçv€è/// A callback that is invoked to report a picture creation.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onCreate] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀçƒÀè–€ë/// A callback that is invoked to report the picture disposal.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onDispose] directly because [MemoryAllocations]
/// allows multiple callbacks. Àíø€ÇÀî±€§/// Whether this reference to the underlying picture is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   ÀîÃ€ïÀï€É/// Returns the approximate number of bytes allocated for this object.
///
/// The actual size of this picture may be larger, particularly if it contains
/// references to image or other large objects.   Àè¤DÀéÉ/// Creates an image from this picture.
///
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped. ÀéÑ	ÀéÖ  ÀéÜ
Àéá   Àéìƒ‚ÀíKƒ6/// Synchronously creates a handle to an image of this picture.
///
/// {@template dart.ui.painting.Picture.toImageSync}
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped.
///
/// The image object is created and returned synchronously, but is rasterized
/// asynchronously. If the rasterization fails, an exception will be thrown
/// when the image is drawn to a [Canvas].
///
/// If a GPU context is available, this image will be created as GPU resident
/// and not copied back to the host. This means the image will be more
/// efficient to draw.
///
/// If no GPU context is available, the image will be rasterized on the CPU.
/// {@endtemplate} ÀíW	Àí\  Àíb
Àíg   Àír€‚Àíên/// Release the resources used by this object. The object is no longer usable
/// after this method is called.    Àï¶ˆ‹ÀïÁ  Àğ€µÀğ¸Àğ¹Àğº€™/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To create a [Picture], use a [PictureRecorder].  Àö›Àö  Àö¬Àö¶€õÀöË   Àö¶Àö·À÷¯€Àø*   À÷¯À÷°À÷»À÷¼À÷ÂÀ÷áÀ÷ÊÀ÷ÃÀ÷ÒÀ÷àÀ÷ÓÀ÷ÚÀ÷ßÀ÷ÛÀ÷âÀøÀ÷éÀ÷ãÀ÷ëÀøÀø	ÀøÀğÁ½ÀğÛ  Àğã	Àğè  Àğî
Àğó  ÀğÁÀğÂÀò‚€°Àòñ  Àòú	Àòÿ  Àó
Àó
  ÀóÀó)  Àò‚ÀòƒÀò‰ÀòÀÀò‘ÀòŠÀò™Àò¿ÀòšÀò¡Àò¦Àò¢Àò©Àò±Àò¹ÀòÁÀòÜÀòÈÀòÂÀòÊÀó65ÀóH  ÀóT	ÀóY  Àó_
Àód  Àó6Àó7Àôo€£Àôİ  Àôê	Àôï  Àôõ
Àôú  ÀõÀõ	  ÀôoÀôpÀôvÀô«Àô|ÀôwÀô„ÀôªÀô…ÀôŒÀô‘ÀôÀô”ÀôœÀô¤Àô¬ÀôËÀô³Àô­ÀôµÀõ€°Àõ'   ÀõÀõÀõÊ€ÍÀöŒk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  Àö:Àö;ÀöAÀö^ÀöGÀöBÀöOÀö]ÀöPÀöWÀö\ÀöXÀö_ÀözÀöfÀö`Àöh ÀøC„Àù'€Ô/// Records a [Picture] containing a sequence of graphical operations.
///
/// To begin recording, construct a [Canvas] to record the commands.
/// To end recording, use the [PictureRecorder.endRecording] method. Àù;€× ÀùçÀùö€/// Creates a new idle PictureRecorder. To associate it with a
/// [Canvas] and begin recording, pass this [PictureRecorder] to the
/// [Canvas] constructor.   Àú™Àû£u/// Whether this object is currently recording commands.
///
/// Specifically, this returns true if a [Canvas] object has been
/// created to record commands and recording has not yet ended via a
/// call to [endRecording], and false if either this
/// [PictureRecorder] has not yet been associated with a [Canvas],
/// or the [endRecording] method has already been called.   Àû³,ÀüĞ
/// Finishes recording graphical operations.
///
/// Returns a picture containing the graphical operations that have been
/// recorded thus far. After calling this function, both the picture recorder
/// and the canvas objects are invalid and cannot be used further.    ÀüãƒÆÀüî  ÀıE, ÀıEÀı[   À À Ÿ  ÀıÚ4Àıï   ÀıÚÀıÛÀıuaÀıÇ   ÀıuÀıvÀı|Àı’Àı‚Àı}ÀıŠÀı‘Àı‹Àı“ÀıµÀıšÀı”ÀıœÀşæÀş&   ÀşÀşÀÿü€À c  À qÀ   ÀÿüÀÿıÀ À (À 	À À À 'À À À À À !À )À QÀ 0À *À 2 À «›ÀT/// A single shadow.
///
/// Multiple shadows are stacked together in a [TextStyle]. À‚P ÀœÀ¢p/// Construct a shadow.
///
/// The default shadow is a black shadow with zero offset and zero blur.
/// Default shadows should be completely covered by the casting element,
/// and not be visible.
///
/// Transparency should be adjusted through the [color] alpha.
///
/// Shadow order matters due to compositing multiple translucent objects not
/// being commutative.À©(À¯  À×Àİ  ÀöÀü  À¶À¼ÀÁÀĞÀÂÀåÀëÀìÀÀÀÀ,À_À&ÀÀ)À.	Àe,Àv À‡À¹&ÀÊ ÀİÀã'Àô ÀÀÀ	À#À À-À+À0À5#ÀF ÀTÀRÀWÀ\&Àm À~À|ÀÀ‡€¼À>€¢/// Color that the shadow will be drawn with.
///
/// The shadows are shapes composited directly over the base canvas, and do not
/// represent optical occlusion. ÀH4Àv/// The displacement of the shadow from the casting element.
///
/// Positive x/y offsets will shift the shadow to the right and down, while
/// negative offsets shift the shadow to the left and up. The offsets are
/// relative to the position of the element that is casting it. ÀiÀàO/// The standard deviation of the Gaussian to convolve with the shadow's shape. Ào€®Àïn/// The [blurRadius] in sigmas instead of logical pixels.
///
/// See the sigma argument to [MaskFilter.blur].   À†GÀš   À†À‡Àï|Àh/// Converts a blur radius in pixels to sigmas.
///
/// See the sigma argument to [MaskFilter.blur].
/// À#À+   À	!‚‹À1õ/// Create the [Paint] object that corresponds to this shadow description.
///
/// The [offset] is not represented in the [Paint] object.
/// To honor this as well, the shape should be translated by [offset] before
/// being filled using this [Paint].
///
/// This class does not provide a way to disable shadows to avoid
/// inconsistencies in shadow blur rendering, primarily as a method of
/// reducing test flakiness. [toPaint] should be overridden in subclasses to
/// provide this functionality.   À°€õÀ[/// Returns a new shadow with its [offset] and [blurRadius] scaled by the given
/// factor. ÀÀ%   À©…×À³ƒÔ/// Linearly interpolate between two shadows.
///
/// If either shadow is null, this function linearly interpolates from
/// a shadow that matches the other shadow in color but has a zero
/// offset and a zero blurRadius.
///
/// {@template dart.ui.shadow.lerp}
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]).
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController].
/// {@endtemplate} À¸	ÀÁ  ÀÃ	ÀÌ  ÀÎÀÖ   À„ƒÀI€¥/// Linearly interpolate between two lists of shadows.
///
/// If the lists differ in length, excess items are lerped with null.
///
/// {@macro dart.ui.shadow.lerp} ÀRÀa  ÀcÀr  ÀtÀ|   À€óÀ©  À¬À´  ÀÀÀ‹ƒÓÀ›  ÀªÀ¹   ÀbLÀu   ÀbÀc À²ÌÀm€¯/// A handle to a read-only byte buffer that is managed by the engine.
///
/// The creator of this object is responsible for calling [dispose] when it is
/// no longer needed. À¢ À±À²À³ À´Àº   À%µÀ%¹  À%ÅÀ%Ê À%ÛÀ%dNÀ% 1/// The length, in bytes, of the underlying data.   À%åÀ&ny/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   ÀÆgÀH^/// Creates a copy of the data from a [Uint8List] suitable for internal use
/// in the engine. ÀVÀa   À1ƒGÀÉr/// Create a buffer from the asset with key [assetKey].
///
/// Throws an [Exception] if the asset does not exist. ÀÓÀÛ   À!|÷À"i/// Create a buffer from the file with [path].
///
/// Throws an [Exception] if the asset does not exist. À"À"    À#w€•À#Ü  À#âÀ#í  À#òÀ$  À#wÀ#xÀ#~À#¦À#†À#À#À#¥À#À#—À#ŸÀ#§À#ÇÀ#®À#¨À#°À$€§À$~  À$À$•  À$À$®  À$À$À$À$?À$À$À$'À$>À$(À$0À$8À$@À$iÀ$GÀ$AÀ$IÀ$»€¥À%(  À%6À%>  À%GÀ%W  À$»À$¼À$ÂÀ$êÀ$ÊÀ$ÃÀ$ÒÀ$éÀ$ÓÀ$ÛÀ$ãÀ$ëÀ%À$òÀ$ìÀ$ôÀ' ‚£À)‚/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, an [ImageDescriptor] that has not been disposed
/// may still retain a reference to the memory from this buffer even if it
/// has been disposed. Freeing that memory requires disposing all resources
/// that may still hold it.   À)§€ÕÀ*qk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À*À*À*À*;À*$À*À*,À*:À*-À*4À*9À*5À*<À*_À*CÀ*=À*E À*€‰‰À+E€µ/// A descriptor of data that can be turned into an [Image] via a [Codec].
///
/// Use this class to determine the height, width, and byte size of image data
/// before decoding it. À+Y‚çÀ-À-‘À-”Ğ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.À-šÀ-«  À-¸À-Æ  À-ĞÀ-Ş  À-éÀ-ï  À-ü À.    À/«yÀ0d/// The width, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   À0({À0œe/// The height, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   À0§€…À1h/// The number of bytes per pixel in the image.
///
/// On web, this is only supported for [raw] images.   À.DcÀ.®H/// Creates an image descriptor from encoded data in a supported format. À.¶À.Ç   À10€øÀ2€Ş/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).   À2,ÛÀ3Ï‚/// Creates a [Codec] object which is suitable for decoding the data in the
/// buffer to an [Image].
///
/// If only one of targetWidth or  targetHeight are specified, the other
/// dimension will be scaled according to the aspect ratio of the supplied
/// dimension.
///
/// If either targetWidth or targetHeight is less than or equal to zero, it
/// will be treated as if it is null. À3áÀ3ç  À3óÀ3ù    À4Œ¦À4  À4mÀ4ƒÀ4„À4…   À4Œƒ£À6ÂÀ6ÃÀ6ÆĞ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.À6ÌÀ6İ  À6êÀ6ø  À7À7  À7À7!  À7. À7D   À9áÀ9æ  À:ŸÀ:¤  À;cÀ;h  À:g4À:{   À:gÀ:hÀ;(7À;<   À;(À;)À<LÀ<   À<À<À83€²À8¦  À8³À8Ä  À8ËÀ8Ü  À83À84À8:À8iÀ8BÀ8;À8JÀ8hÀ8KÀ8SÀ8ZÀ8_À8[À8bÀ8jÀ8‘À8qÀ8kÀ8sÀ8é€ôÀ9g  À9pÀ9  À9À9   À9§	À9¬  À9²
À9·  À9¾À9Ã  À9ÌÀ9Ñ  À8éÀ8êÀ8ğÀ9*À8öÀ8ñÀ8şÀ9)À8ÿÀ9À9À9À9À9$À9+À9NÀ92À9,À94À9ñrÀ:W   À9ñÀ9òÀ9øÀ:À9ÿÀ9ùÀ:À:À:À:À:À:À:À:FÀ:À:À: À:@À::À:BÀ:°tÀ;   À:°À:±À:·À:ÕÀ:¾À:¸À:ÆÀ:ÔÀ:ÇÀ:ÎÀ:ÓÀ:ÏÀ:ÖÀ;À:İÀ:×À:ßÀ; À:úÀ;À;{€‚À;é   À;{À;|À;‚À; À;‰À;ƒÀ;‘À;ŸÀ;’À;™À;À;šÀ;¡À;ØÀ;¨À;¢À;ªÀ;ÒÀ;ÌÀ;ÔÀ<QpÀ<·   À<QÀ<RÀ<]À<^À<dÀ<À<jÀ<eÀ<rÀ<€À<sÀ<zÀ<À<{À<‚À<¥À<‰À<ƒÀ<‹À<Åƒ(À<ß  À<ñÀ<÷  À=À=	  À<ÅÀ<ÆÀ?ñ€¾À@j  À@|À@ƒ  À@ŒÀ@‘  À@À@¢  À?ñÀ?òÀ?øÀ@+À?şÀ?ùÀ@À@*À@À@À@À@À@À@À@%À@,À@XÀ@3À@-À@5 ÀL¤ƒùÀN u/// An exception thrown by [Canvas.drawImage] and related methods when drawing
/// an [Image] created via [Picture.toImageSync] that is in an invalid state.
///
/// This exception may be thrown if the requested image dimensions exceeded the
/// maximum 2D texture size allowed by the GPU, or if no GPU surface or context
/// was available for rasterization at request time. ÀNWBÀNzÀN{ÀN| ÀN}ÀNƒ  ÀNŒ
ÀN’   ÀNIÀNß2/// A string containing details about the failure. ÀNëiÀOOO/// If available, the stack trace at the time [Picture.toImageSync] was called.  ÀOYBÀOl   ÀOYÀOZ  ±çÀ Oò½‹/// Algorithms to use when painting on the canvas.
///
/// When drawing a shape or image onto a canvas, different algorithms can be
/// used to blend the pixels. The different values of [BlendMode] specify
/// different such algorithms.
///
/// Each algorithm has two inputs, the _source_, which is the image being drawn,
/// and the _destination_, which is the image into which the source image is
/// being composited. The destination is often thought of as the _background_.
/// The source and destination both have four color channels, the red, green,
/// blue, and alpha channels. These are typically represented as numbers in the
/// range 0.0 to 1.0. The output of the algorithm also has these same four
/// channels, with values computed from the source and destination.
///
/// The documentation of each value below describes how the algorithm works. In
/// each case, an image shows the output of blending a source image with a
/// destination image. In the images below, the destination is represented by an
/// image with horizontal lines and an opaque landscape photograph, and the
/// source is represented by an image with vertical lines (the same lines but
/// rotated) and a bird clip-art image. The [src] mode shows only the source
/// image, and the [dst] mode shows only the destination image. In the
/// documentation below, the transparency is illustrated by a checkerboard
/// pattern. The [clear] mode drops both the source and destination, resulting
/// in an output that is entirely transparent (illustrated by a solid
/// checkerboard pattern).
///
/// The horizontal and vertical bars in these images show the red, green, and
/// blue channels with varying opacity levels, then all three color channels
/// together with those same varying opacity levels, then all three color
/// channels set to zero with those varying opacity levels, then two bars showing
/// a red/green/blue repeating gradient, the first with full opacity and the
/// second with partial opacity, and finally a bar with the three color channels
/// set to zero but the opacity varying in a repeating gradient.
///
/// ## Application to the [Canvas] API
///
/// When using [Canvas.saveLayer] and [Canvas.restore], the blend mode of the
/// [Paint] given to the [Canvas.saveLayer] will be applied when
/// [Canvas.restore] is called. Each call to [Canvas.saveLayer] introduces a new
/// layer onto which shapes and images are painted; when [Canvas.restore] is
/// called, that layer is then composited onto the parent layer, with the source
/// being the most-recently-drawn shapes and images, and the destination being
/// the parent layer. (For the first [Canvas.saveLayer] call, the parent layer
/// is the canvas itself.)
///
/// See also:
///
///  * [Paint.blendMode], which uses [BlendMode] to define the compositing
///    strategy.  ½¹€î¾¢€Ş/// Drop both the source and destination images, leaving nothing.
///
/// This corresponds to the "clear" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_clear.png) ¾¬H¿ñ4/// Drop the destination image, only paint the source image.
///
/// Conceptually, the destination is first cleared, then the source image is
/// painted.
///
/// This corresponds to the "Copy" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_src.png) ¿ùMÀ AC9/// Drop the source image, only paint the destination image.
///
/// Conceptually, the source image is discarded, leaving the destination
/// untouched.
///
/// This corresponds to the "Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dst.png) À AKìÀ C0Ğ/// Composite the source image over the destination image.
///
/// This is the default value. It represents the most intuitive case, where
/// shapes are painted on top of what is below, with transparent areas showing
/// the destination layer.
///
/// This corresponds to the "Source over Destination" Porter-Duff operator,
/// also known as the Painter's Algorithm.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOver.png) À C<­À Dâ‘/// Composite the source image under the destination image.
///
/// This is the opposite of [srcOver].
///
/// This corresponds to the "Destination over Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOver.png)
///
/// This is useful when the source image should have been painted before the
/// destination image, but could not be. À Dî‚šÀ Gƒ‚x/// Show the source image, but only where the two images overlap. The
/// destination image is not rendered, it is treated merely as a mask. The
/// color channels of the destination are ignored, only the opacity has an
/// effect.
///
/// To show the destination image instead, consider [dstIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is absent, rather than where it is present), consider
/// [srcOut].
///
/// This corresponds to the "Source in Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcIn.png) À G‚„À J‚f/// Show the destination image, but only where the two images overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [dstOut].
///
/// This corresponds to the "Destination in Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstIn.png) À J‚˜À L¨‚y/// Show the source image, but only where the two images do not overlap. The
/// destination image is not rendered, it is treated merely as a mask. The color
/// channels of the destination are ignored, only the opacity has an effect.
///
/// To show the destination image instead, consider [dstOut].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [srcIn].
///
/// This corresponds to the "Source out Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOut.png) À L³‚À O;‚o/// Show the destination image, but only where the two images do not overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcOut].
///
/// To reverse the semantic of the mask (only showing the destination where the
/// source is present, rather than where it is absent), consider [dstIn].
///
/// This corresponds to the "Destination out Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOut.png) À OF‚gÀ Q¦‚E/// Composite the source image over the destination image, but only where it
/// overlaps the destination.
///
/// This corresponds to the "Source atop Destination" Porter-Duff operator.
///
/// This is essentially the [srcOver] operator, but with the output's opacity
/// channel being set to that of the destination image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the destination on top instead of the source, see
/// [dstATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcATop.png) À Q²‚]À T‚;/// Composite the destination image over the source image, but only where it
/// overlaps the source.
///
/// This corresponds to the "Destination atop Source" Porter-Duff operator.
///
/// This is essentially the [dstOver] operator, but with the output's opacity
/// channel being set to that of the source image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the source on top instead of the destination, see
/// [srcATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstATop.png) À T;À UL+/// Apply a bitwise `xor` operator to the source and destination images. This
/// leaves transparency where they would overlap.
///
/// This corresponds to the "Source xor Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_xor.png) À UTƒOÀ XŸƒ,/// Sum the components of the source and destination images.
///
/// Transparency in a pixel of one of the images reduces the contribution of
/// that image to the corresponding output pixel, as if the color of that
/// pixel in that image was darker.
///
/// This corresponds to the "Source plus Destination" Porter-Duff operator.
///
/// This is the right blend mode for cross-fading between two images. Consider
/// two images A and B, and an interpolation time variable _t_ (from 0.0 to
/// 1.0). To cross fade between them, A should be drawn with opacity 1.0 - _t_
/// into a new layer using [BlendMode.srcOver], and B should be drawn on top
/// of it, at opacity _t_, into the same layer, using [BlendMode.plus].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_plus.png) À X¨ƒVÀ [öƒ'/// Multiply the color components of the source and destination images.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// When compositing two opaque images, this has similar effect to overlapping
/// two transparencies on a projector.
///
/// For a variant that also multiplies the alpha channel, consider [multiply].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_modulate.png)
///
/// See also:
///
///  * [screen], which does a similar computation but inverted.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À \L…!À ag„â/// Multiply the inverse of the components of the source and destination
/// images, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// This is essentially the same as [modulate] blend mode, but with the values
/// of the colors inverted before the multiplication and the result being
/// inverted back before rendering.
///
/// This can only result in the same or lighter colors (multiplying by black,
/// 1.0, results in no change; multiplying by white, 0.0, results in white).
/// Similarly, in the alpha channel, it can only result in more opaque colors.
///
/// This has similar effect to two projectors displaying their images on the
/// same screen simultaneously.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_screen.png)
///
/// See also:
///
///  * [modulate], which does a similar computation but without inverting the
///    values.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À a‹ƒŞÀ ebƒ®/// Multiply the components of the source and destination images after
/// adjusting them to favor the destination.
///
/// Specifically, if the destination value is smaller, this multiplies it with
/// the source value, whereas is the source value is smaller, it multiplies
/// the inverse of the source value with the inverse of the destination value,
/// then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_overlay.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [hardLight], which is similar to [overlay] but favors the source image
///    instead of the destination image. À en7À fŸ"/// Composite the source and destination image by choosing the lowest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_darken.png) À fª:À gİ$/// Composite the source and destination image by choosing the highest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_lighten.png) À gé{À iZb/// Divide the destination by the inverse of the source.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorDodge.png) À ii‘À jñy/// Divide the inverse of the destination by the source, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorBurn.png) À jÿƒâÀ nØƒ°/// Multiply the components of the source and destination images after
/// adjusting them to favor the source.
///
/// Specifically, if the source value is smaller, this multiplies it with the
/// destination value, whereas is the destination value is smaller, it
/// multiplies the inverse of the destination value with the inverse of the
/// source value, then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hardLight.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [overlay], which is similar to [hardLight] but favors the destination
///    image instead of the source image. À næsÀ pPU/// Use [colorDodge] for source values below 0.5 and [colorBurn] for source
/// values above 0.5.
///
/// This results in a similar but softer effect than [overlay].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_softLight.png)
///
/// See also:
///
///  * [color], which is a more subtle tinting effect. À p^ÅÀ r¤/// Subtract the smaller value from the bigger value for each channel.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [exclusion] but harsher.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_difference.png) À r(ÔÀ só²/// Subtract double the product of the two images from the sum of the two
/// images.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [difference] but softer.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_exclusion.png) À t‚ÙÀ vÒ‚´/// Multiply the components of the source and destination images, including
/// the alpha channel.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// Since the alpha channel is also multiplied, a fully-transparent pixel
/// (opacity 0.0) in one image results in a fully transparent pixel in the
/// output. This is similar to [dstIn], but with the colors combined.
///
/// For a variant that multiplies the colors but does not multiply the alpha
/// channel, consider [modulate].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_multiply.png) À vü‚÷À yğ‚Ñ/// Take the hue of the source image, and the saturation and luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which is a similar but stronger effect as it also applies the
///    saturation of the source image.
///  * [HSVColor], which allows colors to be expressed using Hue rather than
///    the red/green/blue channels of [Color]. À yø‚dÀ |R‚=/// Take the saturation of the source image, and the hue and luminosity of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which also applies the hue of the source image.
///  * [luminosity], which applies the luminosity of the source image to the
///    destination. À |a‚ãÀ ?‚½/// Take the hue and saturation of the source image, and the luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue and saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_color.png)
///
/// See also:
///
///  * [hue], which is a similar but weaker effect.
///  * [softLight], which is a similar tinting effect but also tints white.
///  * [saturation], which only applies the saturation of the source image. À I‚À Ì‚d/// Take the luminosity of the source image, and the hue and saturation of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their luminosity from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_luminosity.png)
///
/// See also:
///
///  * [saturation], which applies the saturation of the source image to the
///    destination.
///  * [ImageFilter.blur], which can be used with [BackdropFilter] for a
///    related effect.    À ÛŒ{À ‡U…t/// Quality levels for image sampling in [ImageFilter] and [Shader] objects that sample
/// images and for [Canvas] operations that render images.
///
/// When scaling up typically the quality is lowest at [none], higher at [low] and [medium],
/// and for very large scale factors (over 10x) the highest at [high].
///
/// When scaling down, [medium] provides the best quality especially when scaling an
/// image to less than half its size or for animating the scale factor between such
/// reductions. Otherwise, [low] and [high] provide similar effects for reductions of
/// between 50% and 100% but the image may lose detail and have dropouts below 50%.
///
/// To get high quality when scaling images up and down, or when the scale is
/// unknown, [medium] is typically a good balanced choice.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/filter_quality.png)
///
/// When building for the web using the `--web-renderer=html` option, filter
/// quality has no effect. All images are rendered using the respective
/// browser's default setting.
///
/// See also:
///
///  * [Paint.filterQuality], which is used to pass [FilterQuality] to the
///    engine while using drawImage calls on a [Canvas].
///  * [ImageShader].
///  * [ImageFilter.matrix].
///  * [Canvas.drawImage].
///  * [Canvas.drawImageRect].
///  * [Canvas.drawImageNine].
///  * [Canvas.drawAtlas].  À ‡æ€ÙÀ ˆ»€Ì/// The fastest filtering method, albeit also the lowest quality.
///
/// This value results in a "Nearest Neighbor" algorithm which just
/// repeats or eliminates pixels as an image is scaled up or down. À ˆÄ€²À ‰s€¦/// Better quality than [none], faster than [medium].
///
/// This value results in a "Bilinear" algorithm which smoothly
/// interpolates between pixels in an image. À ‰{‚À Œ‚k/// The best all around filtering method that is only worse than [high]
/// at extremely large scale factors.
///
/// This value improves upon the "Bilinear" algorithm specified by [low]
/// by utilizing a Mipmap that pre-computes high quality lower resolutions
/// of the image at half (and quarter and eighth, etc.) sizes and then
/// blends between those to prevent loss of detail at small scale sizes.
///
/// {@template dart.ui.filterQuality.seeAlso}
/// See also:
///
///  * [FilterQuality] class-level documentation that goes into detail about
///    relative qualities of the constant values.
/// {@endtemplate} À Œ‚EÀ O‚&/// Best possible quality when scaling up images by scale factors larger than
/// 5-10x.
///
/// When images are scaled down, this can be worse than [medium] for scales
/// smaller than 0.5x, or when animating the scale factor.
///
/// This option is also the slowest.
///
/// This value results in a standard "Bicubic" algorithm which uses a 3rd order
/// equation to smooth the abrupt transitions between pixels while preserving
/// some of the sense of an edge and avoiding sharp peaks in the result.
///
/// {@macro dart.ui.filterQuality.seeAlso}    À X†ÆÀ K€±/// Styles to use for line endings.
///
/// See also:
///
///  * [Paint.strokeCap] for how this value is used.
///  * [StrokeJoin] for the different kinds of line segment joins.  À Y…À Úr/// Begin and end contours with a flat edge and no extension.
///
/// ![A butt cap ends line segments with a square end that stops at the end of
/// the line segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/butt_cap.png)
///
/// Compare to the [square] cap, which has the same shape, but extends past
/// the end of the line by half a stroke width. À ãËÀ ’©µ/// Begin and end contours with a semi-circle extension.
///
/// ![A round cap adds a rounded end to the line segment that protrudes
/// by one half of the thickness of the line (which is the radius of the cap)
/// past the end of the segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line. À ’³‚hÀ •‚I/// Begin and end contours with a half square extension. This is
/// similar to extending each contour by half the stroke width (as
/// given by [Paint.strokeWidth]).
///
/// ![A square cap has a square end that effectively extends the line length
/// by half of the stroke width.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/square_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line.
///
/// Compare to the [butt] cap, which has the same shape, but doesn't extend
/// past the end of the line.    À • ˆÀ –Êg/// Styles to use for line segment joins.
///
/// This only affects line joins for polygons drawn by [Canvas.drawPath] and
/// rectangles, not points drawn as lines with [Canvas.drawPoints].
///
/// See also:
///
/// * [Paint.strokeJoin] and [Paint.strokeMiterLimit] for how this value is
///   used.
/// * [StrokeCap] for the different kinds of line endings.  À –Ù‚YÀ ™-‚7/// Joins between line segments form sharp corners.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.
///   * [Paint.strokeMiterLimit], used to define when a miter is drawn instead
///     of a bevel when the join is set to this value. À ™7ÌÀ šş®/// Joins between line segments are semi-circular.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value. À ›‚À ÷/// Joins between line segments connect the corners of the butt ends of the
/// line segments to give a beveled appearance.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.    À $‚ÖÀ ºT/// Strategies for painting shapes and paths on a canvas.
///
/// See [Paint.style].  À &€·À Ù€¬/// Apply the [Paint] to the inside of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results in a disc
/// of the given size being painted. À âÀ Ÿñ/// Apply the [Paint] to the edge of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results is a hoop
/// of the given size being painted. The line drawn on the edge will
/// be the width given by the [Paint.strokeWidth] property.    À ŸüŒ‡À  0./// Different ways to clip a widget's content.  À  9‚8À ¢m‚/// No clip at all.
///
/// This is the default option for most widgets: if the content does not
/// overflow the widget boundary, don't pay any performance cost for clipping.
///
/// If the content does overflow, please explicitly specify the following
/// [Clip] options:
///  * [hardEdge], which is the fastest clipping, but with lower fidelity.
///  * [antiAlias], which is a little slower than [hardEdge], but with smoothed edges.
///  * [antiAliasWithSaveLayer], which is much slower than [antiAlias], and should
///    rarely be used. À ¢v‚_À ¤Í‚:/// Clip, but do not apply anti-aliasing.
///
/// This mode enables clipping, but curves and non-axis-aligned straight lines will be
/// jagged as no effort is made to anti-alias.
///
/// Faster than other clipping modes, but slower than [none].
///
/// This is a reasonable choice when clipping is needed, if the container is an axis-
/// aligned rectangle or an axis-aligned rounded rectangle with very small corner radii.
///
/// See also:
///
///  * [antiAlias], which is more reasonable when clipping is needed and the shape is not
///    an axis-aligned rectangle. À ¤Úƒ.À §ÿƒ /// Clip with anti-aliasing.
///
/// This mode has anti-aliased clipping edges to achieve a smoother look.
///
/// It' s much faster than [antiAliasWithSaveLayer], but slower than [hardEdge].
///
/// This will be the common case when dealing with circles and arcs.
///
/// Different from [hardEdge] and [antiAliasWithSaveLayer], this clipping may have
/// bleeding edge artifacts.
/// (See https://fiddle.skia.org/c/21cb4c2b2515996b537f36e7819288ae for an example.)
///
/// See also:
///
///  * [hardEdge], which is a little faster, but with lower fidelity.
///  * [antiAliasWithSaveLayer], which is much slower, but can avoid the
///    bleeding edges if there's no other way.
///  * [Paint.isAntiAlias], which is the anti-aliasing switch for general draw operations. À ¨„sÀ ¬j„4/// Clip with anti-aliasing and saveLayer immediately following the clip.
///
/// This mode not only clips with anti-aliasing, but also allocates an offscreen
/// buffer. All subsequent paints are carried out on that buffer before finally
/// being clipped and composited back.
///
/// This is very slow. It has no bleeding edge artifacts (that [antiAlias] has)
/// but it changes the semantics as an offscreen buffer is now introduced.
/// (See https://github.com/flutter/flutter/issues/18057#issuecomment-394197336
/// for a difference between paint without saveLayer and paint with saveLayer.)
///
/// This will be only rarely needed. One case where you might need this is if
/// you have an image overlaid on a very different background color. In these
/// cases, consider whether you can avoid overlaying multiple colors in one
/// spot (e.g. by having the background color only present where the image is
/// absent). If you can, [antiAlias] would be fine and much faster.
///
/// See also:
///
///  * [antiAlias], which is much faster, and has similar clipping results.    À ïhƒ×À ñ9Ë/// The color space describes the colors that are available to an [Image].
///
/// This value can help decide which [ImageByteFormat] to use with
/// [Image.toByteData]. Images that are in the [extendedSRGB] color space
/// should use something like [ImageByteFormat.rawExtendedRgba128] so that
/// colors outside of the sRGB gamut aren't lost.
///
/// This is also the result of [Image.colorSpace].
///
/// See also: https://en.wikipedia.org/wiki/Color_space  À ñH€ØÀ ò€Ç/// The sRGB color space.
///
/// You may know this as the standard color space for the web or the color
/// space of non-wide-gamut Flutter apps.
///
/// See also: https://en.wikipedia.org/wiki/SRGB À ò$À ó0/// A color space that is backwards compatible with sRGB but can represent
/// colors outside of that gamut with values outside of [0..1]. In order to
/// see the extended values an [ImageByteFormat] like
/// [ImageByteFormat.rawExtendedRgba128] must be used.    À óA‰À ôÍY/// The format in which image bytes should be returned when using
/// [Image.toByteData].  À ôá€‚À õ\t/// Raw RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with premultiplied alpha, 8 bits per channel. À õh€À õçx/// Raw straight RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 8 bits per channel. À õû€»À ö©€¥/// Raw unmodified format.
///
/// Unencoded bytes, in the image's existing format. For example, a grayscale
/// image may use a single 8-bit channel for each pixel. À ö»‚ÎÀ ùw‚/// Raw extended range RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 32 bit
/// float (IEEE 754 binary32) per channel.
///
/// Example usage:
///
/// ```dart
/// import 'dart:ui' as ui;
/// import 'dart:typed_data';
///
/// Future<Map<String, double>> getFirstPixel(ui.Image image) async {
///   final ByteData data =
///       (await image.toByteData(format: ui.ImageByteFormat.rawExtendedRgba128))!;
///   final Float32List floats = Float32List.view(data.buffer);
///   return <String, double>{
///     'r': floats[0],
///     'g': floats[1],
///     'b': floats[2],
///     'a': floats[3],
///   };
/// }
/// ``` À ù‚¾À üI‚œ/// PNG format.
///
/// A loss-less compression format for images. This format is well suited for
/// images with hard edges, such as screenshots or sprites, and images with
/// text. Transparency is supported. The PNG format supports images up to
/// 2,147,483,647 pixels in either dimension, though in practice available
/// memory provides a more immediate limitation on maximum image size.
///
/// PNG images normally use the `.png` file extension and the `image/png` MIME
/// type.
///
/// See also:
///
///  * <https://en.wikipedia.org/wiki/Portable_Network_Graphics>, the Wikipedia page on PNG.
///  * <https://tools.ietf.org/rfc/rfc2083.txt>, the PNG standard.    À üQƒ?À ü•>/// The format of pixel data given to [decodeImageFromPixels].  À ü¥€ÙÀ ıv€Ê/// Each pixel is 32 bits, with the highest 8 bits encoding red, the next 8
/// bits encoding green, the next 8 bits encoding blue, and the lowest 8 bits
/// encoding alpha. Premultiplied alpha is used. À ıƒ€ÙÀ şT€Ê/// Each pixel is 32 bits, with the highest 8 bits encoding blue, the next 8
/// bits encoding green, the next 8 bits encoding red, and the lowest 8 bits
/// encoding alpha. Premultiplied alpha is used. À şa,À ÿ‚/// Each pixel is 128 bits, where each color component is a 32 bit float that
/// is normalized across the sRGB gamut.  The first float is the red
/// component, followed by: green, blue and alpha. Premultiplied alpha isn't
/// used, matching [ImageByteFormat.rawExtendedRgba128].    Àwbƒ•Àwÿ€—/// Determines the winding rule that decides how the interior of a [Path] is
/// calculated.
///
/// This enum is used by the [Path.fillType] property.  Àx¯Ày¸—/// The interior is defined by a non-zero sum of signed edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses lines going clockwise
/// around the point a different number of times than it crosses lines going
/// counter-clockwise around that point.
///
/// See: <https://en.wikipedia.org/wiki/Nonzero-rule> ÀyÄ0Àzí/// The interior is defined by an odd number of edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses an odd number of lines.
///
/// See: <https://en.wikipedia.org/wiki/Even-odd_rule>    ÀzùˆLÀ{­€ˆ/// Strategies for combining paths.
///
/// See also:
///
/// * [Path.combine], which uses this enum to decide how to combine two paths.  À{¿£À}X„/// Subtract the second path from the first path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// first circle that was not overlapped by the second circle.
///
/// See also:
///
///  * [reverseDifference], which is the same but subtracting the first path
///    from the second. À}f‡À~äk/// Create a new path that is the intersection of the two paths, leaving the
/// overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be only the overlapping portion
/// of the two circles.
///
/// See also:
///  * [xor], which is the inverse of this operation À~ñ$À€/// Create a new path that is the union (inclusive-or) of the two paths.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a figure-eight like shape
/// matching the outer boundaries of both circles. À€‚À˜n/// Create a new path that is the exclusive-or of the two paths, leaving
/// everything but the overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the figure-eight like shape less the overlapping parts
///
/// See also:
///  * [intersect], which is the inverse of this operation ÀŸ£Àƒ1}/// Subtract the first path from the second path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// second circle that was not overlapped by the first circle.
///
/// See also:
///
///  * [difference], which is the same but subtracting the second path
///    from the first.    À‚ƒ{Àø4/// Styles to use for blurs in [MaskFilter] objects.  À?€–ÀÏ€‹/// Fuzzy inside and outside. This is useful for painting shadows that are
/// offset from the shape that ostensibly is casting the shadow. ÀÚ€ÍÀ¢€Á/// Solid inside, fuzzy outside. This corresponds to drawing the shape, and
/// additionally drawing the blur. This can make objects appear brighter,
/// maybe even as if they were fluorescent. À¬€æÀ€Ú/// Nothing inside, fuzzy outside. This is useful for painting shadows for
/// partially transparent shapes, when they are painted separately but without
/// an offset, so that the shadow doesn't paint below the shape. À—cÀõY/// Fuzzy inside, nothing outside. This can make shapes appear to be lit from
/// within.    Àg›“Ànn†’/// Defines what happens at the edge of a gradient or the sampling of a source image
/// in an [ImageFilter].
///
/// A gradient is defined along a finite inner area. In the case of a linear
/// gradient, it's between the parallel lines that are orthogonal to the line
/// drawn between two points. In the case of radial gradients, it's the disc
/// that covers the circle centered on a particular point up to a given radius.
///
/// An image filter reads source samples from a source image and performs operations
/// on those samples to produce a result image. An image defines color samples only
/// for pixels within the bounds of the image but some filter operations, such as a blur
/// filter, read samples over a wide area to compute the output for a given pixel. Such
/// a filter would need to combine samples from inside the image with hypothetical
/// color values from outside the image.
///
/// This enum is used to define how the gradient or image filter should treat the regions
/// outside that defined inner area.
///
/// See also:
///
///  * [painting.Gradient], the superclass for [LinearGradient] and
///    [RadialGradient], as used by [BoxDecoration] et al, which works in
///    relative coordinates and can create a [Shader] representing the gradient
///    for a particular [Rect] on demand.
///  * [dart:ui.Gradient], the low-level class used when dealing with the
///    [Paint.shader] property directly, with its [Gradient.linear] and
///    [Gradient.radial] constructors.
///  * [dart:ui.ImageFilter.blur], an ImageFilter that may sometimes need to
///    read samples from outside an image to combine with the pixels near the
///    edge of the image.  Àn{‚£Àq‚‡/// Samples beyond the edge are clamped to the nearest color in the defined inner area.
///
/// A gradient will paint all the regions outside the inner area with the
/// color at the end of the color stop list closest to that region.
///
/// An image filter will substitute the nearest edge pixel for any samples taken from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png) Àq#ƒ5ÀtPƒ/// Samples beyond the edge are repeated from the far end of the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated from 1.0 to 2.0, 2.0 to 3.0, and so forth (and for linear gradients, similarly
/// from -1.0 to 0.0, -2.0 to -1.0, etc).
///
/// An image filter will treat its source image as if it were tiled across the enlarged
/// sample space from which it reads, each tile in the same orientation as the base image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png) Àt]ƒ|ÀwÓƒY/// Samples beyond the edge are mirrored back and forth across the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated backwards from 2.0 to 1.0, then forwards from 2.0 to 3.0, then backwards
/// again from 4.0 to 3.0, and so forth (and for linear gradients, similarly in the
/// negative direction).
///
/// An image filter will treat its source image as tiled in an alternating forwards and
/// backwards or upwards and downwards direction across the sample space from which
/// it is reading.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png) ÀwŞ‚½Àz–‚Ÿ/// Samples beyond the edge are treated as transparent black.
///
/// A gradient will render transparency over any region that is outside the circle of a
/// radial gradient or outside the parallel lines that define the inner area of a linear
/// gradient.
///
/// An image filter will substitute transparent black for any sample it must read from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)    ÀÎ˜‚ÃÀÏRw/// Defines how a list of points is interpreted when drawing a set of triangles.
///
/// Used by [Canvas.drawVertices].  ÀÏaQÀÏ©E/// Draw each sequence of three points as the vertices of a triangle. ÀÏ·[ÀĞK/// Draw each sliding window of three points as the vertices of a triangle. ÀĞAÀÑM)/// Draw the first point and each sliding window of two points as the vertices
/// of a triangle.
///
/// This mode is not natively supported by most backends, and is instead
/// implemented by unrolling the points into the equivalent
/// [VertexMode.triangles], which is generally more efficient.    Àıe„-Àş<€/// Defines how a list of points is interpreted when drawing a set of points.
///
/// Used by [Canvas.drawPoints] and [Canvas.drawRawPoints].  ÀşJ·Àÿû/// Draw each point separately.
///
/// If the [Paint.strokeCap] is [StrokeCap.round], then each point is drawn
/// as a circle with the diameter of the [Paint.strokeWidth], filled as
/// described by the [Paint] (ignoring [Paint.style]).
///
/// Otherwise, each point is drawn as an axis-aligned square with sides of
/// length [Paint.strokeWidth], filled as described by the [Paint] (ignoring
/// [Paint.style]). À €éÀ ê€×/// Draw each sequence of two points as a line segment.
///
/// If the number of points is odd, then the last point is ignored.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]). À ô€›Àˆ€‹/// Draw the entire sequence of points as one line.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]).    À”Àx/// Defines how a new clip region should be merged with the existing clip
/// region.
///
/// Used by [Canvas.clipRect].  ÀBÀU5/// Subtract the new region from the existing region. ÀdBÀ6/// Intersect the new region from the existing region.       „‹o„  „	„£   „üt…  ……   …r€…w  …†…   †€Û†  ††%   †à€†å  †ô†ü   ‡om‡u  ‡‡ˆ  ‡Š‡’   À.<pÀ.\  À.gÀ.o  À.<À.=À.CÀ.TÀ.DÀCõ‰?ÀKÍ‡‰/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The `list` parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported:
/// {@template dart.ui.imageFormats}
/// JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP. Additional
/// formats may be supported by the underlying platform. Flutter will
/// attempt to call platform API to decode unrecognized formats, and if the
/// platform API supports decoding the image Flutter will be able to render it.
/// {@endtemplate}
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed. ÀKæÀKñ  ÀKúÀL   ÀLÀL  ÀL#ÀL)  ÀL9ÀM6Š¡ÀUpˆ+/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported: {@macro dart.ui.imageFormats}
///
/// The [buffer] will be disposed by this method once the codec has been created,
/// so the caller must relinquish ownership of the [buffer] when they call this
/// method.
///
/// The [targetWidth] and [targetHeight] arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed.
///
/// ## Compatibility note on the web
///
/// When running Flutter on the web, only the CanvasKit renderer supports image
/// resizing capabilities (not the HTML renderer). So if image resizing is
/// critical to your use case, and you're deploying to the web, you should
/// build using the CanvasKit renderer. ÀU“ÀU¤  ÀU¯ÀUµ  ÀUÃÀUÉ  ÀUØÀUŞ  ÀUîÀWÙ‰„À^ğ‡/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary
/// data). The data can be for either static or animated images. The following
/// image formats are supported: {@macro dart.ui.imageFormats}
///
/// The [buffer] will be disposed by this method once the codec has been
/// created, so the caller must relinquish ownership of the [buffer] when they
/// call this method.
///
/// The [getTargetSize] parameter, when specified, will be invoked and passed
/// the image's intrinsic size to determine the size to decode the image to.
/// The width and the height of the size it returns must be positive values
/// greater than or equal to 1, or null. It is valid to return a
/// [TargetImageSize] that specifies only one of `width` and `height` with the
/// other remaining null, in which case the omitted dimension will be scaled to
/// maintain the aspect ratio of the original dimensions. When both are null or
/// omitted, the image will be decoded at its native resolution (as will be the
/// case if the [getTargetSize] parameter is omitted).
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform.
///
/// The returned future can complete with an error if the image decoding has
/// failed.
///
/// ## Compatibility note on the web
///
/// When running Flutter on the web, only the CanvasKit renderer supports image
/// resizing capabilities (not the HTML renderer). So if image resizing is
/// critical to your use case, and you're deploying to the web, you should
/// build using the CanvasKit renderer. À_À_"  À_-&À_G   Àa_sÀao  Àa„Àa‰  Àa˜Àa   Ài¦©ÀjÜ0/// Loads a single image frame from a byte array into an [Image] object.
///
/// This is a convenience wrapper around [instantiateImageCodec]. Prefer using
/// [instantiateImageCodec] which also supports multi frame images and offers
/// better error handling. This function swallows asynchronous errors. ÀjğÀjû  Àk Àk   ÀkQ€ïÀk^  ÀkxÀkƒ  ÀkˆÀk   ÀlB‹Àqå…/// Convert an array of pixel values into an [Image] object.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `format`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true. 	ÀqşÀr	  Àr	Àr  Àr
Àr$  Àr-Àr:  ÀrCÀrY  ÀrfÀrl  ÀrwÀr}  Àr‹Àr‘  Àr Àr¦  Àr¶Àz €ëÀzª  Àz»ÀzÈ   À{›À{™  À{ªÀ{¸   À}*$À}6  À}GÀ}O  À}VÀ}^   ÀF²‚¼ÀF¼ ÀFÆÀFÆÀFÉÀFÙ   ÀIpƒ2ÀI½B/// A variant of `_futurize` that can communicate specific errors.ÀIĞÀIĞÀIÓ"ÀIì    À ÿ’dÀ ÿÆ+/// Signature for [Image] lifecycle events.  À ÿéÀ ÿğ   À.®mÀ.è1/// Callback signature for [decodeImageFromList].  À/À/   ÀaÔdÀbÕ€ø/// Signature for a callback that determines the size to which an image should
/// be decoded given its intrinsic size.
///
/// See also:
///
///  * [instantiateImageCodecWithSize], which used this signature for its
///    `getTargetSize` argument.  ÀcÀc  Àc!Àc&   ÀälÀäÄ-/// Signature for [Picture] lifecycle events.  ÀäéÀäò   À@³dÀ@ğ4/// Generic callback signature, used by [_futurize].À@úÀ@ú ÀAÀA   ÀA€…ÀA_=/// Generic callback signature, used by [_futurizeWithError].ÀArÀAr ÀA…ÀAˆ  ÀAÀA˜   ÀA €ÕÀB;€’/// Signature for a method that receives a [_Callback].
///
/// Return value should be null on success, and a string error message on
/// failure.ÀBGÀBG ÀB]ÀBl   ÀBw€±ÀBÜ\/// Signature for a method that receives a [_CallbackWithError].
/// See also: [_Callbacker]ÀBñÀBñ ÀCÀC       ›n <€†€¤€µ€¶€Î€ï-Fz­®û‚E‚•‚æƒ6ƒ„ƒÕ„„„d„Š„‹„ª„ê„ù„û„ü……`…o…q…r…—…ñ† †††/†p†Î†İ†ß†à‡‡]‡l‡n‡o‡›‡Û‡İ‡Şˆˆˆfˆ¶‰‰-‰1‰a‰e‰q‰™‰ÖŠŠFŠNŠRŠ£Šò‹B‹n‹r‹~‹ËŒŒŒŒ-Œ1Œ„ŒÊŒØEKs™Àåë;‰·½Pu¬­íó@PuœÂÈ‘‘‘\‘i‘‘À‘â’’2’3’ˆ’’³’Ú“ “M“}“ƒ“Æ“Ì””R”ˆ”¾”ô•6•7•e•k•“•™•Á•ç––3–F–G–€–†–Õ–÷—&—'—Z—`—±—Ó—ù—ú˜1˜^˜_˜˜˜Æ˜Ç˜ÿ™,™-™v™¬™²™êšš5š9š:šƒšËšÑ›	›/›]››’›“›ãœœœNœgœ™œœœç#[v¦ª«ü)/g²¶·õŸ2ŸRŸrŸxŸ¹Ÿ½Ÿ¾ 	  c  ‡ Å ã¡#¡^¡›¡×¢¢¢¢<¢B¢Š¢Í¢Ó££j£©£ï£õ¤B¤Œ¤×¥#¥q¥Á¦¦_¦Œ¦’¦á§§6§K§b§w§†§®§¶§Ã§Ú§ü¨¨*¨n¨®¨ò©4©?©G©M©Q©R©•©Û©áª-ªtª¿««Y«™«Á¬ ¬¬¬F¬l¬£¬À¬Î­­^­¦­¯­Ì­ş®,®L®i®{®Æ¯¯b¯k¯q¯u¯v¯Ã¯É¯ô°'°b°f°g°s°–°¸°Ë°Ñ°ı±±±1±R±V±W±c±‰±Š±–±ä±æ±ç²²²k²µ²Ô²Ø³)³v³Å´´c´®´ò´öµFµ‘µâ¶.¶|¶É··[·ª·ğ¸¸¸]¸ª¸ô¹F¹“¹äº%º)ºPºTº¢ºã»4»»Ò¼!¼p¼‹¼¼¼¡¼ì¼ı½½]½p½¶½·½û¾¾=¾C¾ ¾©¾ª¾é¾ï¿>¿M¿S¿¿”¿ï¿ö¿÷À @6À @<À @‡À @˜À @À @àÀ @æÀ AAÀ AHÀ AIÀ A†À AŒÀ AÚÀ B+À BHÀ BNÀ BœÀ BÉÀ BÏÀ C.À C9À C:À CxÀ C~À C§À C­À CûÀ DÀ D`À DfÀ DµÀ DàÀ DëÀ DìÀ E4À EÀ EÎÀ EÜÀ EâÀ F!À F'À FtÀ F¼À FÌÀ FÒÀ GÀ G$À GÀ GŠÀ G‹À GØÀ H&À HpÀ HvÀ H°À H¶À IÀ IUÀ I[À I§À I­À J
À JÀ JÀ JcÀ J¶À KÀ KÀ KKÀ KQÀ KÀ KïÀ KõÀ LBÀ LHÀ L¦À L°À L±À MÀ MSÀ MÀ M£À MŞÀ MäÀ N6À N‚À NˆÀ NÕÀ NÛÀ O9À OCÀ ODÀ O“À O³À O¹À PÀ PÀ P]À P©À PİÀ PãÀ Q.À Q?À QEÀ Q¤À Q¯À Q°À QÿÀ RÀ R À RnÀ RtÀ RÄÀ SÀ S?À SEÀ SÀ S¡À S§À TÀ TÀ TÀ TbÀ T–À TœÀ TéÀ TïÀ UJÀ UQÀ URÀ U‘À U—À UæÀ V2À VXÀ V^À V¬À V²À WÀ WQÀ W¢À WñÀ X;À XAÀ XÀ X¥À X¦À XğÀ XöÀ YEÀ Y”À YšÀ YëÀ ZÀ ZÀ ZkÀ ZqÀ ZÑÀ Z×À ZçÀ ZíÀ [/À [wÀ [“À [İÀ [ôÀ \ À \À \IÀ \JÀ \•À \»À \ÁÀ ]À ]ZÀ ]‰À ]À ]àÀ ^,À ^RÀ ^XÀ ^¨À ^÷À _HÀ _NÀ _À _¿À _ÅÀ `#À `)À `9À `?À `À ` À `èÀ aÀ aNÀ aeÀ aˆÀ a‰À aÒÀ bÀ bÀ bXÀ b¦À b÷À cÀ cÀ chÀ cµÀ cäÀ cêÀ dIÀ dOÀ d_À deÀ dÀ dåÀ e5À e`À ekÀ elÀ eºÀ eÙÀ eßÀ f(À f9À f?À fÀ f§À f¨À f÷À gÀ gÀ geÀ gvÀ g|À gÛÀ gæÀ gçÀ h"À h(À htÀ hÁÀ hğÀ höÀ iXÀ ifÀ igÀ iºÀ iÀÀ jÀ jYÀ jˆÀ jÀ jïÀ jüÀ jıÀ kFÀ kpÀ kvÀ kÆÀ lÀ l]À lŠÀ lÀ lÜÀ m)À mXÀ m^À m¿À mÅÀ mÕÀ mÛÀ nÀ n[À nªÀ nÖÀ nãÀ näÀ o2À oJÀ oPÀ o’À o˜À oùÀ oÿÀ pÀ pÀ pNÀ p[À p\À p¥À p«À púÀ qÀ qÀ q`À qqÀ qwÀ q¯À qµÀ rÀ r%À r&À rrÀ r€À r†À rÕÀ rìÀ ròÀ s;À sLÀ sRÀ sŠÀ sÀ sñÀ sşÀ sÿÀ tMÀ tfÀ tlÀ t»À u
À uÀ u\À u©À uñÀ u÷À vFÀ vjÀ vpÀ vĞÀ vùÀ vúÀ wKÀ wdÀ wjÀ w³À w¹À xÀ xRÀ xxÀ x~À xÙÀ xßÀ xïÀ xõÀ yEÀ ynÀ y½À yîÀ yõÀ yöÀ zGÀ z`À zfÀ z¯À zÿÀ {,À {2À {À {“À {£À {©À {ëÀ |:À |PÀ |^À |_À |°À |ÉÀ |ÏÀ }À }À }gÀ }·À }ìÀ }òÀ ~OÀ ~UÀ ~eÀ ~kÀ ~¡À ~ïÀ =À FÀ GÀ ˜À ±À ·À € À €PÀ €}À €ƒÀ €åÀ €ëÀ €ûÀ À PÀ fÀ ±À ÊÀ ØÀ ÚÀ ÛÀ ‚3À ‚nÀ ‚rÀ ‚ÏÀ ƒÀ ƒÀ ƒoÀ ƒÃÀ „À „mÀ „qÀ „¿À „úÀ „şÀ …WÀ …[À …¨À …ğÀ †À †À †!À †%À †pÀ †©À †¿À †ÜÀ †÷À ‡À ‡5À ‡PÀ ‡eÀ ‡»À ‡ãÀ ‡äÀ ˆ(À ˆ.À ˆtÀ ˆ¹À ˆÁÀ ˆÂÀ ˆúÀ ‰ À ‰BÀ ‰qÀ ‰xÀ ‰yÀ ‰ÃÀ ‰ëÀ ‰ñÀ Š<À Š‰À ŠÒÀ ‹À ‹#À ‹SÀ ‹cÀ ‹iÀ ‹¸À ‹ìÀ ŒÀ ŒÀ ŒÀ Œ\À ŒiÀ ŒoÀ Œ½À ŒúÀ  À 'À -À À ÏÀ À  À MÀ UÀ WÀ XÀ |À €À À ’À ÇÀ 
À FÀ WÀ —À À îÀ RÀ XÀ ¦À ØÀ àÀ áÀ ‘À ‘"À ‘lÀ ‘¼À ’,À ’2À ’‚À ’§À ’°À ’±À ’ôÀ “9À “^À “dÀ “³À ”$À ”*À ”zÀ ”ŸÀ ”¥À ”óÀ •À •À •À • À •JÀ •NÀ •›À •ßÀ •ãÀ •ñÀ •õÀ –AÀ –MÀ –ˆÀ –ÅÀ –×À —À —À —|À —‚À —ÊÀ ˜À ˜&À ˜,À ˜<À ˜BÀ ˜À ˜¡À ˜òÀ ™+À ™4À ™5À ™jÀ ™pÀ ™×À ™İÀ š%À šuÀ šÀ š‡À š—À šÀ šëÀ šüÀ ›À ›À ›TÀ ›†À ›ŒÀ ›óÀ ›ùÀ œAÀ œ‘À œÀ œ£À œ³À œ¹À À À !À #À $À ^À bÀ yÀ µÀ ÊÀ À #À $À jÀ °À ×À ßÀ àÀ Ÿ$À ŸjÀ Ÿ±À ŸïÀ ŸùÀ ŸûÀ ŸüÀ  +À  7À  MÀ  SÀ  À  ïÀ  õÀ ¡AÀ ¡WÀ ¡¤À ¡ıÀ ¢RÀ ¢kÀ ¢sÀ ¢tÀ ¢ À ¢¦À ¢ÿÀ £0À £6À £vÀ £|À £ÔÀ ¤/À ¤5À ¤EÀ ¤KÀ ¤§À ¤ËÀ ¤×À ¤ØÀ ¤÷À ¤ıÀ ¥IÀ ¥OÀ ¥¢À ¥¨À ¥ïÀ ¥õÀ ¦JÀ ¦iÀ ¦ÀÀ ¦ÆÀ ¦ÖÀ ¦ÜÀ §$À §oÀ § À §ıÀ ¨
À ¨À ¨WÀ ¨]À ¨°À ©À ©+À ©1À ©ƒÀ ©ĞÀ ª"À ªtÀ ªzÀ ªÊÀ «À «hÀ «¸À «şÀ ¬À ¬À ¬À ¬hÀ ¬‚À ¬„À ¬…À ¬ÇÀ ¬ËÀ ­À ­0À ­>À ­†À ­œÀ ­§À ­¨À ­×À ­ÜÀ ®'À ®rÀ ®ÁÀ ¯À ¯^À ¯cÀ ¯³À °À °À °À °bÀ °cÀ °„À ° À °ÔÀ °ÕÀ ± À ±%À ±NÀ ±sÀ ±À ±ÇÀ ±ñÀ ²!À ²NÀ ²xÀ ²¬À ²ÜÀ ³À ³	À ³KÀ ³À ³¿À ³õÀ ´7À ´uÀ ´µÀ µÀ µGÀ µ‡À µÙÀ ¶#À ¶eÀ ¶fÀ ¶§À ¶éÀ ¶êÀ ·.À ·OÀ ·kÀ ·†À ·‡À ·µÀ ·øÀ ·üÀ ·ıÀ ¸#À ¸NÀ ¸yÀ ¸ÍÀ ¸ÎÀ ¹À ¹"À ¹(À ¹@À ¹YÀ ¹ À ¹¤À ¹ÄÀ ºÀ º>À ºeÀ º©À º­À º®À ºæÀ »À »À »PÀ »VÀ »vÀ »|À »ŒÀ »’À »ØÀ ¼	À ¼QÀ ¼WÀ ¼ŸÀ ¼´À ¼ÈÀ ½À ½=À ½AÀ ½\À ½’À ½ĞÀ ½ÔÀ ½ÕÀ ¾À ¾NÀ ¾OÀ ¾›À ¾¡À ¾ãÀ ¿4À ¿…À ¿¦À ¿¬À ¿ùÀ ÀÀ À À ÀGÀ ÀMÀ À]À ÀcÀ À²À ÀæÀ Á0À ÁFÀ ÁbÀ Á¯À ÁêÀ ÁîÀ ÂÀ ÂKÀ ÂÀ Â‘À Â’À ÂÖÀ ÂÜÀ ÃÀ Ã À ÃrÀ ÃvÀ Ã™À Ã¾À ÃüÀ Ä À ÄÀ Ä;À ÄŠÀ ÄÇÀ ÄÍÀ Å
À Å%À ÅiÀ ÅmÀ ÅÀ Å±À Å÷À ÅûÀ ÅüÀ Æ=À ÆmÀ ÆsÀ Æ¥À ÆÁÀ ÇÀ ÇÀ Ç:À Ç_À Ç¡À Ç¥À Ç¦À ÇçÀ ÇíÀ È>À È‰À ÈÀ ÈÉÀ ÈÏÀ ÈíÀ ÈóÀ É\À ÉbÀ ÉÉÀ ÉÏÀ Ê6À Ê<À ÊˆÀ ÊÙÀ ÊåÀ ÊëÀ ÊûÀ ËÀ ËPÀ Ë|À ËÅÀ ÌÀ Ì"À ÌvÀ ÌzÀ ÌŸÀ ÌÄÀ ÍÀ ÍÀ ÍÀ ÍDÀ Í{À Í|À ÍÇÀ ÎÀ Î`À Î­À ÎûÀ ÏÀ ÏFÀ ÏLÀ ÏšÀ Ï¾À ÏÄÀ Ğ-À Ğ3À ĞœÀ Ğ¢À ÑÀ ÑÀ Ñ]À Ñ®À ÑºÀ ÑÀÀ ÑĞÀ ÑÖÀ Ò À Ò;À Ò„À Ò¤À ÒíÀ ÒñÀ ÓÀ ÓVÀ Ó¡À Ó¥À Ó¦À ÓöÀ Ô4À Ô:À Ô^À Ô}À ÔÁÀ ÔâÀ Ô÷À ÕÀ Õ8À Õ“À ÕÚÀ ÕåÀ ÕëÀ ÕüÀ Ö À Ö&À Ö?À Ö‘À ÖÙÀ ×!À ×.À ×{À ×­À ×ÿÀ ØXÀ Ø©À Ø¯À Ø³À Ø´À ÙÀ ÙZÀ Ù¦À Ù¬À ÙÔÀ Ú!À ÚEÀ ÚŸÀ Ú£À ÚÎÀ ÚóÀ Û9À Û=À Û>À ÛxÀ Û~À Û´À ÛºÀ ÛÊÀ ÛĞÀ ÜÀ ÜDÀ ÜvÀ Ü¾À ÜÕÀ İÀ İ	À İ'À İ7À İEÀ İtÀ İ«À İ´À İÇÀ İÑÀ İáÀ ŞÀ Ş0À ŞÀ ŞšÀ Ş¢À ŞµÀ Ş¿À Ş÷À ŞûÀ ŞüÀ ßCÀ ßUÀ ß[À ß€À ß†À ß×À ßøÀ àOÀ àqÀ àuÀ àÀ àãÀ áÀ á!À áOÀ áWÀ ádÀ áªÀ á°À á´À áµÀ áğÀ áöÀ â=À âWÀ â]À âkÀ â˜À â²À âÄÀ âŞÀ ã.À ã9À ãAÀ ãKÀ ãQÀ ãaÀ ãgÀ ã¢À ãÃÀ äÀ ä<À ä@À ähÀ äÀ äŸÀ äÍÀ äÕÀ äâÀ å#À åyÀ å¤À åèÀ åğÀ åöÀ åúÀ åûÀ æ:À æ@À æŒÀ æÖÀ çÀ ç!À çhÀ çlÀ çÀ ç×À çÛÀ çÜÀ çèÀ çşÀ è7À èVÀ è\À èŒÀ è§À èÃÀ èìÀ é
À é*À éfÀ éuÀ é˜À é À éÉÀ éîÀ éöÀ ê"À ê_À ê´À ê¾À êÍÀ êóÀ êûÀ ëÀ ëÀ ë1À ëbÀ ëzÀ ë€À ë°À ëØÀ ëğÀ ëöÀ ì'À ìSÀ ìkÀ ìqÀ ìÀ ìÍÀ ìåÀ ìëÀ í	À íDÀ í\À íbÀ í‘À íÒÀ íêÀ íğÀ î
À î=À îUÀ î[À îzÀ î·À îÏÀ îÕÀ îíÀ ï&À ï,À ïCÀ ïaÀ ïeÀ ïgÀ ïhÀ ï³À ï·À ïúÀ ğDÀ ğÀ ğÁÀ ğÅÀ ğøÀ ğüÀ ñ4À ñFÀ ñbÀ ñhÀ ñµÀ ñáÀ ñçÀ òÀ ò"À òoÀ ò½À òõÀ ó.À ó>À ó@À óAÀ óƒÀ ó›À óéÀ ô6À ô~À ôÈÀ ôßÀ ôöÀ ôüÀ õZÀ õeÀ õfÀ õ†À õŒÀ õåÀ õøÀ õùÀ öÀ öÀ ölÀ ö§À ö¸À ö¹À ößÀ öåÀ ÷1À ÷^À ÷dÀ ÷yÀ ÷À ÷À ÷«À ÷ËÀ ÷ÑÀ øÀ ø7À øÀ øÏÀ øğÀ ù
À ù$À ù>À ùXÀ ùcÀ ùkÀ ùuÀ ù‹À ùŒÀ ùÀ ù¤À ùôÀ úBÀ úÀ úÛÀ û$À û*À û{À û‡À ûÀ ûÀ û£À üÀ üGÀ üNÀ üPÀ üQÀ üÀ ü£À üñÀ ıAÀ ıtÀ ı€À ıÀ ıĞÀ şÀ şRÀ ş^À ş_À ş¯À şöÀ ÿEÀ ÿ€À ÿÀ ÿ‘À ÿ’À ÿ¾À ÿ÷À ÿøÀ .À 2À rÀ vÀ ÄÀ ÜÀ àÀ/À~ÀÅÀÀ[ÀiÀmÀ¹ÀÀOÀSÀaÀeÀÓÀ"ÀHÀ—À¥À×ÀçÀÀ"À,ÀKÀeÀiÀjÀ‹À§À¾À¿ÀıÀÀNÀÀ±ÀØÀÙÀÀÀiÀ¬ÀÍÀõÀöÀÀÀVÀiÀjÀ¬ÀÀÀÁÀÛÀ	(À	YÀ	_À	°À	ËÀ	ÑÀ
À
gÀ
¶À
ÖÀ
éÀÀ1À]ÀsÀªÀ¿ÀâÀúÀ ÀÀÀIÀOÀÀ³ÀÎÀâÀòÀÀ!À+À™ÀÀÀÓÀÙÀ%À5À;À€ÀÏÀÀÀiÀ‚ÀÒÀ!ÀkÀ·ÀÀ9ÀgÀkÀlÀ¨À®ÀúÀIÀuÀ{ÀÊÀÀKÀ—ÀÄÀâÀÀ4ÀBÀbÀpÀ˜À§ÀõÀûÀÿÀ ÀQÀsÀyÀ¹ÀïÀÀÀqÀ„ÀÀ¡À¥À¦À×ÀİÀ,À{ÀÌÀÀdÀ²ÀşÀÀ"ÀpÀ™ÀŸÀçÀ8ÀNÀTÀŠÀÀÀ¹ÀÙÀñÀ÷À/ÀnÀÀ×ÀèÀúÀÀjÀ¸ÀŞÀÀÀ@ÀHÀNÀpÀ¤ÀïÀÀ]À¡ÀŞÀ÷ÀıÀ9ÀiÀoÀŒÀ¦À¬ÀÎÀìÀ À À À 1À TÀ ZÀ uÀ {À À ×À áÀ çÀ!À!À!$À!*À!oÀ!½À!áÀ!óÀ"À" À"KÀ"œÀ"êÀ#,À#5À#;À#ZÀ#…À#‰À#ŠÀ#ÖÀ$À$"À$oÀ$¹À%	À%XÀ%¢À%ïÀ&(À&)À&5À&_À&aÀ&bÀ&|À&±À&úÀ'À'À'hÀ'ŠÀ'¦À'´À'µÀ(À(À(À(oÀ(ŠÀ(‹À(àÀ))À)vÀ)¦À)İÀ)îÀ*À*À*#À*+À*/À*0À*lÀ*ÂÀ+À+À+6À+IÀ+aÀ+mÀ+…À+ÒÀ+êÀ,4À,lÀ,sÀ,‰À,™À,À,À,éÀ-À-PÀ-lÀ-mÀ-–À-—À-İÀ-üÀ-ıÀ.	À.9À.;À.<À.VÀ.wÀ.«À.­À.®À.àÀ/À/À/QÀ/UÀ/‘À/«À/¯À/ùÀ0BÀ0À0ÖÀ1!À1JÀ1NÀ1‡À1‹À1—À1£À1İÀ2À2<À2‰À2ÔÀ2ñÀ3=À3\À3}À3ƒÀ3‹À3À3¥À3©À3µÀ3ÂÀ3üÀ4=À4}À4¼À5À5"À5qÀ5¹À5ÚÀ5àÀ5èÀ5úÀ6DÀ6`À6fÀ6¤À6ÀÀ6şÀ6ÿÀ7.À74À7À7œÀ7À7ÆÀ7ÌÀ8À8À8fÀ8{À8}À8~À8À8¢À8êÀ9À9À9@À9]À9tÀ9šÀ9°À9±À9àÀ9æÀ:À:?À:ZÀ:[À:ƒÀ:‰À:ÍÀ:ÓÀ;$À;*À;kÀ;›À;¿À;ÀÀ<À<3À<9À<„À<©À<»À<½À<¾À=
À=À=XÀ=sÀ=xÀ=±À=ÏÀ=ãÀ=äÀ=şÀ=ÿÀ>À>FÀ>GÀ>›À>»À>¼À>ÛÀ>ÜÀ>èÀ?2À?3À?ŒÀ?±À?²À?¾À?éÀ@1À@™À@´À@×ÀA8ÀABÀA{ÀAŠÀA²ÀAîÀB0ÀB<ÀBDÀBLÀBeÀBƒÀB‰ÀB¦ÀBªÀB«ÀBçÀC8ÀCˆÀC‰ÀC•ÀC×ÀCòÀCôÀCõÀDÀDÀDkÀD»ÀE	ÀE,ÀE0ÀE‚ÀEĞÀEëÀF+ÀFPÀF¡ÀFçÀG3ÀGƒÀG–ÀGšÀGåÀH/ÀHÀHÎÀIÀIkÀIºÀJÀJ>ÀJBÀJŒÀJÖÀK&ÀKbÀKfÀK³ÀK¿ÀKäÀKøÀLÀL!ÀL?ÀLJÀL–ÀLÀÀLÌÀLêÀM
ÀM.ÀM3ÀM5ÀM6ÀMYÀM]ÀM¬ÀMüÀNJÀNmÀNqÀNÅÀOÀOLÀOPÀO¢ÀOòÀOşÀPÀPMÀP—ÀPçÀQ6ÀQ‚ÀQÓÀR"ÀRjÀR¦ÀRªÀRôÀS>ÀSÀSÊÀSÎÀTÀT'ÀT+ÀTPÀTTÀT¤ÀTïÀU:ÀUbÀU‘ÀU­ÀUÁÀUÖÀUôÀUùÀV!ÀV-ÀVlÀV‰ÀVÍÀVõÀVÿÀWFÀWpÀWzÀW‚ÀWÊÀWÑÀWÖÀWØÀWÙÀWüÀX ÀXKÀXOÀXœÀXëÀY*ÀY.ÀYwÀYÆÀYÜÀYàÀZ.ÀZ{ÀZÇÀ[À[WÀ[§À[÷À\GÀ\~À\‚À\ÌÀ]À]JÀ]NÀ]›À]§À]«À]ĞÀ]ÔÀ^$À^oÀ^ºÀ^âÀ_À_+À_UÀ_`À_ŠÀ_ÖÀ_ŞÀ`9À`xÀ`¹À`áÀaÀa-Àa4ÀaBÀaXÀa\Àa^Àa_Àa¯ÀaÑÀaÓÀaÔÀb#ÀbLÀbPÀb^ÀbbÀb¬ÀbÍÀc	ÀcÀc6Àc9Àc:ÀcÀcƒÀc‘Àc•ÀcáÀdÀdGÀd_Àd‹Àd‘ÀdàÀdøÀe+ÀeWÀe…Àe†Àe´ÀeºÀf	ÀfYÀf§ÀfôÀgÀg%Àg[ÀgoÀgpÀgŸÀg¥ÀgõÀhDÀh‘ÀhßÀi	ÀiÀiEÀiZÀi[ÀigÀi£Ài¥Ài¦ÀiïÀióÀjBÀjÀj×Àk!ÀkNÀkPÀkQÀk¯ÀkèÀl"Àl?ÀlAÀlBÀlÀlƒÀlÑÀmÀm4Àm8Àm„ÀmÕÀnÀnÀncÀn­ÀnıÀoLÀo˜ÀoéÀp8Àp€Àp¼ÀpÀÀq
ÀqTÀq¤ÀqàÀqüÀrÀrÀr+ÀrAÀrdÀruÀr‰ÀrÀr¼ÀrÁÀrŞÀsÀsÀs4ÀsjÀsnÀsoÀs—Às¼ÀsúÀt
Àt Àt8ÀtTÀtqÀtzÀt{Àt˜ÀtŞÀuÀuÀu[Àu‡Àu‘Àu™ÀušÀu«ÀuÆÀuêÀvÀvÀv8Àv|Àv—Àv³Àv¾ÀväÀw Àw Àw!ÀwMÀwYÀw_ÀwaÀwbÀw¯Àw¿ÀwÃÀwúÀxÀxXÀx^Àx¯ÀxşÀyMÀyxÀy~Ày¶ÀyÁÀyÂÀzÀz
Àz[Àz¬Àz²ÀzëÀzöÀzøÀzùÀ{À{!À{/À{3À{‚À{¨À{½À{ñÀ{÷À|EÀ|À|ÑÀ|×À|çÀ|íÀ}<À}VÀ}dÀ}³À}ÙÀ}ßÀ~-À~{À~•À~›À~«À~âÀ~ïÀ:À@ÀÀÙÀ€À€À€bÀ€›À€¡À€ïÀCÀIÀYÀ–ÀÀÑÀ×À‚%À‚pÀ‚±À‚·À‚ÇÀ‚ÍÀƒÀƒ/ÀƒDÀƒFÀƒGÀƒ˜ÀƒµÀ„À„(À„.À„~À„ÇÀ…À…aÀ…{À…À…ĞÀ†À†VÀ†\À†§À†ÌÀ†ŞÀ†àÀ†áÀ‡9À‡ƒÀ‡ŸÀ‡¹À‡ºÀ‡ÆÀˆÀˆ)Àˆ+Àˆ,Àˆ^ÀˆbÀˆ§Àˆ«ÀˆîÀ‰-À‰AÀ‰EÀ‰‹À‰¶À‰ºÀ‰ùÀŠ<ÀŠdÀŠhÀŠ¬ÀŠåÀŠûÀ‹À‹À‹DÀ‹JÀ‹—À‹æÀŒ	ÀŒ=ÀŒmÀŒ„ÀŒˆÀŒ‰ÀŒÇÀŒÍÀÀ/ÀSÀTÀ‰À¬À­ÀõÀ"À#ÀjÀwÀšÀ›ÀâÀÀAÀBÀ…ÀÅÀÔÀÚÀKÀÀÀ‘À‘À‘JÀ‘‘À‘ÖÀ‘ãÀ’1À’2À’wÀ’¾À’ÍÀ’ÓÀ“@À“±À”À”À”IÀ”À”ÕÀ”êÀ•DÀ•EÀ•‹À•ÏÀ–À–[À–€À–†À–óÀ—dÀ—ªÀ—«À—ñÀ˜5À˜zÀ˜ÁÀ™À™/À™}À™~À™ÁÀ™ãÀ™éÀš,ÀšPÀšVÀšÀšİÀ›$À›hÀ›¯À›óÀœ!Àœ'ÀœlÀœ¢ÀœóÀœôÀCÀˆÀÀİÀ&ÀjÀ‘À—ÀÜÀŸ+ÀŸwÀŸ}ÀŸ ÀŸÁÀŸÜÀŸ÷À À À À hÀ ­À ³À çÀ íÀ¡<À¡ŠÀ¡ÍÀ¢À¢À¢`À¢®À¢ûÀ£À£-À£GÀ£hÀ£ƒÀ£À£¹À£¿À£ÀÀ¤À¤À¤9À¤:À¤|À¤ªÀ¤°À¥À¥PÀ¥kÀ¥lÀ¥´À¥ñÀ¦0À¦qÀ¦·À¦ûÀ§?À§KÀ§QÀ§½À¨-À¨3À¨£À©À©WÀ©XÀ©ªÀ©¸À©¾ÀªÀª2Àª8ÀªÀª³Àª´ÀªöÀ«9À«IÀ«gÀ«hÀ«®À«´À¬À¬OÀ¬zÀ¬¼À¬½À­À­BÀ­À­…À­ÒÀ®#À®NÀ®—À®˜À®İÀ¯À¯.À¯/À¯tÀ¯¸À¯ÓÀ¯ãÀ¯äÀ°4À°À° À°¦À°îÀ°ôÀ±9À±XÀ±YÀ±™À±ÈÀ±åÀ±æÀ²&À²VÀ²}À²~À²³À²¹À³	À³VÀ³¡À³àÀ³æÀ´7À´†À´ØÀµ%ÀµoÀµ½ÀµËÀ¶À¶$À¶%À¶qÀ¶„À¶ŠÀ¶ÚÀ·(À·bÀ·«À·×À¸(À¸;À¸AÀ¸¸À¸¼À¸½À¹À¹=À¹CÀ¹À¹×Àº&ÀºuÀº¿Àº÷ÀºıÀ»HÀ»•À»ŞÀ¼À¼À¼hÀ¼µÀ½À½HÀ½•À½âÀ¾1À¾À¾ĞÀ¾ÖÀ¿$À¿sÀ¿§À¿­À¿şÀÀIÀÀƒÀÀ…ÀÀ†ÀÀĞÀÀøÀÁÀÁÀÁkÀÁ°ÀÁÃÀÁÄÀÁıÀÂÀÂÀÂeÀÂ‹ÀÂŒÀÂ˜ÀÂÜÀÂèÀÃ)ÀÃ*ÀÃ~ÀÃÀÃÀÃøÀÄ$ÀÄ%ÀÄ1ÀÄÀÄ»ÀÄ¼ÀÄÈÀÅ.ÀÅdÀÅeÀÅqÀÅÏÀÅûÀÅüÀÆÀÆnÀÆ¤ÀÆ¥ÀÆ±ÀÇ*ÀÇyÀÇzÀÇ†ÀÈÀÈ2ÀÈeÀÈfÀÈrÀÈñÀÉLÀÉMÀÉYÀÉàÀÊCÀÊDÀÊPÀÊÇÀËÀËÀË#ÀË¢ÀËùÀËúÀÌÀÌXÀÌxÀÌ×ÀÌÛÀÌÜÀÍ_ÀÍåÀÍæÀÍòÀÎÀÎ6ÀÎQÀÎlÀÎ‡ÀÎÀÎ²ÀÎÖÀÏ0ÀÏ4ÀÏ5ÀÏ»ÀĞHÀĞIÀĞUÀĞpÀĞŠÀĞ«ÀĞÆÀĞáÀĞüÀÑÀÑ,ÀÑPÀÑ¼ÀÑÀÀÑÁÀÒOÀÒtÀÒŠÀÒ ÀÒ¶ÀÒÌÀÒãÀÒøÀÓÀÓÀÓÀÓ8ÀÓXÀÓ”ÀÓ˜ÀÓ™ÀÔÀÔXÀÔYÀÔeÀÔÀÔ¡ÀÔİÀÔáÀÔâÀÕQÀÕ¡ÀÕ¢ÀÕ®ÀÕïÀÖÀÖbÀÖfÀÖgÀÖåÀ×ZÀ×[À×gÀ×œÀ×ÎÀ×ÒÀ×ÓÀØ%ÀØbÀØcÀØoÀØÀØ°ÀØÔÀØØÀØÙÀÙ#ÀÙQÀÙRÀÙ^ÀÙ¡ÀÙÅÀÙàÀÚÀÚVÀÚcÀÚÀÚ¤ÀÚ¨ÀÚ©ÀÛ	ÀÛKÀÛLÀÛ¾ÀÜÀÜÀÜ+ÀÜuÀÜ™ÀÜ´ÀÜÜÀİ0Àİ=ÀİÀİ…Àİ‰ÀİŠÀİñÀŞ:ÀŞ;ÀŞ³ÀßÀßÀß&ÀßsÀßŒÀßÀß™ÀßæÀßÿÀà ÀàÀà,ÀàOÀàyÀà}Àà~ÀàŞÀáÀáÀáÀá8Àá\ÀáŠÀá²ÀáÃÀáÇÀáÈÀâÀâ[Àâ\ÀâhÀâÀâ¶ÀâäÀãÀãÀãÀãÀãlÀã«Àã¬Àã¸ÀãÍÀãøÀä6Àä:Àä;Àä€Àä¥Àä¦ÀåÀåQÀåRÀå^Àå™ÀåÆÀåÊÀåÌÀåÍÀæÀæÀæ!ÀæÀæÀæÀÀæÆÀæìÀçÀçÀç_ÀçeÀçºÀçæÀè#ÀèkÀèoÀèpÀèÀè•ÀèèÀé,ÀéEÀéFÀésÀéyÀéÊÀêÀê8ÀêOÀêPÀê€Àê†ÀêÖÀë%ÀëAÀëGÀë•ÀëäÀì3ÀìÀì’Àì×ÀíÀíÀíÀí[Àí_Àí°ÀíüÀîBÀîFÀîŒÀîÀîÜÀï+ÀïIÀïMÀï—ÀïçÀğÀğHÀğwÀğÍÀğÎÀğöÀğ÷ÀñÀñ5Àñ7Àñ8Àñ‡Àñ¡ÀñÜÀòÀòÀò#ÀòFÀòGÀòSÀònÀò¡ÀòÂÀòÚÀó=Àó™ÀôÀôÀôÀô6Àô:Àô;ÀôGÀô[Àô‚Àô²ÀôÅÀôËÀôãÀôõÀôùÀôûÀôüÀõ;Àõ?Àõ‡ÀõÒÀö ÀöDÀöHÀö–ÀöåÀ÷1À÷À÷ÏÀ÷İÀ÷ğÀøÀøLÀøÀøÁÀøÂÀøøÀøşÀùGÀù‘ÀùÚÀùñÀùòÀúÀúÀúkÀú±ÀûÀû Àû7Àû8ÀûcÀûiÀû¹Àü ÀüNÀüÀüÖÀüÜÀı*ÀızÀıÉÀşÀşÀşÀş<Àş=ÀşÀş´ÀşºÀÿ	ÀÿVÀÿnÀÿtÀÿ©Àÿ¯ÀÿõÀ 'À hÀ lÀ mÀ ¶À ¼À şÀBÀÀíÀñÀòÀşÀfÀhÀiÀ¤ÀÙÀşÀÀÀXÀšÀ›À¿À5ÀWÀ[À\À½ÀêÀëÀ/À_À­ÀğÀ+ÀGÀZÀgÀ}À£ÀÈÀÑÀ×ÀÛÀÜÀ7À}À~À½ÀäÀZÀˆÀËÀÜÀàÀáÀ	QÀ	¿À	ÀÀ	äÀ
ZÀ
~À
‚À
ƒÀ
áÀÀÀ:À?À”À¾ÀÖÀÀÀ/À5ÀFÀJÀKÀ¥ÀËÀÌÀÀÀ_ÀÀÀ‚À·ÀóÀÀ<À=ÀŠÀÍÀ×ÀØÀ&ÀrÀ À©ÀªÀ÷ÀHÀ‹À”À•ÀåÀóÀüÀşÀÿÀLÀœÀ®À²ÀÀÀaÀgÀ›À¡ÀòÀøÀGÀ•ÀåÀöÀüÀKÀQÀwÀ}ÀÀ“ÀàÀùÀ
ÀÀ À!À;ÀRÀSÀ™ÀäÀÀDÀEÀQÀtÀ“ÀµÀØÀÜÀİÀéÀÀÀ)ÀzÀ|À}ÀÎÀÀkÀ·ÀèÀìÀ5ÀBÀmÀºÀÀOÀUÀ¦ÀôÀ!À\ÀtÀ”À¬ÀÈÀÉÀÀZÀoÀuÀÂÀêÀğÀ#ÀVÀ‰À¼ÀïÀõÀDÀÀ–À¤ÀäÀûÀÀ)À@ÀJÀTÀZÀlÀrÀ“À™À§ÀåÀ À À 9À UÀ _À iÀ oÀ öÀ üÀ!
À!GÀ!jÀ!À!°À!ÓÀ!İÀ!çÀ!íÀ"vÀ"|À"ŠÀ"ËÀ"ñÀ#À#=À#cÀ#mÀ#wÀ#§À#¾À#ÙÀ#óÀ$À$À$^À$nÀ$–À$­À$ÈÀ$àÀ%	À%
À%XÀ%sÀ%›À%²À%ÍÀ%åÀ&À&À&&À&EÀ&dÀ&wÀ&xÀ&¨À&İÀ'!À'jÀ'³À'´À'ÌÀ'ØÀ(%À(&À(OÀ(dÀ({À(¯À(ÆÀ(ĞÀ(øÀ)À)?À)]À)tÀ)~À)ÉÀ)óÀ*À*LÀ*pÀ*¥À*´À*öÀ*üÀ+ À+À+À+0À+\À+pÀ+vÀ+–À+¶À+íÀ,À,:À,>À,?À,KÀ,`À,ŠÀ,íÀ,ñÀ,òÀ,şÀ-À-4À-KÀ-„À-À-ÌÀ-ğÀ."À.FÀ.xÀ.‡À.¬À.²À.¶À.·À.ÃÀ.ÙÀ.îÀ/À/>À/WÀ/†À/ªÀ/ÜÀ0 À02À0AÀ0İÀ0ãÀ0çÀ0éÀ0êÀ1(À1,À1|À1ÇÀ2À2/À2jÀ2ŒÀ2ÄÀ2ØÀ3À3À3À3BÀ3|À3À3ÉÀ3ÍÀ3üÀ4AÀ4UÀ4sÀ4wÀ4xÀ4§À4ìÀ5 À5À5"À5#À5qÀ5—À5´À5µÀ5õÀ6À6À6{À6°À6±À7À75À76À7šÀ7ÄÀ7ÅÀ8)À8SÀ8UÀ8VÀ8‰À8À8›À8ŸÀ8îÀ9;À9ŠÀ9²À9şÀ:)À:FÀ:˜À:ÅÀ:ÆÀ;À;qÀ;ÊÀ;ÎÀ;ÏÀ<À<bÀ<±À<ôÀ<øÀ<ùÀ==À=À=İÀ>À>#À>$À>hÀ>nÀ>¼À?À?8À?„À?¤À?âÀ?èÀ@JÀ@NÀ@OÀ@™À@ŸÀ@îÀA%ÀAJÀA¦ÀAîÀAòÀAóÀBDÀB‘ÀB¸ÀB¹ÀCÀC:ÀCZÀC\ÀC]ÀCÀCÚÀCÛÀCõÀDÀDÀD<ÀD€ÀDŒÀDÃÀDÄÀDĞÀEÀEÀE ÀEdÀEeÀEqÀE”ÀEÀÀEÔÀEÚÀFÀF1ÀFcÀFgÀFhÀFtÀF¼ÀF¾ÀF¿ÀF÷ÀG[ÀG\ÀGsÀGŠÀG¥ÀG¦ÀGºÀGüÀHÀH?ÀH@ÀH[ÀHsÀHÀHËÀHüÀI'ÀI-ÀI1ÀI2ÀI>ÀIˆÀI‰ÀI•ÀIàÀIáÀIíÀJÀJ<ÀJPÀJVÀJƒÀJ¥ÀJÇÀJîÀJòÀJóÀJÿÀK2ÀK4ÀK5ÀKgÀK¯ÀK°ÀKÈÀKàÀKáÀL%ÀL1ÀLhÀLiÀLuÀLµÀL¶ÀLÂÀMÀMÀMÀM3ÀM_ÀMsÀMyÀM ÀMÄÀMéÀMíÀMîÀMúÀN/ÀN1ÀN2ÀNcÀNªÀN«ÀNÃÀNÛÀNÜÀOÀO+ÀObÀOcÀOoÀO®ÀO¯ÀO»ÀOûÀOüÀPÀP+ÀPWÀPkÀPqÀP—ÀP»ÀPàÀPäÀPåÀPñÀQ&ÀQ(ÀQ)ÀQ\ÀQ­ÀQ®ÀQÏÀQğÀQñÀRÀRQÀR]ÀR”ÀR•ÀR¡ÀSÀSÀSÀSnÀSoÀS{ÀSÀSÊÀSŞÀSäÀTÀT8ÀTeÀTiÀTjÀTvÀT³ÀTµÀT¶ÀTõÀTùÀUIÀUœÀUàÀVÀVWÀVŒÀV¥ÀV¹ÀVıÀWÀWÀWOÀW•ÀWÆÀWßÀWóÀX$ÀX(ÀX)ÀXmÀX¿ÀXîÀYÀYÀYKÀYOÀYPÀY”ÀYšÀYèÀZ2ÀZcÀZ|ÀZ ÀZŞÀZäÀZøÀ[2À[6À[7À[iÀ[œÀ[µÀ[ÉÀ\À\3À\7À\8À\kÀ\ŸÀ\¸À\ÌÀ]"À]xÀ]±À]µÀ]¶À]öÀ^À^À^…À^ÌÀ^ÍÀ_6À_sÀ_tÀ_ÜÀ`À`À`sÀ`¸À`¹ÀaÀaUÀaVÀaÆÀbÀbÀbhÀbÀb«Àb­Àb®ÀbôÀc)Àc^Àc¨ÀcÄÀcàÀcîÀcïÀdÀdÀd8Àd>ÀdÀdªÀdÂÀdÒÀdóÀeÀeÀe%Àe)Àe*ÀezÀeÀe£ÀeğÀf:ÀfƒÀfÍÀfÓÀgÀg+Àg;ÀgZÀgwÀgŠÀg”Àg˜ÀgšÀg›ÀgğÀh	ÀhÀhZÀh¨ÀhõÀiEÀiIÀiÀiòÀjKÀj£ÀjöÀkÀk#Àk}Àk¢Àk¦Àk´Àk¸ÀküÀlFÀl–ÀlÀÀm
ÀmRÀmyÀmÆÀnÀn.ÀniÀnyÀnÓÀnÙÀo%ÀokÀoqÀoÉÀoéÀoïÀpRÀpµÀqÀq Àq!ÀqrÀqxÀqĞÀr.ÀrZÀr`ÀrºÀsÀsÀsƒÀséÀtNÀtZÀt[Àt®Àt´ÀuÀudÀuºÀuÕÀuÛÀv5Àv‹Àv Àv¦Àw
ÀwnÀwÑÀwÛÀwÜÀxÀx"Àx|Àx×ÀxçÀxíÀyFÀyfÀylÀyÏÀz2Àz”ÀzÀzŸÀz ÀzÑÀzùÀ{+À{TÀ{uÀ{yÀ{ŠÀ{ŒÀ{À{ÁÀ{éÀ|#À|LÀ|jÀ|À|±À|ÔÀ|óÀ}À}À}'À})À}*À}gÀ}‰À}«À}ØÀ}ñÀ~
À~#À~<À~MÀ~OÀ~PÀ~˜À~œÀ~îÀÀÀÀÀÀ‘À¶ÀëÀñÀ€@À€‘À€ÛÀ*À{ÀÌÀ‚À‚>À‚DÀ‚“À‚ÉÀ‚ÏÀƒ2Àƒ•ÀƒùÀ„_À„eÀ„°À„öÀ…À…À…dÀ…·À…÷À†
À†À†*À†DÀ†bÀ†ŠÀ†¤À†ÉÀ†ìÀ‡(À‡;À‡hÀ‡¬À‡éÀˆQÀˆeÀˆÀÀˆÄÀˆÅÀ‰À‰0À‰6À‰…À‰ÖÀŠ ÀŠoÀŠÀÀ‹À‹aÀ‹ƒÀ‹‰À‹×ÀŒÀŒÀŒvÀŒÙÀ=À£À©ÀúÀ@À[ÀaÀ®ÀÀAÀGÀ“ÀáÀ+ÀyÀÈÀíÀ‘ À‘À‘&À‘@À‘^À‘†À‘ À‘³À‘ĞÀ‘÷À’3À’FÀ’sÀ’°À“À“À“~À“ÚÀ”À”4À”À”«À•À•*À•¶À•¼À•ÀÀ•ÁÀ–À–/À–5À–€À–ÎÀ—	À—À—^À—¯À—ùÀ˜HÀ˜™À˜êÀ™:À™\À™bÀ™²À™óÀ™ùÀš[Àš½À› À›…À›‹À›ÚÀœ*ÀœMÀœSÀœ ÀœóÀ3ÀEÀXÀrÀÀ¸ÀÕÀøÀÀ9À_À›À®ÀÛÀŸÀŸ€ÀŸ”À 	À À À KÀ kÀ lÀ ÛÀ¡^À¡_À¡ŞÀ¡ûÀ¢À¢'À¢<À¢TÀ¢sÀ¢‡À¢¤À¢¥À£EÀ£cÀ£xÀ£À£§À£ºÀ£ÍÀ£åÀ£ıÀ¤À¤0À¤MÀ¤NÀ¤ÔÀ¤ğÀ¥À¥À¥4À¥SÀ¥gÀ¥€À¥—À¥³À¥´À¥×À¦À¦+À¦KÀ¦£À¦«À¦¸À¦èÀ§DÀ§LÀ§RÀ§VÀ§XÀ§YÀ§—À§¿À§åÀ§ëÀ¨'À¨vÀ¨¼À¨îÀ¨ôÀ©DÀ©“À©¡À©§À©îÀª4ÀªaÀªgÀª­ÀªıÀ«JÀ«gÀ«ƒÀ«ÑÀ«óÀ«úÀ¬À¬,À¬LÀ¬ŠÀ¬À¬¤À­À­0À­NÀ­TÀ­XÀ­YÀ­eÀ­xÀ­À­À­¡À­¢À­âÀ®À®À®À®ïÀ®ğÀ¯;À¯`À¯¨À¯ÄÀ¯ÆÀ¯ÇÀ°À°&À°*À°TÀ°¤À°âÀ°şÀ±.À±BÀ±vÀ±“À±²À±¸À±ÈÀ±åÀ±øÀ²À²À²À²À²À²cÀ²iÀ²²À²÷À³DÀ³ZÀ³˜À³İÀ´&À´pÀ´À´åÀµ/ÀµJÀµÀµ…Àµ·À¶À¶RÀ¶hÀ¶pÀ¶tÀ¶uÀ¶®À¶ÿÀ·MÀ·À·©À·öÀ¸(À¸)À¸^À¸©À¸÷À¹#À¹uÀ¹“À¹¡À¹§À¹¨À¹àÀ¹ûÀº	ÀºÀºÀºLÀºiÀºšÀº Àº¤Àº¥ÀºÁÀºàÀºáÀºıÀ»À»À»\À»|À»}À»ÙÀ¼À¼À¼AÀ¼•À¼—À¼˜À¼ËÀ¼ÏÀ½À½LÀ½œÀ½êÀ¾À¾À¾aÀ¾®À¾üÀ¿EÀ¿~À¿©ÀÀÀÀ.ÀÀ=ÀÀ_ÀÀ|ÀÀƒÀÀ‡ÀÀˆÀÀ¤ÀÀ¥ÀÀåÀÁÀÁÀÁFÀÁLÀÁšÀÁèÀÂ3ÀÂÀÂÑÀÂûÀÃÀÃHÀÃNÀÃ\ÀÃxÀÃšÀÃ¹ÀÃÔÀÃŞÀÃäÀÄ2ÀÄ<ÀÄBÀÄPÀÄ¡ÀÄÌÀÄıÀÅ.ÀÅ4ÀÅgÀÅ²ÀÅıÀÆHÀÆ“ÀÆ™ÀÆÀÀÆêÀÆòÀÆüÀÇÀÇOÀÇ¤ÀÇµÀÇ»ÀÈÀÈ0ÀÈ…ÀÈ¡ÀÈ¥ÀÈ¦ÀÈÜÀÈâÀÉ:ÀÉ}ÀÉƒÀÉĞÀÉñÀÊ"ÀÊvÀÊ¡ÀÊ¥ÀÊ¦ÀÊèÀÊîÀË=ÀË‰ÀËÄÀËĞÀËãÀËøÀÌÀÌ*ÀÌ.ÀÌ/ÀÌ”ÀÌúÀÌûÀÍfÀÍ£ÀÍ¤ÀÎ ÀÎ%ÀÎ&ÀÎyÀÎ•ÀÎ—ÀÎ˜ÀÎéÀÎíÀÏÀÏMÀÏ_ÀÏ§ÀÏ´ÀÏµÀĞÀĞÀĞÀĞfÀĞ{ÀĞÀĞÌÀÑ
ÀÑKÀÑZÀÑ\ÀÑ]ÀÑ•ÀÑ™ÀÑèÀÒ.ÀÒyÀÒÅÀÓÀÓ;ÀÓ?ÀÓŒÀÓÚÀÔ)ÀÔ9ÀÔ=ÀÔ‰ÀÔØÀÕ'ÀÕtÀÕÁÀÖÀÖ`ÀÖ­ÀÖÈÀÖÌÀ×À×cÀ×°À×ÒÀ×ÖÀØ%ÀØjÀØ·ÀÙÀÙYÀÙ©ÀÙÌÀÚÀÚJÀÚPÀÚÀÚëÀÛ9ÀÛ„ÀÛ³ÀÛ¹ÀÜÀÜ/ÀÜ5ÀÜ†ÀÜÔÀİ#Àİ`Àİ~Àİ„ÀİÓÀŞ"ÀŞ(ÀŞzÀŞ£ÀŞ©ÀŞùÀßJÀß›ÀßçÀà5Àà€ÀàËÀàÛÀàáÀá/ÀáYÀá_ÀáÀá£ÀáïÀâ@Àâ‘ÀâİÀãÀãÀã%ÀãCÀã\Àã‚ÀãšÀã¡ÀãàÀä+Àä1ÀäˆÀäßÀäåÀå Àå@ÀårÀå‘ÀåİÀæ$ÀæoÀæ|Àæ†ÀæÀæ”ÀæÚÀç*ÀçWÀçeÀç™ÀçºÀçÈÀçÿÀè$Àè2Àè3Àè£ÀèåÀèëÀèïÀèğÀéAÀépÀévÀéÄÀêÀê_ÀêªÀêÙÀêßÀë,ÀëvÀëÂÀìÀì$Àì*Àì{ÀìÊÀíÀíbÀí³ÀîÀî9Àî?ÀîÀîİÀï.ÀïwÀï°Àï¶ÀğÀğWÀğ¨ÀğøÀñBÀñÀñßÀòÀòÀò`Àò°ÀòÿÀó-Àó3ÀóqÀóÀó–Àó³ÀóÊÀóïÀôÀôÀô4Àô¤ÀôªÀôíÀõ8Àõ>Àõ•ÀõìÀõòÀöÀöMÀöƒÀö¢ÀöîÀ÷:À÷…À÷’À÷œÀ÷¤À÷ªÀ÷şÀø@ÀøFÀøJÀøKÀø­ÀøàÀùÀù;ÀùyÀù©ÀùÜÀùİÀú-ÀúPÀúcÀú{Àú‹Àú£Àú¶ÀúÀÀúĞÀúÔÀúÕÀû ÀûEÀûŠÀû¦Àû§ÀûÁÀüÀüÀü_ÀüuÀüÀü¤Àü´ÀüĞÀüãÀüíÀı^ÀıbÀıdÀıeÀı³Àı·ÀıóÀş7ÀşHÀşjÀşpÀş¾ÀÿÀÿAÀÿGÀÿ”ÀÿãÀÿùÀ À À >À DÀ ŠÀ À ÒÀ èÀ ñÀ òÀ(À.ÀpÀ†À‘À“À”ÀŞÀêÀîÀÀÀSÀaÀbÀ›À¨ÀªÀ«ÀàÀäÀ+ÀoÀ°À´ÀıÀMÀ–À³À·ÀÀPÀ…À‰ÀÖÀÀ-ÀpÀÀ”ÀİÀ%ÀuÀÄÀÀTÀZÀ¡À·À	À	À	PÀ	VÀ	‚À	ˆÀ	˜À	À	ïÀ
$À
3À
4À
…À
ÖÀ%ÀnÀ}ÀƒÀÏÀ ÀnÀ¶ÀÀNÀTÀ¡À§ÀËÀÑÀÀkÀ»ÀÀ0À6À„ÀÍÀÀlÀºÀ
ÀRÀÀ…ÀÏÀèÀîÀüÀ)ÀQÀhÀ¨ÀÑÀÀAÀ[ÀuÀ}À‡ÀÀÜÀ*ÀxÀ–ÀœÀªÀ×ÀÀBÀYÀ™ÀĞÀ	À#À+À5À;ÀŒÀÒÀÀ"À0À]ÀtÀÈÀÀÀ2À“ÀÌÀæÀîÀøÀşÀIÀ’ÀãÀÀ!ÀEÀKÀŠÀÀŞÀ,À}ÀÈÀÀeÀ°ÀûÀLÀÀ¸À¾ÀÎÀÔÀ$ÀFÀÀ¤ÀÑÀÒÀÀ1À7ÀvÀ|ÀÅÀ 	À À À xÀ ÅÀ!À!À!\À!bÀ!°À" À""À"DÀ"EÀ"ˆÀ"ÍÀ#À#IÀ#OÀ#tÀ#ŠÀ#‹À#ÛÀ$+À$SÀ$TÀ$£À$íÀ$şÀ%À%JÀ%\À%ƒÀ%„À%ÙÀ%øÀ%ùÀ&JÀ&–À&åÀ'À'1À'2À'‚À'½À'äÀ'åÀ(8À(À(ªÀ(°À)À)PÀ) À)ÍÀ)ëÀ)ìÀ*:À*QÀ*WÀ*­À*³À*÷À*ıÀ+OÀ+—À+ÀÀ+ÆÀ,À,$À,À,€À,ÎÀ,íÀ,óÀ-JÀ-PÀ-”À-šÀ-ìÀ.4À.„À.¾À.¿À/À/!À/'À/}À/ƒÀ/ÇÀ/ÍÀ0À0gÀ0À0ÇÀ0ÈÀ1À1kÀ1¾À1ÏÀ1ÕÀ2)À2|À2ÎÀ3À3lÀ3¿À4À4aÀ4²À4ÎÀ4ÔÀ5À5^À5²À6À6CÀ6IÀ6—À6¾À6ÄÀ6ÒÀ6óÀ7À7KÀ7ˆÀ7§À7áÀ8À8,À84À8>À8DÀ8•À8áÀ9<À9À9 À9¦À9ìÀ:9À:mÀ:sÀ:ÃÀ;À;^À;vÀ;‹À;¨À;©À;úÀ<LÀ<ŸÀ<¥À<õÀ=GÀ=—À=çÀ>9À>À>àÀ>íÀ>óÀ?(À?KÀ?LÀ?À?ÛÀ?øÀ@,À@-À@|À@ÄÀ@ÊÀAÀAÀA‰ÀAøÀB,ÀB-ÀB\ÀBbÀB§ÀBÂÀBáÀBâÀC2ÀCmÀCsÀCŞÀDMÀDvÀDwÀDÈÀE
ÀEÀE|ÀEìÀFÀFÀFiÀF¹ÀFßÀFåÀG*ÀGdÀGeÀG²ÀHÀH&ÀH,ÀH—ÀIÀI/ÀI0ÀI{ÀIÍÀJÀJ?ÀJEÀJ²ÀK#ÀK\ÀK]ÀK™ÀKŸÀKßÀL,ÀLvÀLÊÀMÀMkÀM—ÀMÀNÀNÀN…ÀNİÀO;ÀO<ÀOqÀOwÀOÀÀP	ÀP5ÀP^ÀP_ÀP­ÀQÀQ?ÀQ@ÀQÀQÛÀQáÀR0ÀRIÀROÀR›ÀRäÀR÷ÀS;ÀS<ÀSƒÀS‰ÀS×ÀT%ÀTrÀT¿ÀUÀUÀUVÀU£ÀUñÀV8ÀVIÀVÀV‘ÀVØÀVñÀWÀWÀWcÀWsÀWyÀWÄÀWÑÀW×ÀX#ÀXpÀX®ÀX´ÀYÀYOÀYUÀY¦ÀYóÀZ@ÀZFÀZÀZÜÀ[)À[cÀ[dÀ[©À[¯À[öÀ[üÀ\BÀ\ŒÀ\’À\¢À\¨À\øÀ]À][À]\À]¡À]§À]÷À^DÀ^JÀ^À^ÚÀ^àÀ^ğÀ^öÀ_DÀ_bÀ_®À_¯À_ùÀ_ÿÀ`KÀ`\À`bÀ`«À`üÀaÀaÀabÀa°ÀaüÀbDÀb”ÀbßÀc*ÀcyÀcÆÀdÀdJÀdPÀdwÀd}ÀdÀdŞÀe*ÀeQÀe£ÀeíÀeîÀf2Àf8Àf‰ÀfâÀg5Àg‰ÀgÁÀgÇÀhÀhhÀh·Ài	ÀiYÀi­ÀiùÀiÿÀjPÀj ÀjõÀkLÀk|ÀkĞÀlÀlbÀlhÀl»Àm
ÀmUÀm£ÀmøÀmşÀnRÀn£ÀnìÀnòÀoCÀo^ÀodÀorÀo‡Ào°ÀoÃÀoÚÀoâÀoèÀpÀpLÀpRÀp«ÀpÉÀpêÀpğÀqÀq1ÀqRÀq‰Àq½ÀqçÀrÀr"Àr_Àr}Àr›ÀráÀsÀs=ÀsNÀscÀs—ÀsÚÀtÀtÀtÀt Àt(Àt2Àt8Àt‘Àt—Àt¥ÀtºÀtşÀuÀu(Àu;ÀuTÀu\ÀubÀuÀuÆÀuÌÀv%ÀvCÀvdÀvjÀv|Àv«ÀvÌÀwÀw7ÀwaÀwŒÀw¨ÀwåÀxÀx!ÀxgÀx•ÀxÃÀxÔÀxéÀyÀy`ÀyvÀyªÀyŞÀz
ÀzÀzÀz)Àz1Àz;ÀzAÀzŠÀzÕÀ{À{À{À{$À{rÀ{‰À{§À{ÖÀ{ùÀ|À|FÀ|gÀ|†À|‡À|ËÀ|ÑÀ}"À}{À}ÎÀ~"À~tÀ~ÆÀ~ıÀÀSÀ›À¡ÀòÀ€2À€]À€cÀ€±À€ûÀÀMÀšÀêÀğÀ‚KÀ‚\À‚bÀ‚pÀ‚…À‚®À‚ÁÀ‚ØÀ‚àÀ‚æÀƒÀƒJÀƒPÀƒ©ÀƒÇÀƒèÀƒîÀ„ À„/À„À„ÎÀ…À…;À…€À…ÊÀ†À†-À†cÀ†ŒÀ†³À†ãÀ‡À‡À‡jÀ‡ÅÀˆÀˆaÀˆÀˆ¹ÀˆøÀ‰7À‰CÀ‰dÀ‰ÂÀ‰ÌÀ‰ÒÀ‰áÀ‰éÀ‰óÀ‰ùÀŠRÀŠXÀŠfÀŠ{ÀŠ¿ÀŠÒÀŠéÀŠüÀ‹À‹À‹#À‹QÀ‹‡À‹À‹æÀŒÀŒ%ÀŒ+ÀŒ=ÀŒlÀŒ¼ÀÀ\ÀxÀ½ÀÀEÀ}À¨ÀŞÀÀ.À^À†ÀŒÀçÀ>À™ÀöÀ‘AÀ‘‡À‘°À‘ÊÀ’À’!À’=À’À’­À’ÙÀ’èÀ“À“VÀ“‹À“ÀÀ“ÆÀ” À”zÀ”ÒÀ•À•HÀ•TÀ•uÀ•ãÀ•íÀ•óÀ–À–
À–À–À–*À–0À–}À–’À–³À–âÀ—	À—0À—ZÀ—~À— À—¡À—îÀ—ôÀ˜DÀ˜YÀ˜_À˜…À˜ÜÀ˜ŞÀ˜ßÀ™-À™nÀ™À™ëÀ™ñÀš%ÀšDÀšcÀš¿ÀšÃÀšÄÀ›.À›£À›¤Àœ Àœ\Àœ¡ÀœÆÀœÇÀœÓÀ!À9À:À]ÀuÀ‘ÀºÀãÀÀ5À>ÀDÀUÀYÀZÀfÀ”À®ÀêÀ÷ÀŸÀŸ€ÀŸ†ÀŸŠÀŸ‹ÀŸíÀ GÀ HÀ ½À¡@À¡AÀ¡MÀ¡À¡¹À¡ºÀ¡ÆÀ¢%À¢PÀ¢QÀ¢]À¢´À¢ÓÀ¢ÔÀ¢àÀ£CÀ£tÀ£uÀ£À£ÀÀ£ÁÀ¤ À¤NÀ¤OÀ¤[À¤³À¤ÛÀ¤ÜÀ¤èÀ¥FÀ¥rÀ¥sÀ¥À¥§À¥ÇÀ¦À¦À¦$À¦(À¦)À¦vÀ¦§À¦¨À¦´À¦ÓÀ§À§ À§4À§8À§9À§‰À§½À§¾À§ÊÀ¨&À¨FÀ¨`À¨­À¨ûÀ©=À©•À©™À©šÀªÀªˆÀª‰Àª•ÀªĞÀªòÀ«$À«(À«)À«|À«½À«¾À«ÊÀ¬À¬3À¬7À¬8À¬‘À¬ĞÀ¬ÑÀ¬İÀ¬ûÀ­*À­KÀ­‘À­•À­–À­ìÀ®%À®&À®2À®VÀ®…À®¬À®òÀ®öÀ®÷À¯SÀ¯’À¯“À¯ŸÀ¯ÔÀ°À°À°À°iÀ°ŸÀ° À°¬À°áÀ±À±!À±iÀ±mÀ±nÀ±âÀ²ZÀ²[À²gÀ²‡À²´À²¸À²¹À³À³[À³\À³hÀ³’À³²À³ÌÀ´
À´fÀ´lÀ´pÀ´qÀ´åÀµgÀµhÀµtÀµ¡ÀµÃÀ¶À¶	À¶
À¶gÀ¶ÇÀ¶ÈÀ¶ÔÀ·À·1À·SÀ·«À·¯À·°À¸À¸ŠÀ¸‹À¸—À¸ÁÀ¸áÀ¸ûÀ¹9À¹•À¹›À¹ŸÀ¹ ÀºÀº–Àº—Àº£ÀºİÀºüÀ»>À»BÀ»CÀ»±À¼"À¼#À¼/À¼À¼®À½*À½.À½/À½¸À½ÒÀ½åÀ½÷À¾À¾ À¾9À¾RÀ¾hÀ¾‹À¾¦À¾§À¾³À¾İÀ¿À¿"À¿#À¿†À¿äÀ¿åÀ¿ñÀÀ-ÀÀOÀÀsÀÀõÀÁÀÁ\ÀÁbÀÁfÀÁgÀÁäÀÂnÀÂoÀÂ{ÀÂÀÀÂâÀÃÀÃ ÀÃWÀÃŠÀÃ¼ÀÃğÀÄ%ÀÄXÀÄŠÀÄ¾ÀÄóÀÅ,ÀÅbÀÅ§ÀÅÀÀÆÀÆÀÆÀÆÀÆÊÀÆíÀÇÀÇÀÇ,ÀÇCÀÇ[ÀÇqÀÇ†ÀÇÀÇµÀÇØÀÇòÀÈÀÈÀÈÀÈfÀÈˆÀÈªÀÈÉÀÉ ÀÉ6ÀÉkÀÉ¢ÀÉÚÀÊÀÊ?ÀÊsÀÊ¨ÀÊáÀËÀË\ÀËuÀËÃÀËÉÀËÍÀËÎÀÌÀÌ¢ÀÌ¶ÀÌÏÀÌçÀÍÀÍÀÍ2ÀÍGÀÍ^ÀÍvÀÍ™ÀÍ³ÀÍÒÀÍÓÀÍßÀÎÀÎ)ÀÎVÀÎZÀÎ[ÀÎ±ÀÎçÀÎèÀÎôÀÏ/ÀÏ{ÀÏ§ÀÏËÀÏöÀĞ.ÀĞ2ÀĞ3ÀĞ?ÀĞŠÀĞãÀĞçÀĞèÀĞôÀÑAÀÑcÀÑ®ÀÑ´ÀÑûÀÑÿÀÒ ÀÒeÀÒÖÀÒ×ÀÒãÀÓ.ÀÓSÀÓÀÓ¢ÀÓ£ÀÔÀÔƒÀÔ„ÀÔÀÔ®ÀÔİÀÕ ÀÕ&ÀÕMÀÕnÀÕÀÕ°ÀÕóÀÕôÀÖÀÖFÀÖ‘ÀÖ—ÀÖäÀ×LÀ×RÀ×SÀ×šÀ×ÙÀ×ÚÀØÀØ$ÀØIÀØnÀØ“ÀØÉÀØëÀÙÀÙCÀÙyÀÙ­ÀÙáÀÚÀÚ,ÀÚSÀÚ{ÀÚÀÚ‚ÀÚëÀÛ,ÀÛdÀÛeÀÛ‹ÀÛêÀÜ0ÀÜ7ÀÜ8ÀÜQÀÜŸÀÜ¥ÀÜ©ÀÜªÀÜ¶ÀÜ×ÀİÀİ-ÀİTÀİ~Àİ¢ÀİÅÀİöÀİ÷ÀŞÀŞLÀŞšÀŞ ÀŞ¾ÀßÀß"Àß^Àß×ÀßİÀàÀàÀà<Àà‘ÀàÛÀàâÀàãÀàüÀáJÀáPÀáTÀáUÀáéÀâÀâ+ÀâEÀâcÀâwÀâ˜Àâ±ÀâÊÀâßÀâıÀâşÀã
ÀãbÀãµÀã¹ÀãºÀä%Àä‹ÀäÀäÀä¼ÀäûÀäüÀåDÀåHÀå|Àå€ÀåÇÀæ	ÀæKÀædÀæ£Àæ©ÀæôÀç6ÀçWÀç€ÀçÀçÂÀçÈÀèÀèVÀèwÀè¡Àè¢ÀèÌÀèÒÀé!ÀépÀé¹ÀééÀéêÀê,Àê2ÀêiÀê¸ÀëÀëPÀëVÀë¦ÀëôÀì!Àì'ÀìwÀìÀÀìÙÀìßÀí.ÀíCÀíoÀípÀíÀÀíãÀíõÀíöÀî<ÀîBÀîÀî¦ÀîÀÀîÁÀï
ÀïÀïaÀï“Àï³ÀïµÀï¶ÀğÀğPÀğlÀğrÀğ¨Àğ¾Àğ¿ÀğËÀğüÀñÀñ9ÀñmÀñsÀñ‰ÀñÙÀñöÀòÀò!Àò`ÀòjÀòtÀò{ÀòÀò€ÀòŞÀó3Àó4Àó@ÀómÀó…ÀóªÀóŞÀóäÀóåÀô
Àô2ÀôhÀôlÀômÀôÍÀõÀõÀõ Àõ3ÀõKÀõ[ÀõsÀõ†ÀõÀõ³ÀõÃÀõÇÀõÈÀöÀö8Àö|Àö˜Àö™Àö³Àö´ÀöÀÀöÛÀöïÀöÿÀ÷À÷.À÷8À÷¨À÷¬À÷­À÷¹ÀøÀø@ÀøBÀøCÀøŠÀøÀøÓÀùÀù9ÀùzÀùÁÀùİÀúÀúÀúOÀúUÀú™ÀúàÀûÀû\Àû˜Àû°Àû±ÀûàÀûæÀü1ÀüÀüÆÀüàÀüâÀüãÀıCÀırÀısÀı·Àı×ÀıØÀıäÀşÀşÀşÀş7ÀşRÀş–ÀşœÀşÓÀşïÀÿÀÿ"ÀÿuÀÿ¼ÀÿáÀÿõÀÿùÀÿúÀ SÀ À À ¨À ªÀ «À ÀÀ ÄÀ ÀÀ)À/ÀzÀÅÀßÀåÀ&À,À{À”À¥ÀÓÀòÀÀbÀcÀ“À·ÀáÀÀ3ÀZÀ„À…ÀµÀ»ÀÀ0ÀEÀFÀ…À‹ÀÙÀ%ÀgÀ~ÀÀÑÀìÀíÀÀ%ÀXÀ^À‹ÀşÀ4ÀhÀlÀmÀ©À¯ÀâÀ	À	À	lÀ	rÀ	¯À	şÀ
%À
+À
oÀ
¸ÀÀ)À=ÀPÀfÀ©À­À®À ÀÀ.ÀAÀUÀtÀ›À¢À¦À§À×ÀİÀ&ÀkÀÀ•À»ÀÀRÀÀéÀ7À‡ÀÔÀÀÀmÀÀ¢ÀÚÀïÀÀÀ*ÀKÀSÀ`ÀwÀ’À¡À¸ÀëÀ"ÀdÀoÀwÀ}ÀÀ‚À»ÀÁÀ	ÀÀ2À€À¢ÀµÀ»ÀÑÀçÀÀNÀ~À­À³ÀêÀÀÀNÀoÀuÀˆÀŒÀÀ™À¼ÀŞÀñÀ÷ÀÀ2ÀTÀÀƒÀ„ÀÀÎÀÏÀÀmÀ‰ÀÃÀŞÀøÀşÀÿÀ<ÀrÀsÀÀÚÀÀAÀBÀ{ÀÂÀÃÀúÀ'À(À_ÀŒÀÀÜÀÀ<ÀBÀCÀ[À_À`ÀlÀ¯À±À²ÀùÀıÀLÀbÀ ÀÃÀÄÀÀ'ÀhÀ­ÀßÀÀ*À.À/ÀiÀoÀ¨ÀæÀ+ÀtÀ¾ÀëÀ 3À nÀ ŸÀ ÛÀ öÀ!À!<À!DÀ!mÀ!uÀ!yÀ!zÀ!«À!±À!êÀ"'À"bÀ"“À"ÈÀ"ãÀ"ıÀ#7À#?À#hÀ#pÀ#tÀ#uÀ#ÉÀ$À$À$kÀ$¸À$¹À%À%aÀ%bÀ%–À%³À%ÂÀ%ÃÀ%âÀ%ãÀ&À&À&cÀ&~À&–À&¦À&ÇÀ&ÚÀ&äÀ&ùÀ&ıÀ&şÀ'NÀ'qÀ'wÀ'ÄÀ(À([À(¨À(öÀ)À)'À)7À)VÀ)sÀ)†À)À) À)¤À)¥À)ğÀ*À*aÀ*}À*À*€À*ËÀ*ÏÀ+À+6À+WÀ+À+–À+æÀ,8À,RÀ,XÀ,¦À,ùÀ-:À-wÀ-–À-´À-ÌÀ-åÀ-øÀ.À.AÀ.BÀ.À.ĞÀ/À/LÀ/„À/¤À/¨À/©À/ÓÀ/ÙÀ0À0%À0&À0QÀ0WÀ0’À0¤À0¥À0×À0İÀ1À1-À1.À1~À1¡À1§À1òÀ2À2)À2*À2xÀ2”À2šÀ2åÀ32À3CÀ3IÀ3—À3¿À4À4
À4À4kÀ4‰À4ŠÀ4ÃÀ4ÉÀ5À5kÀ5…À5‹À5ÙÀ6,À6mÀ6ªÀ6ÈÀ6æÀ6şÀ7À7*À7PÀ7WÀ7kÀ7À7ÆÀ7ŞÀ8,À80À81À8“À8æÀ8çÀ9PÀ9ŞÀ9ßÀ9îÀ9ïÀ:HÀ:dÀ:eÀ:qÀ:œÀ:À:­À:®À;À;%À;&À;2À;`À;aÀ;xÀ;yÀ;ÚÀ;şÀ;ÿÀ<À<NÀ<OÀ<[À<§À<ÂÀ<ÃÀ<ÏÀ=À=RÀ=lÀ=rÀ=§À=ÂÀ=ÈÀ=ÉÀ> À>À>8À>vÀ>µÀ>óÀ?)À?/À?PÀ?rÀ?sÀ?À?ØÀ?êÀ?îÀ?ïÀ@ZÀ@°À@²À@³À@èÀAÀAÀAWÀAŸÀA ÀAØÀAÜÀB&ÀB3ÀBvÀBwÀB¸ÀBÔÀC)ÀC*ÀCyÀCÀC‘ÀCŞÀCûÀCşÀDJÀDMÀD_ÀDbÀDmÀD¡ÀD¤ÀDßÀEÀE!ÀE$ÀECÀEsÀExÀEÀE‚ÀE×ÀF-ÀFYÀF\ÀF²ÀFæÀGÀGcÀG§ÀGäÀGúÀH&ÀH;ÀHOÀH|ÀH‹ÀHËÀHÓÀHàÀHıÀIÀI	ÀIÀI2ÀINÀIRÀImÀIoÀIpÀI³ÀIùÀJ/ÀJvÀJºÀJ÷ÀKÀKHÀK]ÀKzÀK‡ÀK›ÀKÑÀKàÀL)ÀL1ÀL7ÀL=ÀLOÀLfÀL‚ÀL†ÀL¡ÀL£ÀL¤ÀLóÀMAÀMEÀM•ÀMåÀNÀNUÀNšÀN›ÀNĞÀNèÀNéÀO;ÀOVÀOWÀOcÀOyÀOÓÀOìÀPÀPKÀPtÀPzÀP˜ÀPœÀP  dart.ui€¬ O_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaint
ColorSpaceImageByteFormatPixelFormatImage_Image
_wrapImage	FrameInfoCodec_NativeCodecinstantiateImageCodecinstantiateImageCodecFromBufferinstantiateImageCodecWithSize_getDefaultImageSizeTargetImageSizedecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayer_NativeEngineLayerPath_NativePathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgramFragmentShader
VertexModeVertices	PointModeClipOpCanvas_NativeCanvasPicture_NativePicturePictureRecorder_NativePictureRecorderShadowImmutableBufferImageDescriptor_NativeImageDescriptor	_futurize_futurizeWithErrorPictureRasterizationException 15